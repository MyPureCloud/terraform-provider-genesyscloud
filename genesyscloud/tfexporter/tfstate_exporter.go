package tfexporter

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
	"terraform-provider-genesyscloud/genesyscloud/util"
	"terraform-provider-genesyscloud/genesyscloud/util/files"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
)

/*
This files contains all of the code used to create an export's Terraform state file.  The TFStateFileWriter struct encapsulates all the logic to write a Terraform state file.
The other functions in this file deal with how to generate the TFVars we create during the export.
*/
type TFStateFileWriter struct {
	ctx              context.Context
	resources        []resourceExporter.ResourceInfo
	d                *schema.ResourceData
	providerRegistry string
}

func NewTFStateWriter(ctx context.Context, resources []resourceExporter.ResourceInfo, d *schema.ResourceData, providerRegistry string) *TFStateFileWriter {
	tfwriter := &TFStateFileWriter{
		ctx:              ctx,
		resources:        resources,
		d:                d,
		providerRegistry: providerRegistry,
	}

	return tfwriter
}

func (t *TFStateFileWriter) writeTfState() diag.Diagnostics {
	stateFilePath, diagErr := getFilePath(t.d, defaultTfStateFile)
	if diagErr != nil {
		return diagErr
	}

	tfstate := terraform.NewState()
	for _, resource := range t.resources {
		resourceState := &terraform.ResourceState{
			Type:     resource.Type,
			Primary:  resource.State,
			Provider: "provider.genesyscloud",
		}
		tfstate.RootModule().Resources[resource.BlockType+resource.Type+"."+resource.BlockLabel] = resourceState
	}

	data, err := json.MarshalIndent(tfstate, "", "  ")
	if err != nil {
		return diag.Errorf("Failed to encode state as JSON: %v", err)
	}

	log.Printf("Writing export state file to %s", stateFilePath)
	if err := files.WriteToFile(data, stateFilePath); err != nil {
		return err
	}

	// This outputs terraform state v3, and there is currently no public lib to generate v4 which is required for terraform 0.13+.
	// However, the state can be upgraded automatically by calling the terraform CLI. If this fails, just print a warning indicating
	// that the state likely needs to be upgraded manually.
	cliError := `The generated tfstate file will need to be upgraded manually by running the following in the state file's directory:
	'terraform state replace-provider registry.terraform.io/-/genesyscloud registry.terraform.io/mypurecloud/genesyscloud'`

	if util.IsDebugServerExecution() {
		cliError = `The current process is running via a debug server (debug binary detected), and so it is unable to run the proper command to replace the state. Please run this command outside of a debug session.` + cliError
		log.Print(cliError)
		return nil
	}

	_, _, err = util.ExecutePlatformCommand(t.ctx, []string{
		"state",
		"replace-provider",
		"-auto-approve",
		"-state=" + stateFilePath,
		fmt.Sprintf("%s/-/genesyscloud", t.providerRegistry),
		fmt.Sprintf("%s/mypurecloud/genesyscloud", t.providerRegistry),
	})

	if err != nil {
		cliError = fmt.Sprintf(`Failed to run the terraform CLI to upgrade the generated state file: \n%s\n\n%s`, err, cliError)
		log.Print(cliError)
		// Don't fail everything even if this errors.
		return nil
	}
	return nil
}

func generateTfVarsContent(vars map[string]interface{}) string {
	tfVarsContent := ""
	for k, v := range vars {
		vStr := v
		if v == nil {
			vStr = "null"
		} else if s, ok := v.(string); ok {
			vStr = fmt.Sprintf(`"%s"`, s)
		} else if m, ok := v.(map[string]interface{}); ok {
			vStr = fmt.Sprintf(`{
	%s
}`, strings.Replace(generateTfVarsContent(m), "\n", "\n\t", -1))
		}
		newLine := ""
		if tfVarsContent != "" {
			newLine = "\n"
		}
		tfVarsContent = fmt.Sprintf("%v%s%s = %v", tfVarsContent, newLine, k, vStr)
	}

	return tfVarsContent
}

func writeTfVars(tfVars map[string]interface{}, path string) diag.Diagnostics {
	tfVarsStr := generateTfVarsContent(tfVars)
	tfVarsStr = fmt.Sprintf("// This file has been autogenerated. The following properties could not be retrieved from the API or would not make sense in a different org e.g. Edge IDs"+
		"\n// The variables contained in this file have been given default values and should be edited as necessary\n\n%s", tfVarsStr)

	log.Printf("Writing export tfvars file to %s", path)
	return files.WriteToFile([]byte(tfVarsStr), path)
}
