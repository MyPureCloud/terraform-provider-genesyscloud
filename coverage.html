
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>architect_grammar: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-genesyscloud/genesyscloud/architect_grammar/data_source_genesyscloud_architect_grammar.go (0.0%)</option>
				
				<option value="file1">terraform-provider-genesyscloud/genesyscloud/architect_grammar/genesyscloud_architect_grammar_proxy.go (10.5%)</option>
				
				<option value="file2">terraform-provider-genesyscloud/genesyscloud/architect_grammar/resource_genesyscloud_architect_grammar.go (14.5%)</option>
				
				<option value="file3">terraform-provider-genesyscloud/genesyscloud/architect_grammar/resource_genesyscloud_architect_grammar_schema.go (33.3%)</option>
				
				<option value="file4">terraform-provider-genesyscloud/genesyscloud/architect_grammar_language/genesyscloud_architect_grammar_language_proxy.go (0.0%)</option>
				
				<option value="file5">terraform-provider-genesyscloud/genesyscloud/architect_grammar_language/resource_genesyscloud_architect_grammar_language.go (0.0%)</option>
				
				<option value="file6">terraform-provider-genesyscloud/genesyscloud/architect_grammar_language/resource_genesyscloud_architect_grammar_language_schema.go (40.0%)</option>
				
				<option value="file7">terraform-provider-genesyscloud/genesyscloud/architect_grammar_language/resource_genesyscloud_architect_grammar_language_utils.go (0.0%)</option>
				
				<option value="file8">terraform-provider-genesyscloud/genesyscloud/architect_ivr/data_source_genesyscloud_architect_ivr.go (90.9%)</option>
				
				<option value="file9">terraform-provider-genesyscloud/genesyscloud/architect_ivr/genesyscloud_architect_ivr_proxy.go (76.1%)</option>
				
				<option value="file10">terraform-provider-genesyscloud/genesyscloud/architect_ivr/resource_genesyscloud_architect_ivr.go (74.7%)</option>
				
				<option value="file11">terraform-provider-genesyscloud/genesyscloud/architect_ivr/resource_genesyscloud_architect_ivr_schema.go (33.3%)</option>
				
				<option value="file12">terraform-provider-genesyscloud/genesyscloud/architect_ivr/resource_genesyscloud_architect_ivr_utils.go (100.0%)</option>
				
				<option value="file13">terraform-provider-genesyscloud/genesyscloud/external_contacts/data_source_genesyscloud_externalcontacts_contact.go (90.9%)</option>
				
				<option value="file14">terraform-provider-genesyscloud/genesyscloud/external_contacts/genesyscloud_externalcontacts_contact_proxy.go (62.3%)</option>
				
				<option value="file15">terraform-provider-genesyscloud/genesyscloud/external_contacts/resource_genesyscloud_externalcontacts_contact.go (75.7%)</option>
				
				<option value="file16">terraform-provider-genesyscloud/genesyscloud/external_contacts/resource_genesyscloud_externalcontacts_contact_schema.go (73.3%)</option>
				
				<option value="file17">terraform-provider-genesyscloud/genesyscloud/external_contacts/resource_genesyscloud_externalcontacts_contact_utils.go (100.0%)</option>
				
				<option value="file18">terraform-provider-genesyscloud/genesyscloud/flow_milestone/data_source_genesyscloud_flow_milestone.go (90.9%)</option>
				
				<option value="file19">terraform-provider-genesyscloud/genesyscloud/flow_milestone/genesyscloud_flow_milestone_proxy.go (56.4%)</option>
				
				<option value="file20">terraform-provider-genesyscloud/genesyscloud/flow_milestone/resource_genesyscloud_flow_milestone.go (70.9%)</option>
				
				<option value="file21">terraform-provider-genesyscloud/genesyscloud/flow_milestone/resource_genesyscloud_flow_milestone_schema.go (33.3%)</option>
				
				<option value="file22">terraform-provider-genesyscloud/genesyscloud/flow_milestone/resource_genesyscloud_flow_milestone_utils.go (100.0%)</option>
				
				<option value="file23">terraform-provider-genesyscloud/genesyscloud/flow_outcome/data_source_genesyscloud_flow_outcome.go (0.0%)</option>
				
				<option value="file24">terraform-provider-genesyscloud/genesyscloud/flow_outcome/genesyscloud_flow_outcome_proxy.go (0.0%)</option>
				
				<option value="file25">terraform-provider-genesyscloud/genesyscloud/flow_outcome/resource_genesyscloud_flow_outcome.go (0.0%)</option>
				
				<option value="file26">terraform-provider-genesyscloud/genesyscloud/flow_outcome/resource_genesyscloud_flow_outcome_schema.go (33.3%)</option>
				
				<option value="file27">terraform-provider-genesyscloud/genesyscloud/flow_outcome/resource_genesyscloud_flow_outcome_utils.go (0.0%)</option>
				
				<option value="file28">terraform-provider-genesyscloud/genesyscloud/integration/data_source_genesyscloud_integration.go (81.8%)</option>
				
				<option value="file29">terraform-provider-genesyscloud/genesyscloud/integration/genesyscloud_integration_proxy.go (72.7%)</option>
				
				<option value="file30">terraform-provider-genesyscloud/genesyscloud/integration/resource_genesyscloud_integration.go (70.4%)</option>
				
				<option value="file31">terraform-provider-genesyscloud/genesyscloud/integration/resource_genesyscloud_integration_schema.go (42.9%)</option>
				
				<option value="file32">terraform-provider-genesyscloud/genesyscloud/integration/resource_genesyscloud_integration_utils.go (85.7%)</option>
				
				<option value="file33">terraform-provider-genesyscloud/genesyscloud/integration_action/data_source_genesyscloud_integration_action.go (0.0%)</option>
				
				<option value="file34">terraform-provider-genesyscloud/genesyscloud/integration_action/genesyscloud_integration_action_proxy.go (0.0%)</option>
				
				<option value="file35">terraform-provider-genesyscloud/genesyscloud/integration_action/resource_genesyscloud_integration_action.go (0.0%)</option>
				
				<option value="file36">terraform-provider-genesyscloud/genesyscloud/integration_action/resource_genesyscloud_integration_action_schema.go (50.0%)</option>
				
				<option value="file37">terraform-provider-genesyscloud/genesyscloud/integration_action/resource_genesyscloud_integration_action_utils.go (0.0%)</option>
				
				<option value="file38">terraform-provider-genesyscloud/genesyscloud/integration_credential/data_source_genesyscloud_integration_credential.go (81.8%)</option>
				
				<option value="file39">terraform-provider-genesyscloud/genesyscloud/integration_credential/genesyscloud_integration_credential_proxy.go (69.2%)</option>
				
				<option value="file40">terraform-provider-genesyscloud/genesyscloud/integration_credential/resource_genesyscloud_integration_credential.go (69.5%)</option>
				
				<option value="file41">terraform-provider-genesyscloud/genesyscloud/integration_credential/resource_genesyscloud_integration_credential_schema.go (33.3%)</option>
				
				<option value="file42">terraform-provider-genesyscloud/genesyscloud/integration_credential/resource_genesyscloud_integration_credential_utils.go (88.9%)</option>
				
				<option value="file43">terraform-provider-genesyscloud/genesyscloud/integration_custom_auth_action/data_source_genesyscloud_integration_custom_auth_action.go (64.7%)</option>
				
				<option value="file44">terraform-provider-genesyscloud/genesyscloud/integration_custom_auth_action/genesyscloud_integration_custom_auth_action_proxy.go (54.5%)</option>
				
				<option value="file45">terraform-provider-genesyscloud/genesyscloud/integration_custom_auth_action/resource_genesyscloud_integration_custom_auth_action.go (64.6%)</option>
				
				<option value="file46">terraform-provider-genesyscloud/genesyscloud/integration_custom_auth_action/resource_genesyscloud_integration_custom_auth_action_schema.go (50.0%)</option>
				
				<option value="file47">terraform-provider-genesyscloud/genesyscloud/integration_custom_auth_action/resource_genesyscloud_integration_custom_auth_action_utils.go (71.4%)</option>
				
				<option value="file48">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_callabletimeset.go (87.5%)</option>
				
				<option value="file49">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_callanalysisresponseset.go (86.7%)</option>
				
				<option value="file50">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_cattemptlimit.go (0.0%)</option>
				
				<option value="file51">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_contactlistfilter.go (86.7%)</option>
				
				<option value="file52">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_dnclist.go (86.7%)</option>
				
				<option value="file53">terraform-provider-genesyscloud/genesyscloud/outbound/data_source_genesyscloud_outbound_messagingcampaign.go (6.2%)</option>
				
				<option value="file54">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_callabletimeset.go (80.3%)</option>
				
				<option value="file55">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_callanalysisresponseset.go (80.7%)</option>
				
				<option value="file56">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_contactlistfilter.go (85.3%)</option>
				
				<option value="file57">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_dnclist.go (73.1%)</option>
				
				<option value="file58">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_init.go (0.0%)</option>
				
				<option value="file59">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_messagingcampaign.go (27.7%)</option>
				
				<option value="file60">terraform-provider-genesyscloud/genesyscloud/outbound/resource_genesyscloud_outbound_settings.go (89.5%)</option>
				
				<option value="file61">terraform-provider-genesyscloud/genesyscloud/outbound_attempt_limit/data_source_genesyscloud_outbound_attemptlimit.go (87.5%)</option>
				
				<option value="file62">terraform-provider-genesyscloud/genesyscloud/outbound_attempt_limit/outbound_attempt_limit_resource_init.go (0.0%)</option>
				
				<option value="file63">terraform-provider-genesyscloud/genesyscloud/outbound_attempt_limit/resource_genesyscloud_outbound_attemptlimit.go (83.9%)</option>
				
				<option value="file64">terraform-provider-genesyscloud/genesyscloud/outbound_campaign/data_source_genesyscloud_outbound_campaign.go (81.8%)</option>
				
				<option value="file65">terraform-provider-genesyscloud/genesyscloud/outbound_campaign/genesyscloud_outbound_campaign_proxy.go (66.1%)</option>
				
				<option value="file66">terraform-provider-genesyscloud/genesyscloud/outbound_campaign/resource_genesyscloud_outbound_campaign.go (70.5%)</option>
				
				<option value="file67">terraform-provider-genesyscloud/genesyscloud/outbound_campaign/resource_genesyscloud_outbound_campaign_schema.go (50.0%)</option>
				
				<option value="file68">terraform-provider-genesyscloud/genesyscloud/outbound_campaign/resource_genesyscloud_outbound_campaign_utils.go (93.5%)</option>
				
				<option value="file69">terraform-provider-genesyscloud/genesyscloud/outbound_campaignrule/data_source_genesyscloud_outbound_campaignrule.go (85.7%)</option>
				
				<option value="file70">terraform-provider-genesyscloud/genesyscloud/outbound_campaignrule/resource_genesyscloud_outbound_campaignrule.go (84.5%)</option>
				
				<option value="file71">terraform-provider-genesyscloud/genesyscloud/outbound_campaignrule/resource_genesyscloud_outbound_campaignrule_schema.go (69.2%)</option>
				
				<option value="file72">terraform-provider-genesyscloud/genesyscloud/outbound_contact_list/data_source_genesyscloud_outbound_contactlist.go (86.7%)</option>
				
				<option value="file73">terraform-provider-genesyscloud/genesyscloud/outbound_contact_list/outbound_contact_list_resource_init.go (0.0%)</option>
				
				<option value="file74">terraform-provider-genesyscloud/genesyscloud/outbound_contact_list/resource_genesyscloud_outbound_contactlist.go (86.1%)</option>
				
				<option value="file75">terraform-provider-genesyscloud/genesyscloud/outbound_ruleset/data_source_genesyscloud_outbound_ruleset.go (81.8%)</option>
				
				<option value="file76">terraform-provider-genesyscloud/genesyscloud/outbound_ruleset/genesyscloud_outbound_ruleset_proxy.go (60.0%)</option>
				
				<option value="file77">terraform-provider-genesyscloud/genesyscloud/outbound_ruleset/resource_genesyscloud_outbound_ruleset.go (67.3%)</option>
				
				<option value="file78">terraform-provider-genesyscloud/genesyscloud/outbound_ruleset/resource_genesyscloud_outbound_ruleset_schema.go (63.6%)</option>
				
				<option value="file79">terraform-provider-genesyscloud/genesyscloud/outbound_ruleset/resource_genesyscloud_outbound_ruleset_utils.go (71.5%)</option>
				
				<option value="file80">terraform-provider-genesyscloud/genesyscloud/outbound_sequence/data_source_genesyscloud_outbound_sequence.go (81.8%)</option>
				
				<option value="file81">terraform-provider-genesyscloud/genesyscloud/outbound_sequence/genesyscloud_outbound_sequence_proxy.go (55.9%)</option>
				
				<option value="file82">terraform-provider-genesyscloud/genesyscloud/outbound_sequence/resource_genesyscloud_outbound_sequence.go (74.7%)</option>
				
				<option value="file83">terraform-provider-genesyscloud/genesyscloud/outbound_sequence/resource_genesyscloud_outbound_sequence_schema.go (50.0%)</option>
				
				<option value="file84">terraform-provider-genesyscloud/genesyscloud/outbound_sequence/resource_genesyscloud_outbound_sequence_utils.go (100.0%)</option>
				
				<option value="file85">terraform-provider-genesyscloud/genesyscloud/outbound_wrapupcode_mappings/genesyscloud_wrapupcode_mappings_proxy.go (92.3%)</option>
				
				<option value="file86">terraform-provider-genesyscloud/genesyscloud/outbound_wrapupcode_mappings/geneysyscloud_wrapupcode_mappings_schema.go (25.0%)</option>
				
				<option value="file87">terraform-provider-genesyscloud/genesyscloud/outbound_wrapupcode_mappings/resource_genesyscloud_outbound_wrapupcode_mappings_utils.go (96.8%)</option>
				
				<option value="file88">terraform-provider-genesyscloud/genesyscloud/outbound_wrapupcode_mappings/resource_genesyscloud_outbound_wrapupcodemappings.go (70.6%)</option>
				
				<option value="file89">terraform-provider-genesyscloud/genesyscloud/process_automation_trigger/data_source_genesyscloud_processautomation_trigger.go (82.4%)</option>
				
				<option value="file90">terraform-provider-genesyscloud/genesyscloud/process_automation_trigger/process_automation_trigger_resource_init.go (0.0%)</option>
				
				<option value="file91">terraform-provider-genesyscloud/genesyscloud/process_automation_trigger/process_automation_triggers_proxy.go (76.4%)</option>
				
				<option value="file92">terraform-provider-genesyscloud/genesyscloud/process_automation_trigger/process_automations_triggers_struct.go (83.3%)</option>
				
				<option value="file93">terraform-provider-genesyscloud/genesyscloud/process_automation_trigger/resource_genesyscloud_processautomation_trigger.go (83.2%)</option>
				
				<option value="file94">terraform-provider-genesyscloud/genesyscloud/recording_media_retention_policy/data_source_genesyscloud_recording_media_retention_policy.go (0.0%)</option>
				
				<option value="file95">terraform-provider-genesyscloud/genesyscloud/recording_media_retention_policy/genesyscloud_recording_media_retention_policy_proxy.go (0.0%)</option>
				
				<option value="file96">terraform-provider-genesyscloud/genesyscloud/recording_media_retention_policy/resource_genesyscloud_recording_media_retention_policy.go (0.0%)</option>
				
				<option value="file97">terraform-provider-genesyscloud/genesyscloud/recording_media_retention_policy/resource_genesyscloud_recording_media_retention_policy_schema.go (88.6%)</option>
				
				<option value="file98">terraform-provider-genesyscloud/genesyscloud/recording_media_retention_policy/resource_genesyscloud_recording_media_retention_policy_utils.go (0.0%)</option>
				
				<option value="file99">terraform-provider-genesyscloud/genesyscloud/resource_exporter/resource_exporter.go (1.8%)</option>
				
				<option value="file100">terraform-provider-genesyscloud/genesyscloud/resource_exporter/resource_exporter_custom.go (70.3%)</option>
				
				<option value="file101">terraform-provider-genesyscloud/genesyscloud/resource_exporter/resource_name_sanitizer.go (94.4%)</option>
				
				<option value="file102">terraform-provider-genesyscloud/genesyscloud/routing_sms_addresses/data_source_genesyscloud_routing_sms_addresses.go (0.0%)</option>
				
				<option value="file103">terraform-provider-genesyscloud/genesyscloud/routing_sms_addresses/genesyscloud_routing_sms_addresses_proxy.go (21.2%)</option>
				
				<option value="file104">terraform-provider-genesyscloud/genesyscloud/routing_sms_addresses/genesyscloud_routing_sms_addresses_schema.go (33.3%)</option>
				
				<option value="file105">terraform-provider-genesyscloud/genesyscloud/routing_sms_addresses/resource_genesyscloud_routing_sms_addresses.go (32.9%)</option>
				
				<option value="file106">terraform-provider-genesyscloud/genesyscloud/scripts/data_source_genesyscloud_script.go (78.6%)</option>
				
				<option value="file107">terraform-provider-genesyscloud/genesyscloud/scripts/genesyscloud_scripts_proxy.go (65.9%)</option>
				
				<option value="file108">terraform-provider-genesyscloud/genesyscloud/scripts/resource_genesyscloud_script.go (54.9%)</option>
				
				<option value="file109">terraform-provider-genesyscloud/genesyscloud/scripts/resource_scripts_schema.go (33.3%)</option>
				
				<option value="file110">terraform-provider-genesyscloud/genesyscloud/station/data_source_genesyscloud_station.go (81.8%)</option>
				
				<option value="file111">terraform-provider-genesyscloud/genesyscloud/station/genesyscloud_station_proxy.go (52.0%)</option>
				
				<option value="file112">terraform-provider-genesyscloud/genesyscloud/station/genesyscloud_station_schema.go (50.0%)</option>
				
				<option value="file113">terraform-provider-genesyscloud/genesyscloud/task_management_workbin/data_source_genesyscloud_task_management_workbin.go (0.0%)</option>
				
				<option value="file114">terraform-provider-genesyscloud/genesyscloud/task_management_workbin/genesyscloud_task_management_workbin_proxy.go (19.1%)</option>
				
				<option value="file115">terraform-provider-genesyscloud/genesyscloud/task_management_workbin/resource_genesyscloud_task_management_workbin.go (12.5%)</option>
				
				<option value="file116">terraform-provider-genesyscloud/genesyscloud/task_management_workbin/resource_genesyscloud_task_management_workbin_schema.go (33.3%)</option>
				
				<option value="file117">terraform-provider-genesyscloud/genesyscloud/team/data_source_genesyscloud_team.go (90.9%)</option>
				
				<option value="file118">terraform-provider-genesyscloud/genesyscloud/team/genesyscloud_team_proxy.go (75.4%)</option>
				
				<option value="file119">terraform-provider-genesyscloud/genesyscloud/team/resource_genesyscloud_team.go (84.5%)</option>
				
				<option value="file120">terraform-provider-genesyscloud/genesyscloud/team/resource_genesyscloud_team_schema.go (33.3%)</option>
				
				<option value="file121">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did/data_source_genesyscloud_telephony_providers_edges_did.go (90.9%)</option>
				
				<option value="file122">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did/genesyscloud_telephony_providers_edges_did_proxy.go (85.7%)</option>
				
				<option value="file123">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did/genesyscloud_telephony_providers_edges_did_schema.go (50.0%)</option>
				
				<option value="file124">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did_pool/data_source_genesyscloud_telephony_providers_edges_did_pool.go (83.3%)</option>
				
				<option value="file125">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did_pool/genesyscloud_telephony_providers_edges_did_pool_proxy.go (74.0%)</option>
				
				<option value="file126">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did_pool/resource_genesyscloud_telephony_providers_edges_did_pool.go (70.3%)</option>
				
				<option value="file127">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did_pool/resource_genesyscloud_telephony_providers_edges_did_pool_schema.go (33.3%)</option>
				
				<option value="file128">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_did_pool/resource_genesyscloud_telephony_providers_edges_did_pool_utils.go (85.7%)</option>
				
				<option value="file129">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_phone/data_source_genesyscloud_telephony_providers_edges_phone.go (81.8%)</option>
				
				<option value="file130">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_phone/genesyscloud_telephony_providers_edges_phone_proxy.go (51.1%)</option>
				
				<option value="file131">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_phone/resource_genesyscloud_telephony_providers_edges_phone.go (73.0%)</option>
				
				<option value="file132">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_phone/resource_genesyscloud_telephony_providers_edges_phone_schema.go (42.9%)</option>
				
				<option value="file133">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_phone/resource_genesyscloud_telephony_providers_edges_phone_utils.go (86.8%)</option>
				
				<option value="file134">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_site/data_source_genesyscloud_telephony_providers_edges_site.go (75.0%)</option>
				
				<option value="file135">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_site/genesyscloud_telephony_providers_edges_site_proxy.go (53.3%)</option>
				
				<option value="file136">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_site/resource_genesyscloud_telephony_providers_edges_site.go (69.3%)</option>
				
				<option value="file137">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_site/resource_genesyscloud_telephony_providers_edges_site_schema.go (50.0%)</option>
				
				<option value="file138">terraform-provider-genesyscloud/genesyscloud/telephony_providers_edges_site/resource_genesyscloud_telephony_providers_edges_site_utils.go (81.0%)</option>
				
				<option value="file139">terraform-provider-genesyscloud/genesyscloud/util/chunks/utils_batch_processing.go (77.8%)</option>
				
				<option value="file140">terraform-provider-genesyscloud/genesyscloud/util/files/util_files.go (33.6%)</option>
				
				<option value="file141">terraform-provider-genesyscloud/genesyscloud/util/lists/lists.go (100.0%)</option>
				
				<option value="file142">terraform-provider-genesyscloud/genesyscloud/util/lists/util_lists.go (15.6%)</option>
				
				<option value="file143">terraform-provider-genesyscloud/genesyscloud/util/typeconv/typeconv.go (44.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package architect_grammar

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_architect_grammar.go contains the data source implementation
   for the resource.
*/

// dataSourceArchitectGrammarRead retrieves by name the id in question
func dataSourceArchitectGrammarRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                grammarId, retryable, err := proxy.getArchitectGrammarIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error grammar %s: %s", name, err))
                }</span>

                <span class="cov0" title="0">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No grammar found with name %s", name))
                }</span>

                <span class="cov0" title="0">d.SetId(grammarId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package architect_grammar

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
)

/*
The genesyscloud_architect_grammar_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *architectGrammarProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createArchitectGrammarFunc func(ctx context.Context, p *architectGrammarProxy, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error)
type getAllArchitectGrammarFunc func(ctx context.Context, p *architectGrammarProxy) (*[]platformclientv2.Grammar, error)
type getArchitectGrammarByIdFunc func(ctx context.Context, p *architectGrammarProxy, grammarId string) (grammar *platformclientv2.Grammar, responseCode int, err error)
type getArchitectGrammarIdByNameFunc func(ctx context.Context, p *architectGrammarProxy, name string) (grammarId string, retryable bool, err error)
type updateArchitectGrammarFunc func(ctx context.Context, p *architectGrammarProxy, grammarId string, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error)
type deleteArchitectGrammarFunc func(ctx context.Context, p *architectGrammarProxy, grammarId string) (responseCode int, err error)

// architectGrammarProxy contains all of the methods that call genesys cloud APIs.
type architectGrammarProxy struct {
        clientConfig                    *platformclientv2.Configuration
        architectApi                    *platformclientv2.ArchitectApi
        createArchitectGrammarAttr      createArchitectGrammarFunc
        getAllArchitectGrammarAttr      getAllArchitectGrammarFunc
        getArchitectGrammarByIdAttr     getArchitectGrammarByIdFunc
        getArchitectGrammarIdByNameAttr getArchitectGrammarIdByNameFunc
        updateArchitectGrammarAttr      updateArchitectGrammarFunc
        deleteArchitectGrammarAttr      deleteArchitectGrammarFunc
}

// newArchitectGrammarProxy initializes the grammar proxy with all of the data needed to communicate with Genesys Cloud
func newArchitectGrammarProxy(clientConfig *platformclientv2.Configuration) *architectGrammarProxy <span class="cov8" title="1">{
        api := platformclientv2.NewArchitectApiWithConfig(clientConfig)
        return &amp;architectGrammarProxy{
                clientConfig:                    clientConfig,
                architectApi:                    api,
                createArchitectGrammarAttr:      createArchitectGrammarFn,
                getAllArchitectGrammarAttr:      getAllArchitectGrammarFn,
                getArchitectGrammarByIdAttr:     getArchitectGrammarByIdFn,
                getArchitectGrammarIdByNameAttr: getArchitectGrammarIdByNameFn,
                updateArchitectGrammarAttr:      updateArchitectGrammarFn,
                deleteArchitectGrammarAttr:      deleteArchitectGrammarFn,
        }
}</span>

// getArchitectGrammarProxy acts as a singleton for the internalProxy. It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getArchitectGrammarProxy(clientConfig *platformclientv2.Configuration) *architectGrammarProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newArchitectGrammarProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// createArchitectGrammar creates a Genesys Cloud Architect Grammar
func (p *architectGrammarProxy) createArchitectGrammar(ctx context.Context, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error) <span class="cov8" title="1">{
        return p.createArchitectGrammarAttr(ctx, p, grammar)
}</span>

// getAllArchitectGrammar retrieves all Genesys Cloud Architect Grammar
func (p *architectGrammarProxy) getAllArchitectGrammar(ctx context.Context) (*[]platformclientv2.Grammar, error) <span class="cov0" title="0">{
        return p.getAllArchitectGrammarAttr(ctx, p)
}</span>

// getArchitectGrammarById returns a single Genesys Cloud Architect Grammar by Id
func (p *architectGrammarProxy) getArchitectGrammarById(ctx context.Context, grammarId string) (grammar *platformclientv2.Grammar, statusCode int, err error) <span class="cov0" title="0">{
        return p.getArchitectGrammarByIdAttr(ctx, p, grammarId)
}</span>

// getArchitectGrammarIdByName returns a single Genesys Cloud Architect Grammar by a name
func (p *architectGrammarProxy) getArchitectGrammarIdByName(ctx context.Context, name string) (grammarId string, retryable bool, err error) <span class="cov0" title="0">{
        return p.getArchitectGrammarIdByNameAttr(ctx, p, name)
}</span>

// updateArchitectGrammar updates a Genesys Cloud Architect Grammar
func (p *architectGrammarProxy) updateArchitectGrammar(ctx context.Context, grammarId string, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error) <span class="cov0" title="0">{
        return p.updateArchitectGrammarAttr(ctx, p, grammarId, grammar)
}</span>

// deleteArchitectGrammar deletes a Genesys Cloud Architect Grammar by Id
func (p *architectGrammarProxy) deleteArchitectGrammar(ctx context.Context, grammarId string) (statusCode int, err error) <span class="cov0" title="0">{
        return p.deleteArchitectGrammarAttr(ctx, p, grammarId)
}</span>

// createArchitectGrammarFn is an implementation function for creating a Genesys Cloud Architect Grammar
func createArchitectGrammarFn(ctx context.Context, p *architectGrammarProxy, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error) <span class="cov8" title="1">{
        grammarSdk, _, err := p.architectApi.PostArchitectGrammars(*grammar)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Failed to create grammar: %s", err)
        }</span>

        <span class="cov0" title="0">return grammarSdk, nil</span>
}

// getAllArchitectGrammarFn is the implementation for retrieving all Architect Grammars in Genesys Cloud
func getAllArchitectGrammarFn(ctx context.Context, p *architectGrammarProxy) (*[]platformclientv2.Grammar, error) <span class="cov0" title="0">{
        var allGrammars []platformclientv2.Grammar

        grammars, _, err := p.architectApi.GetArchitectGrammars(1, 100, "", "", []string{}, "", "", "", true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get architect grammars: %v", err)
        }</span>
        <span class="cov0" title="0">if grammars.Entities == nil || len(*grammars.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allGrammars, nil
        }</span>
        <span class="cov0" title="0">for _, grammar := range *grammars.Entities </span><span class="cov0" title="0">{
                allGrammars = append(allGrammars, grammar)
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *grammars.PageCount; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100

                grammars, _, err := p.architectApi.GetArchitectGrammars(pageNum, pageSize, "", "", []string{}, "", "", "", true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get architect grammars: %v", err)
                }</span>

                <span class="cov0" title="0">if grammars.Entities == nil || len(*grammars.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, grammar := range *grammars.Entities </span><span class="cov0" title="0">{
                        allGrammars = append(allGrammars, grammar)
                }</span>
        }

        <span class="cov0" title="0">return &amp;allGrammars, nil</span>
}

// getArchitectGrammarByIdFn is an implementation of the function to get a Genesys Cloud Architect Grammar by Id
func getArchitectGrammarByIdFn(ctx context.Context, p *architectGrammarProxy, grammarId string) (grammar *platformclientv2.Grammar, statusCode int, err error) <span class="cov0" title="0">{
        grammar, resp, err := p.architectApi.GetArchitectGrammar(grammarId, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve grammar by id %s: %s", grammarId, err)
        }</span>
        <span class="cov0" title="0">return grammar, resp.StatusCode, nil</span>
}

// getArchitectGrammarIdByNameFn is an implementation of the function to get a Genesys Cloud Architect Grammar by name
func getArchitectGrammarIdByNameFn(ctx context.Context, p *architectGrammarProxy, name string) (grammarId string, retryable bool, err error) <span class="cov0" title="0">{
        grammars, err := getAllArchitectGrammarFn(ctx, p)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov0" title="0">if grammars == nil || len(*grammars) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("No architect grammars found with name %s", name)
        }</span>

        <span class="cov0" title="0">var grammar platformclientv2.Grammar
        for _, grammarSdk := range *grammars </span><span class="cov0" title="0">{
                if *grammarSdk.Name == name </span><span class="cov0" title="0">{
                        log.Printf("Retrieved the grammar id %s by name %s", *grammarSdk.Id, name)
                        grammar = grammarSdk
                        return *grammar.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", false, fmt.Errorf("Unable to find grammar with name %s", name)</span>
}

// updateArchitectGrammarFn is an implementation of the function to update a Genesys Cloud Architect Grammar
func updateArchitectGrammarFn(ctx context.Context, p *architectGrammarProxy, grammarId string, grammar *platformclientv2.Grammar) (*platformclientv2.Grammar, error) <span class="cov0" title="0">{
        grammarSdk, _, err := p.architectApi.PatchArchitectGrammar(grammarId, *grammar)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update grammar %s: %s", grammarId, err)
        }</span>

        <span class="cov0" title="0">return grammarSdk, nil</span>
}

// deleteArchitectGrammarFn is an implementation function for deleting a Genesys Cloud Architect Grammar
func deleteArchitectGrammarFn(ctx context.Context, p *architectGrammarProxy, grammarId string) (statusCode int, err error) <span class="cov0" title="0">{
        _, resp, err := p.architectApi.DeleteArchitectGrammar(grammarId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete grammar: %s", err)
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package architect_grammar

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"
)

/*
The resource_genesyscloud_architect_grammar.go contains all the methods that perform the core logic for a resource.
*/

// getAllAuthArchitectGrammar retrieves all of the architect grammars via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthArchitectGrammar(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := getArchitectGrammarProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        grammars, err := proxy.getAllArchitectGrammar(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get grammars: %v", err)
        }</span>

        <span class="cov0" title="0">for _, grammar := range *grammars </span><span class="cov0" title="0">{
                resources[*grammar.Id] = &amp;resourceExporter.ResourceMeta{Name: *grammar.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createArchitectGrammar is used by the architect_grammar_language resource to create a Genesys cloud architect grammar
func createArchitectGrammar(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarProxy(sdkConfig)

        architectGrammar := platformclientv2.Grammar{
                Name:        platformclientv2.String(d.Get("name").(string)),
                Description: platformclientv2.String(d.Get("description").(string)),
        }

        // Create grammar
        log.Printf("Creating Architect Grammar %s", *architectGrammar.Name)
        grammar, err := proxy.createArchitectGrammar(ctx, &amp;architectGrammar)
        if err != nil </span><span class="cov8" title="1">{
                return diag.Errorf("Failed to create grammar: %s", err)
        }</span>

        <span class="cov0" title="0">d.SetId(*grammar.Id)
        log.Printf("Created Architect Grammar %s", *grammar.Id)
        return readArchitectGrammar(ctx, d, meta)</span>
}

// readArchitectGrammar is used by the architect_grammar_language resource to read an architect grammar from genesys cloud.
func readArchitectGrammar(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarProxy(sdkConfig)

        log.Printf("Reading Architect Grammar %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                grammar, respCode, getErr := proxy.getArchitectGrammarById(ctx, d.Id())

                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Architect Grammar %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Architect Grammar %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceArchitectGrammar())

                resourcedata.SetNillableValue(d, "name", grammar.Name)
                resourcedata.SetNillableValue(d, "description", grammar.Description)

                log.Printf("Read Architect Grammar %s", d.Id())
                return cc.CheckState()</span>
        })
}

// updateArchitectGrammar is used by the architect_grammar_language resource to update an architect grammar in Genesys Cloud
func updateArchitectGrammar(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarProxy(sdkConfig)

        architectGrammar := platformclientv2.Grammar{
                Name:        platformclientv2.String(d.Get("name").(string)),
                Description: platformclientv2.String(d.Get("description").(string)),
        }

        // Update grammar
        log.Printf("Updating Architect Grammar %s", *architectGrammar.Name)
        grammar, err := proxy.updateArchitectGrammar(ctx, d.Id(), &amp;architectGrammar)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update grammar: %s", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated Architect Grammar %s", *grammar.Id)
        return readArchitectGrammar(ctx, d, meta)</span>
}

// deleteArchitectGrammar is used by the architect_grammar_language resource to delete an architect grammar from Genesys cloud.
func deleteArchitectGrammar(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarProxy(sdkConfig)

        _, err := proxy.deleteArchitectGrammar(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete grammar %s: %s", d.Id(), err)
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, respCode, err := proxy.getArchitectGrammarById(ctx, d.Id())

                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                log.Printf("Deleted Grammar %s", d.Id())
                                return nil
                        }</span>

                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting grammar %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Grammar %s still exists", d.Id()))</span>
        })
}

func GenerateGrammarResource(
        resourceId string,
        name string,
        description string,
) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
                resource "genesyscloud_architect_grammar" "%s" {
                        name = "%s"
                        description = "%s"
                }
        `, resourceId, name, description)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package architect_grammar

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_architect_grammar_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the architect_grammar resource.
3.  The datasource schema definitions for the architect_grammar datasource.
4.  The resource exporter configuration for the architect_grammar exporter.
*/
const resourceName = "genesyscloud_architect_grammar"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceArchitectGrammar())
        regInstance.RegisterDataSource(resourceName, DataSourceArchitectGrammar())
        regInstance.RegisterExporter(resourceName, ArchitectGrammarExporter())
}</span>

// ResourceArchitectGrammar registers the genesyscloud_architect_grammar resource with Terraform
func ResourceArchitectGrammar() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud architect grammar`,

                CreateContext: gcloud.CreateWithPooledClient(createArchitectGrammar),
                ReadContext:   gcloud.ReadWithPooledClient(readArchitectGrammar),
                UpdateContext: gcloud.UpdateWithPooledClient(updateArchitectGrammar),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteArchitectGrammar),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: "The name of grammar",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `description`: {
                                Description: "Description of the grammar",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
}</span>

// ArchitectGrammarExporter returns the resourceExporter object used to hold the genesyscloud_architect_grammar exporter's config
func ArchitectGrammarExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthArchitectGrammar),
        }
}</span>

// DataSourceArchitectGrammar registers the genesyscloud_architect_grammar data source
func DataSourceArchitectGrammar() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Data source for Genesys Cloud Architect Grammar. Select an Architect Grammar by name.`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceArchitectGrammarRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `Architect grammar name.`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package architect_grammar_language

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "net/http"
        "os"
)

type FileType int

const (
        Dtmf FileType = iota
        Voice
)

/*
The genesyscloud_architect_grammar_language_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *architectGrammarLanguageProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createArchitectGrammarLanguageFunc func(ctx context.Context, p *architectGrammarLanguageProxy, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error)
type getArchitectGrammarLanguageByIdFunc func(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string) (language *platformclientv2.Grammarlanguage, responseCode int, err error)
type updateArchitectGrammarLanguageFunc func(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error)
type deleteArchitectGrammarLanguageFunc func(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string) (responseCode int, err error)
type getAllArchitectGrammarLanguageFunc func(ctx context.Context, p *architectGrammarLanguageProxy) (*[]platformclientv2.Grammarlanguage, error)

// architectGrammarLanguageProxy contains all of the methods that call genesys cloud APIs.
type architectGrammarLanguageProxy struct {
        clientConfig                        *platformclientv2.Configuration
        architectApi                        *platformclientv2.ArchitectApi
        createArchitectGrammarLanguageAttr  createArchitectGrammarLanguageFunc
        getArchitectGrammarLanguageByIdAttr getArchitectGrammarLanguageByIdFunc
        updateArchitectGrammarLanguageAttr  updateArchitectGrammarLanguageFunc
        deleteArchitectGrammarLanguageAttr  deleteArchitectGrammarLanguageFunc
        getAllArchitectGrammarLanguageAttr  getAllArchitectGrammarLanguageFunc
}

// newArchitectGrammarLanguageProxy initializes the grammar Language proxy with all of the data needed to communicate with Genesys Cloud
func newArchitectGrammarLanguageProxy(clientConfig *platformclientv2.Configuration) *architectGrammarLanguageProxy <span class="cov0" title="0">{
        api := platformclientv2.NewArchitectApiWithConfig(clientConfig)
        return &amp;architectGrammarLanguageProxy{
                clientConfig:                        clientConfig,
                architectApi:                        api,
                createArchitectGrammarLanguageAttr:  createArchitectGrammarLanguageFn,
                getArchitectGrammarLanguageByIdAttr: getArchitectGrammarLanguageByIdFn,
                updateArchitectGrammarLanguageAttr:  updateArchitectGrammarLanguageFn,
                deleteArchitectGrammarLanguageAttr:  deleteArchitectGrammarLanguageFn,
                getAllArchitectGrammarLanguageAttr:  getAllArchitectGrammarLanguageFn,
        }
}</span>

// getArchitectGrammarLanguageProxy acts as a singleton for the internalProxy. It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getArchitectGrammarLanguageProxy(clientConfig *platformclientv2.Configuration) *architectGrammarLanguageProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newArchitectGrammarLanguageProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// createArchitectGrammarLanguage creates a Genesys Cloud Architect Grammar Language
func (p *architectGrammarLanguageProxy) createArchitectGrammarLanguage(ctx context.Context, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        return p.createArchitectGrammarLanguageAttr(ctx, p, language)
}</span>

// getArchitectGrammarLanguageById returns a single Genesys Cloud Architect Grammar Language by Id
func (p *architectGrammarLanguageProxy) getArchitectGrammarLanguageById(ctx context.Context, grammarId string, languageCode string) (language *platformclientv2.Grammarlanguage, statusCode int, err error) <span class="cov0" title="0">{
        return p.getArchitectGrammarLanguageByIdAttr(ctx, p, grammarId, languageCode)
}</span>

// updateArchitectGrammarLanguage updates a Genesys Cloud Architect Grammar Language
func (p *architectGrammarLanguageProxy) updateArchitectGrammarLanguage(ctx context.Context, grammarId string, languageCode string, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        return p.updateArchitectGrammarLanguageAttr(ctx, p, grammarId, languageCode, language)
}</span>

// deleteArchitectGrammarLanguage deletes a Genesys Cloud Architect Grammar Language by Id
func (p *architectGrammarLanguageProxy) deleteArchitectGrammarLanguage(ctx context.Context, grammarId string, languageCode string) (statusCode int, err error) <span class="cov0" title="0">{
        return p.deleteArchitectGrammarLanguageAttr(ctx, p, grammarId, languageCode)
}</span>

// getAllArchitectGrammarLanguage retrieves all Genesys Cloud Architect Grammar Languages
func (p *architectGrammarLanguageProxy) getAllArchitectGrammarLanguage(ctx context.Context) (*[]platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        return p.getAllArchitectGrammarLanguageAttr(ctx, p)
}</span>

// createArchitectGrammarLanguageFn is an implementation function for creating a Genesys Cloud Architect Grammar Language
func createArchitectGrammarLanguageFn(ctx context.Context, p *architectGrammarLanguageProxy, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        languageSdk, _, err := p.architectApi.PostArchitectGrammarLanguages(*language.GrammarId, *language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", err)
        }</span>

        // Upload grammar voice file
        <span class="cov0" title="0">if language.VoiceFileMetadata != nil &amp;&amp; language.VoiceFileMetadata.FileName != nil </span><span class="cov0" title="0">{
                uploadRequest := platformclientv2.Grammarfileuploadrequest{
                        FileType: language.VoiceFileMetadata.FileType,
                }
                err = uploadGrammarLanguageFile(p, *language.GrammarId, *language.Language, language.VoiceFileMetadata.FileName, &amp;uploadRequest, Voice)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to upload language voice file: %s", err)
                }</span>
        }

        // Upload grammar dtmf file
        <span class="cov0" title="0">if language.DtmfFileMetadata != nil &amp;&amp; language.DtmfFileMetadata.FileName != nil </span><span class="cov0" title="0">{
                uploadRequest := platformclientv2.Grammarfileuploadrequest{
                        FileType: language.DtmfFileMetadata.FileType,
                }
                err = uploadGrammarLanguageFile(p, *language.GrammarId, *language.Language, language.DtmfFileMetadata.FileName, &amp;uploadRequest, Dtmf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to upload language dtmf file: %s", err)
                }</span>
        }

        <span class="cov0" title="0">return languageSdk, nil</span>
}

// getArchitectGrammarLanguageByIdFn is an implementation of the function to get a Genesys Cloud Architect Grammar Language by Id
func getArchitectGrammarLanguageByIdFn(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string) (language *platformclientv2.Grammarlanguage, statusCode int, err error) <span class="cov0" title="0">{
        language, resp, err := p.architectApi.GetArchitectGrammarLanguage(grammarId, languageCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp.StatusCode, fmt.Errorf("%s", err)
        }</span>
        <span class="cov0" title="0">return language, resp.StatusCode, nil</span>
}

// updateArchitectGrammarLanguageFn is an implementation of the function to update a Genesys Cloud Architect Grammar Language
func updateArchitectGrammarLanguageFn(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string, language *platformclientv2.Grammarlanguage) (*platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        languageUpdate := platformclientv2.Grammarlanguageupdate{
                VoiceFileMetadata: language.VoiceFileMetadata,
                DtmfFileMetadata:  language.DtmfFileMetadata,
        }

        languageSdk, _, err := p.architectApi.PatchArchitectGrammarLanguage(grammarId, languageCode, languageUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", err)
        }</span>

        // Upload grammar voice file
        <span class="cov0" title="0">if language.VoiceFileMetadata != nil &amp;&amp; language.VoiceFileMetadata.FileName != nil </span><span class="cov0" title="0">{
                uploadRequest := platformclientv2.Grammarfileuploadrequest{
                        FileType: language.VoiceFileMetadata.FileType,
                }
                err = uploadGrammarLanguageFile(p, *language.GrammarId, *language.Language, language.VoiceFileMetadata.FileName, &amp;uploadRequest, Voice)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to upload language voice file: %s", err)
                }</span>
        }

        // Upload grammar dtmf file
        <span class="cov0" title="0">if language.DtmfFileMetadata != nil &amp;&amp; language.DtmfFileMetadata.FileName != nil </span><span class="cov0" title="0">{
                uploadRequest := platformclientv2.Grammarfileuploadrequest{
                        FileType: language.DtmfFileMetadata.FileType,
                }
                err = uploadGrammarLanguageFile(p, *language.GrammarId, *language.Language, language.DtmfFileMetadata.FileName, &amp;uploadRequest, Dtmf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to upload language dtmf file: %s", err)
                }</span>
        }

        <span class="cov0" title="0">return languageSdk, nil</span>
}

// deleteArchitectGrammarLanguageFn is an implementation function for deleting a Genesys Cloud Architect Grammar Language
func deleteArchitectGrammarLanguageFn(ctx context.Context, p *architectGrammarLanguageProxy, grammarId string, languageCode string) (statusCode int, err error) <span class="cov0" title="0">{
        resp, err := p.architectApi.DeleteArchitectGrammarLanguage(grammarId, languageCode)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("%s", err)
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

// uploadGrammarLanguageFile is a function for uploading a grammar language file to Genesys cloud
func uploadGrammarLanguageFile(p *architectGrammarLanguageProxy, grammarId string, languageCode string, filename *string, uploadBody *platformclientv2.Grammarfileuploadrequest, fileType FileType) error <span class="cov0" title="0">{
        var uploadResponse *platformclientv2.Uploadurlresponse
        var err error
        if fileType == Voice </span><span class="cov0" title="0">{
                uploadResponse, _, err = p.architectApi.PostArchitectGrammarLanguageFilesVoice(grammarId, languageCode, *uploadBody)
        }</span>
        <span class="cov0" title="0">if fileType == Dtmf </span><span class="cov0" title="0">{
                uploadResponse, _, err = p.architectApi.PostArchitectGrammarLanguageFilesDtmf(grammarId, languageCode, *uploadBody)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to get language file presignedUri: %s for file %s", err, *filename)
        }</span>

        <span class="cov0" title="0">maxRetries := 5
        var response *http.Response
        var file *os.File
        for retry := 0; retry &lt; maxRetries; retry++ </span><span class="cov0" title="0">{
                file, err = os.Open(*filename)
                if err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return fmt.Errorf("Failed to find file: %s", err)
                }</span>

                <span class="cov0" title="0">request, err := http.NewRequest(http.MethodPut, *uploadResponse.Url, file)
                if err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return err
                }</span>

                <span class="cov0" title="0">for key, value := range *uploadResponse.Headers </span><span class="cov0" title="0">{
                        request.Header.Add(key, value)
                }</span>

                <span class="cov0" title="0">client := &amp;http.Client{}
                response, err = client.Do(request)
                if err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        response.Body.Close()
                        return err
                }</span>

                <span class="cov0" title="0">if response.StatusCode == http.StatusNotImplemented </span><span class="cov0" title="0">{
                        file.Close()
                        response.Body.Close()
                        if retry == maxRetries-1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("Max retry attempts reached, status: %s", response.Status)
                        }</span>
                }
                <span class="cov0" title="0">if response.StatusCode &gt;= http.StatusBadRequest &amp;&amp; response.StatusCode != http.StatusNotImplemented </span><span class="cov0" title="0">{
                        file.Close()
                        response.Body.Close()
                        return fmt.Errorf("Invalid request, status: %s", response.Status)
                }</span>

                <span class="cov0" title="0">if response.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">file.Close()
        response.Body.Close()
        return nil</span>
}

// getAllArchitectGrammarLanguageFn is the implementation for retrieving all Architect Grammars in Genesys Cloud
func getAllArchitectGrammarLanguageFn(ctx context.Context, p *architectGrammarLanguageProxy) (*[]platformclientv2.Grammarlanguage, error) <span class="cov0" title="0">{
        var allLanguages []platformclientv2.Grammarlanguage

        grammars, _, err := p.architectApi.GetArchitectGrammars(1, 100, "", "", []string{}, "", "", "", true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get architect grammar languages: %v", err)
        }</span>
        <span class="cov0" title="0">if grammars.Entities == nil || len(*grammars.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allLanguages, nil
        }</span>

        <span class="cov0" title="0">for _, grammar := range *grammars.Entities </span><span class="cov0" title="0">{
                if grammar.Languages != nil </span><span class="cov0" title="0">{
                        for _, language := range *grammar.Languages </span><span class="cov0" title="0">{
                                allLanguages = append(allLanguages, language)
                        }</span>
                }
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *grammars.PageCount; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100

                grammars, _, err := p.architectApi.GetArchitectGrammars(pageNum, pageSize, "", "", []string{}, "", "", "", true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get architect grammar languages: %v", err)
                }</span>

                <span class="cov0" title="0">if grammars.Entities == nil || len(*grammars.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, grammar := range *grammars.Entities </span><span class="cov0" title="0">{
                        if grammar.Languages != nil </span><span class="cov0" title="0">{
                                for _, language := range *grammar.Languages </span><span class="cov0" title="0">{
                                        allLanguages = append(allLanguages, language)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;allLanguages, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package architect_grammar_language

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        "strings"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"
)

/*
The resource_genesyscloud_architect_grammar_language.go contains all the methods that perform the core logic for a resource.
*/

// getAllAuthArchitectGrammarLanguage retrieves all of the architect grammar languages via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthArchitectGrammarLanguage(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := getArchitectGrammarLanguageProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        languages, err := proxy.getAllArchitectGrammarLanguage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get grammar languages: %v", err)
        }</span>

        <span class="cov0" title="0">for _, language := range *languages </span><span class="cov0" title="0">{
                languageId := *language.GrammarId + ":" + *language.Language
                resources[languageId] = &amp;resourceExporter.ResourceMeta{Name: languageId}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createArchitectGrammarLanguage is used by the architect_grammar_language resource to create a Genesys cloud architect grammar language
func createArchitectGrammarLanguage(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarLanguageProxy(sdkConfig)

        architectGrammarLanguage := getArchitectGrammarLanguageFromResourceData(d)

        log.Printf("Creating Architect Grammar Language %s for grammar %s", *architectGrammarLanguage.Language, *architectGrammarLanguage.GrammarId)
        language, err := proxy.createArchitectGrammarLanguage(ctx, &amp;architectGrammarLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create grammar language: %s", err)
        }</span>

        // Language id is always in format &lt;grammar-id&gt;:&lt;language-code&gt;
        <span class="cov0" title="0">d.SetId(*language.GrammarId + ":" + *language.Language)
        log.Printf("Created Architect Grammar Language %s", *language.GrammarId+":"+*language.Language)
        return readArchitectGrammarLanguage(ctx, d, meta)</span>
}

// readArchitectGrammarLanguage is used by the architect_grammar_language resource to read an architect grammar language from genesys cloud.
func readArchitectGrammarLanguage(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarLanguageProxy(sdkConfig)

        log.Printf("Reading Architect Grammar Language %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                grammarId, languageCode := splitLanguageId(d.Id())
                language, respCode, getErr := proxy.getArchitectGrammarLanguageById(ctx, grammarId, languageCode)

                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Architect Grammar Language %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Architect Grammar Language %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceArchitectGrammarLanguage())

                resourcedata.SetNillableValue(d, "grammar_id", language.GrammarId)
                resourcedata.SetNillableValue(d, "language", language.Language)
                if language.VoiceFileMetadata != nil </span><span class="cov0" title="0">{
                        d.Set("voice_file_data", flattenGrammarLanguageFileMetadata(d, language.VoiceFileMetadata, Voice))
                }</span>
                <span class="cov0" title="0">if language.DtmfFileMetadata != nil </span><span class="cov0" title="0">{
                        d.Set("dtmf_file_data", flattenGrammarLanguageFileMetadata(d, language.DtmfFileMetadata, Dtmf))
                }</span>

                <span class="cov0" title="0">log.Printf("Read Architect Grammar Language %s", d.Id())
                return cc.CheckState()</span>
        })
}

func splitLanguageId(languageId string) (string, string) <span class="cov0" title="0">{
        split := strings.SplitN(languageId, ":", 2)
        if len(split) == 2 </span><span class="cov0" title="0">{
                return split[0], split[1]
        }</span>
        <span class="cov0" title="0">return "", ""</span>
}

// updateArchitectGrammarLanguage is used by the architect_grammar_language resource to update an architect grammar language in Genesys Cloud
func updateArchitectGrammarLanguage(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarLanguageProxy(sdkConfig)

        architectGrammarLanguage := getArchitectGrammarLanguageFromResourceData(d)

        log.Printf("Updating Architect Grammar Language %s", d.Id())
        _, err := proxy.updateArchitectGrammarLanguage(ctx, *architectGrammarLanguage.GrammarId, *architectGrammarLanguage.Language, &amp;architectGrammarLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update grammar language: %s", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated Architect Grammar Language %s", d.Id())
        return readArchitectGrammarLanguage(ctx, d, meta)</span>
}

// deleteArchitectGrammarLanguage is used by the architect_grammar_language resource to delete an architect grammar language from Genesys cloud.
func deleteArchitectGrammarLanguage(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newArchitectGrammarLanguageProxy(sdkConfig)

        grammarId, languageCode := splitLanguageId(d.Id())
        _, err := proxy.deleteArchitectGrammarLanguage(ctx, grammarId, languageCode)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete grammar language %s: %s", d.Id(), err)
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, respCode, err := proxy.getArchitectGrammarLanguageById(ctx, grammarId, d.Id())

                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                log.Printf("Deleted Grammar Language %s", d.Id())
                                return nil
                        }</span>

                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting grammar language %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Grammar Language %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package architect_grammar_language

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
        "terraform-provider-genesyscloud/genesyscloud/util/architectlanguages"
)

/*
resource_genesyscloud_architect_grammar_language_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the architect_grammar_language resource.
3.  The datasource schema definitions for the architect_grammar_language datasource.
4.  The resource exporter configuration for the architect_grammar_language exporter.
*/
const resourceName = "genesyscloud_architect_grammar_language"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceArchitectGrammarLanguage())
        regInstance.RegisterExporter(resourceName, ArchitectGrammarLanguageExporter())
}</span>

// ResourceArchitectGrammarLanguage registers the genesyscloud_architect_grammar_language resource with Terraform
func ResourceArchitectGrammarLanguage() *schema.Resource <span class="cov8" title="1">{
        fileMetadataResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `file_name`: {
                                Description: "The name of the file as defined by the user.",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `file_type`: {
                                Description:  "The extension of the file.",
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"Gram", "Grxml"}, false),
                        },
                        "file_content_hash": {
                                Description: "Hash value of the file content. Used to detect changes.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: `Genesys Cloud architect grammar language`,

                CreateContext: gcloud.CreateWithPooledClient(createArchitectGrammarLanguage),
                ReadContext:   gcloud.ReadWithPooledClient(readArchitectGrammarLanguage),
                UpdateContext: gcloud.UpdateWithPooledClient(updateArchitectGrammarLanguage),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteArchitectGrammarLanguage),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `grammar_id`: {
                                Description: "The id of the grammar this language belongs too. If this is changed a new language is created.",
                                Required:    true,
                                Type:        schema.TypeString,
                                ForceNew:    true,
                        },
                        `language`: {
                                Description:  "Language name. (eg. en-us). If this is changed a new language is created.",
                                Required:     true,
                                Type:         schema.TypeString,
                                ForceNew:     true,
                                ValidateFunc: validation.StringInSlice(architectlanguages.Languages, false),
                        },
                        `voice_file_data`: {
                                Description: "Information about the associated voice file.",
                                Optional:    true,
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Elem:        fileMetadataResource,
                        },
                        `dtmf_file_data`: {
                                Description: "Information about the associated dtmf file.",
                                Optional:    true,
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Elem:        fileMetadataResource,
                        },
                },
        }
}</span>

// ArchitectGrammarLanguageExporter returns the resourceExporter object used to hold the genesyscloud_architect_grammar_language exporter's config
func ArchitectGrammarLanguageExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthArchitectGrammarLanguage),
                CustomFileWriter: resourceExporter.CustomFileWriterSettings{
                        RetrieveAndWriteFilesFunc: ArchitectGrammarLanguageResolver,
                        SubDirectory:              "language_files",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package architect_grammar_language

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        "os"
        "path"
        "strings"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/util/files"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"
)

/*
The resource_genesyscloud_architect_grammar_language_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.
*/

// getArchitectGrammarLanguageFromResourceData maps data from schema ResourceData into a Genesys Cloud platformclientv2.Grammarlanguage
func getArchitectGrammarLanguageFromResourceData(d *schema.ResourceData) platformclientv2.Grammarlanguage <span class="cov0" title="0">{
        return platformclientv2.Grammarlanguage{
                GrammarId:         platformclientv2.String(d.Get("grammar_id").(string)),
                Language:          platformclientv2.String(d.Get("language").(string)),
                VoiceFileMetadata: buildGrammarLanguageFileMetadata(d.Get("voice_file_data").([]interface{})),
                DtmfFileMetadata:  buildGrammarLanguageFileMetadata(d.Get("dtmf_file_data").([]interface{})),
        }
}</span>

func buildGrammarLanguageFileMetadata(fileMetadata []interface{}) *platformclientv2.Grammarlanguagefilemetadata <span class="cov0" title="0">{
        if fileMetadata == nil || len(fileMetadata) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var sdkMetadata platformclientv2.Grammarlanguagefilemetadata
        metadataMap, ok := fileMetadata[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkMetadata.FileName, metadataMap, "file_name")
        resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkMetadata.FileType, metadataMap, "file_type")

        // Get the current date time, helpful in the UI
        currentTime := time.Now().UTC()
        formattedTime := currentTime.Format("2006-01-02T15:04:05.999Z")
        parsedTime, err := time.Parse("2006-01-02T15:04:05.999Z", formattedTime)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Unable to get current date time %s", err)
        }</span> else<span class="cov0" title="0"> {
                sdkMetadata.DateUploaded = &amp;parsedTime
        }</span>

        <span class="cov0" title="0">return &amp;sdkMetadata</span>
}

func flattenGrammarLanguageFileMetadata(d *schema.ResourceData, fileMetadata *platformclientv2.Grammarlanguagefilemetadata, fileType FileType) []interface{} <span class="cov0" title="0">{
        if fileMetadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metadataMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(metadataMap, "file_name", fileMetadata.FileName)
        resourcedata.SetMapValueIfNotNil(metadataMap, "file_type", fileMetadata.FileType)

        if fileType == Voice </span><span class="cov0" title="0">{
                if voiceData := d.Get("voice_file_data").([]interface{}); len(voiceData) &gt; 0 </span><span class="cov0" title="0">{
                        voiceDataMap := voiceData[0].(map[string]interface{})
                        if hash, ok := voiceDataMap["file_content_hash"].(string); ok </span><span class="cov0" title="0">{
                                metadataMap["file_content_hash"] = hash
                        }</span>
                }
        }
        <span class="cov0" title="0">if fileType == Dtmf </span><span class="cov0" title="0">{
                if dtmfData := d.Get("dtmf_file_data").([]interface{}); len(dtmfData) &gt; 0 </span><span class="cov0" title="0">{
                        dtmfDataMap := dtmfData[0].(map[string]interface{})
                        if hash, ok := dtmfDataMap["file_content_hash"].(string); ok </span><span class="cov0" title="0">{
                                metadataMap["file_content_hash"] = hash
                        }</span>
                }
        }

        <span class="cov0" title="0">return []interface{}{metadataMap}</span>
}

func ArchitectGrammarLanguageResolver(languageId, exportDirectory, subDirectory string, configMap map[string]interface{}, meta interface{}) error <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getArchitectGrammarLanguageProxy(sdkConfig)

        fullPath := path.Join(exportDirectory, subDirectory)
        if err := os.MkdirAll(fullPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        grammarId, languageCode := splitLanguageId(languageId)
        language, _, err := proxy.getArchitectGrammarLanguageById(ctx, grammarId, languageCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if language.VoiceFileMetadata != nil &amp;&amp; language.VoiceFileUrl != nil </span><span class="cov0" title="0">{
                if language.VoiceFileMetadata.FileType != nil </span><span class="cov0" title="0">{
                        downloadFiles(grammarId, fullPath, *language.Language, *language.VoiceFileUrl, *language.VoiceFileMetadata.FileType)
                }</span> else<span class="cov0" title="0"> {
                        downloadFiles(grammarId, fullPath, *language.Language, *language.VoiceFileUrl, "")
                }</span>
        }

        <span class="cov0" title="0">if language.DtmfFileMetadata != nil &amp;&amp; language.DtmfFileUrl != nil </span><span class="cov0" title="0">{
                if language.DtmfFileMetadata.FileType != nil </span><span class="cov0" title="0">{
                        downloadFiles(grammarId, fullPath, *language.Language, *language.DtmfFileUrl, *language.DtmfFileMetadata.FileType)
                }</span> else<span class="cov0" title="0"> {
                        downloadFiles(grammarId, fullPath, *language.Language, *language.DtmfFileUrl, "")
                }</span>
        }

        <span class="cov0" title="0">updateFilenamesInExportConfigMap(configMap, grammarId, *language, subDirectory)
        return nil</span>
}

func downloadFiles(grammarId string, fullPath string, languageCode string, fileUrl string, fileTypeSdk string) error <span class="cov0" title="0">{
        fileType := ""
        if fileTypeSdk != "" </span><span class="cov0" title="0">{
                fileType = strings.ToLower(fileTypeSdk)
        }</span>
        <span class="cov0" title="0">dtmfFileName := fmt.Sprintf("%s-dtmf-%s.%s", languageCode, grammarId, fileType)
        if err := files.DownloadExportFile(fullPath, dtmfFileName, fileUrl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func updateFilenamesInExportConfigMap(configMap map[string]interface{}, grammarId string, language platformclientv2.Grammarlanguage, subDir string) <span class="cov0" title="0">{
        if voiceFileData, ok := configMap["voice_file_data"].([]interface{}); ok </span><span class="cov0" title="0">{
                setExporterFileData(voiceFileData, grammarId, language, subDir, Voice)
        }</span>
        <span class="cov0" title="0">if dtmfFileData, ok := configMap["dtmf_file_data"].([]interface{}); ok </span><span class="cov0" title="0">{
                setExporterFileData(dtmfFileData, grammarId, language, subDir, Dtmf)
        }</span>
}

func setExporterFileData(fileDataMap []interface{}, grammarId string, language platformclientv2.Grammarlanguage, subDir string, fileType FileType) <span class="cov0" title="0">{
        //Set file name and content hash in the exporter map
        if fileData, ok := fileDataMap[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                fileExtension := ""
                if fileType == Voice &amp;&amp; language.VoiceFileMetadata.FileType != nil </span><span class="cov0" title="0">{
                        fileExtension = strings.ToLower(*language.VoiceFileMetadata.FileType)
                }</span>
                <span class="cov0" title="0">if fileType == Dtmf &amp;&amp; language.DtmfFileMetadata.FileType != nil </span><span class="cov0" title="0">{
                        fileExtension = strings.ToLower(*language.DtmfFileMetadata.FileType)
                }</span>

                <span class="cov0" title="0">fileName := fmt.Sprintf("%s-%v-%s.%s", *language.Language, fileType, grammarId, fileExtension)
                fileData["file_name"] = path.Join(subDir, fileName)
                fileData["file_content_hash"] = fmt.Sprintf(`${filesha256("%s")}`, path.Join(subDir, fileName))
                if fileData["file_type"] == nil </span><span class="cov0" title="0">{
                        fileData["file_type"] = ""
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package architect_ivr

import (
        "context"
        "fmt"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// dataSourceIvrRead retrieves the Genesys Cloud architect ivr id by name
func dataSourceIvrRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        ap := getArchitectIvrProxy(sdkConfig)
        name := d.Get("name").(string)
        // Query ivr by name. Retry in case search has not yet indexed the ivr.
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                id, retryable, err := ap.getArchitectIvrIdByName(ctx, name)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting IVR %s: %s", name, err))
                }</span>
                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(err)
                }</span>
                <span class="cov8" title="1">d.SetId(id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package architect_ivr

import (
        "context"
        "fmt"
        "log"
        utillists "terraform-provider-genesyscloud/genesyscloud/util/lists"
        "time"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_architect_ivr_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function to initialize the proxy object. This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to retrieve
    the proxy. This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *architectIvrProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createArchitectIvrFunc func(context.Context, *architectIvrProxy, platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error)
type getArchitectIvrFunc func(context.Context, *architectIvrProxy, string) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error)
type updateArchitectIvrFunc func(context.Context, *architectIvrProxy, string, platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error)
type deleteArchitectIvrFunc func(context.Context, *architectIvrProxy, string) (*platformclientv2.APIResponse, error)
type getAllArchitectIvrsFunc func(context.Context, *architectIvrProxy, string) (*[]platformclientv2.Ivr, error)
type getArchitectIvrIdByNameFunc func(context.Context, *architectIvrProxy, string) (id string, retryable bool, err error)

// architectIvrProxy contains all methods that call genesys cloud APIs.
type architectIvrProxy struct {
        clientConfig *platformclientv2.Configuration
        api          *platformclientv2.ArchitectApi

        createArchitectIvrAttr      createArchitectIvrFunc
        getArchitectIvrAttr         getArchitectIvrFunc
        updateArchitectIvrAttr      updateArchitectIvrFunc
        deleteArchitectIvrAttr      deleteArchitectIvrFunc
        getAllArchitectIvrsAttr     getAllArchitectIvrsFunc
        getArchitectIvrIdByNameAttr getArchitectIvrIdByNameFunc

        maxDnisPerRequest int

        // functions to perform basic put/post request without chunking logic
        updateArchitectIvrBasicAttr updateArchitectIvrFunc
        createArchitectIvrBasicAttr createArchitectIvrFunc
}

// newArchitectIvrProxy initializes the proxy with all the data needed to communicate with Genesys Cloud
func newArchitectIvrProxy(clientConfig *platformclientv2.Configuration) *architectIvrProxy <span class="cov8" title="1">{
        api := platformclientv2.NewArchitectApiWithConfig(clientConfig)
        return &amp;architectIvrProxy{
                clientConfig: clientConfig,
                api:          api,

                createArchitectIvrAttr:      createArchitectIvrFn,
                getArchitectIvrAttr:         getArchitectIvrFn,
                updateArchitectIvrAttr:      updateArchitectIvrFn,
                deleteArchitectIvrAttr:      deleteArchitectIvrFn,
                getAllArchitectIvrsAttr:     getAllArchitectIvrsFn,
                getArchitectIvrIdByNameAttr: getArchitectIvrIdByNameFn,

                maxDnisPerRequest: maxDnisPerRequest,

                createArchitectIvrBasicAttr: createArchitectIvrBasicFn,
                updateArchitectIvrBasicAttr: updateArchitectIvrBasicFn,
        }
}</span>

// getArchitectIvrProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getArchitectIvrProxy(clientConfig *platformclientv2.Configuration) *architectIvrProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newArchitectIvrProxy(clientConfig)
        }</span>
        <span class="cov8" title="1">return internalProxy</span>
}

// getAllArchitectIvrs retrieves all Genesys Cloud Architect IVRs
func (a *architectIvrProxy) getAllArchitectIvrs(ctx context.Context, name string) (*[]platformclientv2.Ivr, error) <span class="cov0" title="0">{
        return a.getAllArchitectIvrsAttr(ctx, a, name)
}</span>

// getArchitectIvrIdByName retrieves a Genesys Cloud Architect IVR ID by name
func (a *architectIvrProxy) getArchitectIvrIdByName(ctx context.Context, name string) (string, bool, error) <span class="cov8" title="1">{
        return a.getArchitectIvrIdByNameAttr(ctx, a, name)
}</span>

// createArchitectIvr creates a Genesys Cloud Architect IVR
func (a *architectIvrProxy) createArchitectIvr(ctx context.Context, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.createArchitectIvrAttr(ctx, a, ivr)
}</span>

// createArchitectIvr retrieves a Genesys Cloud Architect IVR by ID (implements chunking logic)
func (a *architectIvrProxy) getArchitectIvr(ctx context.Context, id string) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.getArchitectIvrAttr(ctx, a, id)
}</span>

// updateArchitectIvr updates a Genesys Cloud Architect IVR (implements chunking logic)
func (a *architectIvrProxy) updateArchitectIvr(ctx context.Context, id string, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.updateArchitectIvrAttr(ctx, a, id, ivr)
}</span>

// deleteArchitectIvr deletes a Genesys Cloud Architect IVR
func (a *architectIvrProxy) deleteArchitectIvr(ctx context.Context, id string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.deleteArchitectIvrAttr(ctx, a, id)
}</span>

// createArchitectIvrBasicFn creates a Genesys Cloud Architect IVR (without chunking logic)
func (a *architectIvrProxy) createArchitectIvrBasic(ctx context.Context, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.createArchitectIvrBasicAttr(ctx, a, ivr)
}</span>

// updateArchitectIvrBasic updates a Genesys Cloud Architect IVR (without chunking logic)
func (a *architectIvrProxy) updateArchitectIvrBasic(ctx context.Context, id string, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.updateArchitectIvrBasicAttr(ctx, a, id, ivr)
}</span>

// createArchitectIvrFn is an implementation function for creating a Genesys Cloud Architect IVR
func createArchitectIvrFn(ctx context.Context, a *architectIvrProxy, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.uploadArchitectIvrWithChunkingLogic(ctx, true, "", ivr)
}</span>

// getArchitectIvrFn is an implementation function for retrieving a Genesys Cloud Architect IVR by ID
func getArchitectIvrFn(_ context.Context, a *architectIvrProxy, id string) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.api.GetArchitectIvr(id)
}</span>

// updateArchitectIvrFn is an implementation function for updating a Genesys Cloud Architect IVR
func updateArchitectIvrFn(ctx context.Context, a *architectIvrProxy, id string, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.uploadArchitectIvrWithChunkingLogic(ctx, false, id, ivr)
}</span>

// createArchitectIvrBasicFn is an implementation function for performing a basic post of a Genesys Cloud Architect IVR
// without any chunking logic for the dnis field
func createArchitectIvrBasicFn(_ context.Context, a *architectIvrProxy, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.api.PostArchitectIvrs(ivr)
}</span>

// updateArchitectIvrBasicFn is an implementation function for performing a basic put of a Genesys Cloud Architect IVR
// without any chunking logic for the dnis field
func updateArchitectIvrBasicFn(_ context.Context, a *architectIvrProxy, id string, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.api.PutArchitectIvr(id, ivr)
}</span>

// deleteArchitectIvrFn is an implementation function for deleting a Genesys Cloud Architect IVR
func deleteArchitectIvrFn(_ context.Context, a *architectIvrProxy, id string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return a.api.DeleteArchitectIvr(id)
}</span>

// getAllArchitectIvrsFn is an implementation function for retrieving all Genesys Cloud Architect IVRs
func getAllArchitectIvrsFn(_ context.Context, a *architectIvrProxy, name string) (*[]platformclientv2.Ivr, error) <span class="cov8" title="1">{
        var (
                allIvrs   []platformclientv2.Ivr
                pageCount int
        )
        const pageSize = 100

        ivrs, _, err := a.api.GetArchitectIvrs(1, pageSize, "", "", name, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error requesting page of architect ivrs: %v", err)
        }</span>
        <span class="cov8" title="1">pageCount = *ivrs.PageCount

        if ivrs.Entities != nil &amp;&amp; len(*ivrs.Entities) &gt; 0 </span><span class="cov8" title="1">{
                allIvrs = append(allIvrs, *ivrs.Entities...)
        }</span>

        <span class="cov8" title="1">if pageCount &lt; 2 </span><span class="cov8" title="1">{
                return &amp;allIvrs, nil
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= pageCount; pageNum++ </span><span class="cov0" title="0">{
                ivrs, _, err := a.api.GetArchitectIvrs(pageNum, pageSize, "", "", name, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error requesting page of architect ivrs: %v", err)
                }</span>
                <span class="cov0" title="0">if ivrs.Entities == nil || len(*ivrs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">allIvrs = append(allIvrs, *ivrs.Entities...)</span>
        }
        <span class="cov0" title="0">return &amp;allIvrs, nil</span>
}

// getArchitectIvrIdByNameFn is an implementation function for retrieving a Genesys Cloud Architect IVR ID by name
func getArchitectIvrIdByNameFn(ctx context.Context, a *architectIvrProxy, name string) (string, bool, error) <span class="cov8" title="1">{
        ivrs, err := getAllArchitectIvrsFn(ctx, a, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("failed to read ivrs: %v", err)
        }</span>
        <span class="cov8" title="1">if ivrs == nil || len(*ivrs) == 0 </span><span class="cov8" title="1">{
                return "", true, fmt.Errorf("failed to find ivr with name '%s': %v", name, err)
        }</span>
        <span class="cov8" title="1">for _, ivr := range *ivrs </span><span class="cov8" title="1">{
                if *ivr.Name == name </span><span class="cov8" title="1">{
                        return *ivr.Id, false, nil
                }</span>
        }
        <span class="cov0" title="0">return "", true, fmt.Errorf("failed to find ivr with name '%s': %v", name, err)</span>
}

// uploadArchitectIvrWithChunkingLogic creates/updates an IVR. The function breaks the dnis field into chunks and uploads them in subsequent
// PUTs if the dnis array length is greater than a.maxDnisPerRequest
func (a *architectIvrProxy) uploadArchitectIvrWithChunkingLogic(ctx context.Context, post bool, id string, ivr platformclientv2.Ivr) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        var (
                respIvr    *platformclientv2.Ivr
                resp       *platformclientv2.APIResponse
                err        error
                dnisChunks [][]string
        )

        // If dnis array is not nil, break it into chunks of size a.maxDnisPerRequest
        if ivr.Dnis != nil </span><span class="cov8" title="1">{
                dnisChunks = utillists.ChunkStringSlice(*ivr.Dnis, a.maxDnisPerRequest)
                // If there is only one chunk - upload it with the request body as normal
                if len(dnisChunks) == 1 </span><span class="cov8" title="1">{
                        ivr.Dnis = &amp;dnisChunks[0]
                }</span> else<span class="cov8" title="1"> {
                        ivr.Dnis = nil
                }</span>
        }

        // Perform initial post/put
        <span class="cov8" title="1">if post </span><span class="cov8" title="1">{
                respIvr, resp, err = a.createArchitectIvrBasic(ctx, ivr)
        }</span> else<span class="cov8" title="1"> {
                respIvr, resp, err = a.updateArchitectIvrBasic(ctx, id, ivr)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                var operation string
                if post </span><span class="cov0" title="0">{
                        operation = "create"
                }</span> else<span class="cov0" title="0"> {
                        operation = "update"
                }</span>
                <span class="cov0" title="0">return respIvr, resp, fmt.Errorf("error performing %s inside function uploadArchitectIvrWithChunkingLogic: %v", operation, err)</span>
        }

        <span class="cov8" title="1">id = *respIvr.Id

        // If there is more than only chunk, call our function to perform each put request
        if len(dnisChunks) &gt; 1 </span><span class="cov8" title="1">{
                respIvr, resp, err = a.uploadIvrDnisChunks(ctx, dnisChunks, id)
                if err != nil </span><span class="cov0" title="0">{
                        return respIvr, resp, err
                }</span>
        }

        <span class="cov8" title="1">return respIvr, resp, err</span>
}

// uploadIvrDnisChunks loops through our chunks of dnis numbers and calls the uploadDnisChunk function for each.
func (a *architectIvrProxy) uploadIvrDnisChunks(ctx context.Context, dnisChunks [][]string, id string) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        ivr, resp, getErr := a.getArchitectIvr(ctx, id)
        if getErr != nil </span><span class="cov0" title="0">{
                return ivr, resp, fmt.Errorf("error occured reading ivr '%s' in function uploadIvrDnisChunks: %v", id, getErr)
        }</span>

        <span class="cov8" title="1">for i, chunk := range dnisChunks </span><span class="cov8" title="1">{
                time.Sleep(2 * time.Second)
                log.Printf("Uploading block %v of DID numbers to ivr config %s", i+1, id)
                // upload current chunk to IVR
                putIvr, resp, err := a.uploadDnisChunk(ctx, *ivr, chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return putIvr, resp, err
                }</span>
                // Update ivr variable to represent the latest state of dnis field
                <span class="cov8" title="1">ivr = putIvr</span>
        }

        <span class="cov8" title="1">return ivr, nil, nil</span>
}

// uploadDnisChunk Takes an IVR object and a chunk of dnis numbers as parameters, appends the dnis numbers from the chunk to the
// dnis numbers on the IVR object, and performs a basic PUT request
func (a *architectIvrProxy) uploadDnisChunk(ctx context.Context, ivr platformclientv2.Ivr, chunk []string) (*platformclientv2.Ivr, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        var dnis []string

        if ivr.Dnis != nil &amp;&amp; len(*ivr.Dnis) &gt; 0 </span><span class="cov8" title="1">{
                dnis = append(dnis, *ivr.Dnis...)
        }</span>

        <span class="cov8" title="1">dnis = append(dnis, chunk...)
        ivr.Dnis = &amp;dnis

        log.Printf("Updating IVR config %s", *ivr.Id)
        putIvr, resp, putErr := a.updateArchitectIvrBasic(ctx, *ivr.Id, ivr)
        if putErr != nil </span><span class="cov0" title="0">{
                return putIvr, resp, fmt.Errorf("error occured updating ivr %s in function uploadDnisChunk: %v", *ivr.Id, putErr)
        }</span>
        <span class="cov8" title="1">return putIvr, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package architect_ivr

import (
        "context"
        "fmt"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// getAllIvrConfigs retrieves all architect IVRs and is used for the exporter
func getAllIvrConfigs(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        ap := getArchitectIvrProxy(clientConfig)

        allIvrs, err := ap.getAllArchitectIvrs(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("failed to get architect ivrs: %v", err)
        }</span>

        <span class="cov0" title="0">for _, entity := range *allIvrs </span><span class="cov0" title="0">{
                resources[*entity.Id] = &amp;resourceExporter.ResourceMeta{Name: *entity.Name}
        }</span>
        <span class="cov0" title="0">return resources, nil</span>
}

// createIvrConfig is used by the resource to create a Genesys Cloud Architect IVR
func createIvrConfig(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ap := getArchitectIvrProxy(sdkConfig)

        ivrBody := buildArchitectIvrFromResourceData(d)

        // It might need to wait for a dependent did_pool to be created to avoid an eventual consistency issue which
        // would result in the error "Field 'didPoolId' is required and cannot be empty."
        if ivrBody.Dnis != nil </span><span class="cov8" title="1">{
                time.Sleep(3 * time.Second)
        }</span>
        <span class="cov8" title="1">log.Printf("Creating IVR config %s", *ivrBody.Name)
        ivrConfig, _, err := ap.createArchitectIvr(ctx, *ivrBody)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create IVR config %s: %s", *ivrBody.Name, err)
        }</span>
        <span class="cov8" title="1">d.SetId(*ivrConfig.Id)

        log.Printf("Created IVR config %s %s", *ivrBody.Name, *ivrConfig.Id)
        return readIvrConfig(ctx, d, meta)</span>
}

// readIvrConfig is used by the resource to read a Genesys Cloud Architect IVR
func readIvrConfig(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ap := getArchitectIvrProxy(sdkConfig)

        log.Printf("Reading IVR config %s", d.Id())
        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                ivrConfig, resp, getErr := ap.getArchitectIvr(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read IVR config %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read IVR config %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">if ivrConfig.State != nil &amp;&amp; *ivrConfig.State == "deleted" </span><span class="cov0" title="0">{
                        d.SetId("")
                        return nil
                }</span>

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceArchitectIvrConfig())
                _ = d.Set("name", *ivrConfig.Name)
                _ = d.Set("dnis", lists.StringListToSetOrNil(ivrConfig.Dnis))

                resourcedata.SetNillableValue(d, "description", ivrConfig.Description)
                resourcedata.SetNillableReference(d, "open_hours_flow_id", ivrConfig.OpenHoursFlow)
                resourcedata.SetNillableReference(d, "closed_hours_flow_id", ivrConfig.ClosedHoursFlow)
                resourcedata.SetNillableReference(d, "holiday_hours_flow_id", ivrConfig.HolidayHoursFlow)
                resourcedata.SetNillableReference(d, "schedule_group_id", ivrConfig.ScheduleGroup)
                resourcedata.SetNillableReferenceWritableDivision(d, "division_id", ivrConfig.Division)

                log.Printf("Read IVR config %s %s", d.Id(), *ivrConfig.Name)

                return cc.CheckState()</span>
        })
}

// updateIvrConfig is used by the resource to update a Genesys Cloud Architect IVR
func updateIvrConfig(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ap := getArchitectIvrProxy(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current version
                ivr, resp, getErr := ap.getArchitectIvr(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read IVR config %s: %s", d.Id(), getErr)
                }</span>

                <span class="cov8" title="1">ivrBody := buildArchitectIvrFromResourceData(d)
                ivrBody.Version = ivr.Version

                // It might need to wait for a dependent did_pool to be created to avoid an eventual consistency issue which
                // would result in the error "Field 'didPoolId' is required and cannot be empty."
                if ivrBody.Dnis != nil </span><span class="cov8" title="1">{
                        time.Sleep(3 * time.Second)
                }</span>
                <span class="cov8" title="1">log.Printf("Updating IVR config %s", *ivrBody.Name)
                _, resp, putErr := ap.updateArchitectIvr(ctx, d.Id(), *ivrBody)

                if putErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update IVR config %s: %s", d.Id(), putErr)
                }</span>

                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated IVR config %s", d.Id())
        return readIvrConfig(ctx, d, meta)</span>
}

// deleteIvrConfig is used by the resource to delete a Genesys Cloud Architect IVR
func deleteIvrConfig(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ap := getArchitectIvrProxy(sdkConfig)

        log.Printf("Deleting IVR config %s", name)
        if _, err := ap.deleteArchitectIvr(ctx, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete IVR config %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                ivr, resp, err := ap.getArchitectIvr(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // IVR config deleted
                                log.Printf("Deleted IVR config %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting IVR config %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">if ivr.State != nil &amp;&amp; *ivr.State == "deleted" </span><span class="cov8" title="1">{
                        // IVR config deleted
                        log.Printf("Deleted IVR config with a deleted state %s", d.Id())
                        return nil
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("IVR config %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package architect_ivr

import (
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

const (
        resourceName      = "genesyscloud_architect_ivr"
        maxDnisPerRequest = 50
)

// SetRegistrar registers all resources, data sources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceArchitectIvr())
        l.RegisterResource(resourceName, ResourceArchitectIvrConfig())
        l.RegisterExporter(resourceName, ArchitectIvrExporter())
}</span>

// ArchitectIvrExporter returns the resourceExporter object used to hold the genesyscloud_architect_ivr exporter's config
func ArchitectIvrExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllIvrConfigs),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "open_hours_flow_id":    {RefType: "genesyscloud_flow"},
                        "closed_hours_flow_id":  {RefType: "genesyscloud_flow"},
                        "holiday_hours_flow_id": {RefType: "genesyscloud_flow"},
                        "schedule_group_id":     {RefType: "genesyscloud_architect_schedulegroups"},
                        "division_id":           {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

// ResourceArchitectIvrConfig registers the genesyscloud_architect_ivr resource with Terraform
func ResourceArchitectIvrConfig() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Genesys Cloud IVR config",

                CreateContext: gcloud.CreateWithPooledClient(createIvrConfig),
                ReadContext:   gcloud.ReadWithPooledClient(readIvrConfig),
                UpdateContext: gcloud.UpdateWithPooledClient(updateIvrConfig),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteIvrConfig),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Name of the IVR config. Note: If the name changes, the existing Genesys Cloud IVR config will be dropped and recreated with a new ID. This can cause an Architect Flow to become invalid if the old flow is reference in the flow.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "description": {
                                Description: "IVR Config description.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "dnis": {
                                Description: fmt.Sprintf("The phone number(s) to contact the IVR by. Each phone number in the array must be in an E.164 number format. (Note: An array with a length greater than %v will be broken into chunks and uploaded in subsequent PUT requests.)", maxDnisPerRequest),
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Computed:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString, ValidateDiagFunc: gcloud.ValidatePhoneNumber},
                        },
                        "open_hours_flow_id": {
                                Description: "ID of inbound call flow for open hours.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "closed_hours_flow_id": {
                                Description: "ID of inbound call flow for closed hours.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "holiday_hours_flow_id": {
                                Description: "ID of inbound call flow for holidays.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "schedule_group_id": {
                                Description: "Schedule group ID.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "division_id": {
                                Description: "Division ID.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                },
        }
}</span>

// DataSourceArchitectIvr registers the genesyscloud_architect_ivr data source
func DataSourceArchitectIvr() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud IVRs. Select an IVR by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceIvrRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "IVR name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package architect_ivr

import (
        "fmt"
        "strconv"
        "strings"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

type IvrConfigStruct struct {
        ResourceID  string
        Name        string
        Description string
        Dnis        []string
        DependsOn   string
        DivisionId  string
}

// GenerateIvrConfigResource returns an ivr resource as a string based on the IvrConfigStruct struct
func GenerateIvrConfigResource(ivrConfig *IvrConfigStruct) string <span class="cov8" title="1">{
        var quotedDnsSlice []string
        for _, val := range ivrConfig.Dnis </span><span class="cov8" title="1">{
                quotedDnsSlice = append(quotedDnsSlice, strconv.Quote(val))
        }</span>

        <span class="cov8" title="1">divisionId := ""
        if ivrConfig.DivisionId != "" </span><span class="cov8" title="1">{
                divisionId = ivrConfig.DivisionId
        }</span> else<span class="cov8" title="1"> {
                divisionId = "null"
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`resource "%s" "%s" {
                name        = "%s"
                description = "%s"
                dnis        = [%s]
                depends_on  = [%s]
                division_id = %s
        }
        `, resourceName,
                ivrConfig.ResourceID,
                ivrConfig.Name,
                ivrConfig.Description,
                strings.Join(quotedDnsSlice, ","),
                ivrConfig.DependsOn,
                divisionId,
        )</span>
}

// GenerateIvrDataSource generate an ivr data source as a string
func GenerateIvrDataSource(
        resourceID string,
        name string,
        dependsOnResource string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`data "%s" "%s" {
                name = %s
                depends_on=[%s]
        }
        `, resourceName, resourceID, name, dependsOnResource)
}</span>

func buildArchitectIvrFromResourceData(d *schema.ResourceData) *platformclientv2.Ivr <span class="cov8" title="1">{
        ivrBody := platformclientv2.Ivr{
                Name:             platformclientv2.String(d.Get("name").(string)),
                OpenHoursFlow:    gcloud.BuildSdkDomainEntityRef(d, "open_hours_flow_id"),
                ClosedHoursFlow:  gcloud.BuildSdkDomainEntityRef(d, "closed_hours_flow_id"),
                HolidayHoursFlow: gcloud.BuildSdkDomainEntityRef(d, "holiday_hours_flow_id"),
                ScheduleGroup:    gcloud.BuildSdkDomainEntityRef(d, "schedule_group_id"),
                Dnis:             lists.BuildSdkStringList(d, "dnis"),
        }

        if description := d.Get("description").(string); description != "" </span><span class="cov8" title="1">{
                ivrBody.Description = &amp;description
        }</span>

        <span class="cov8" title="1">if divisionId := d.Get("division_id").(string); divisionId != "" </span><span class="cov8" title="1">{
                ivrBody.Division = &amp;platformclientv2.Writabledivision{Id: &amp;divisionId}
        }</span>

        <span class="cov8" title="1">return &amp;ivrBody</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package external_contacts

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_externalcontacts_contact.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

// dataSourceExternalContactsContactRead retrieves by search term the id in question
func dataSourceExternalContactsContactRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        ep := newExternalContactsContactsProxy(sdkConfig)

        search := d.Get("search").(string)
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{

                contactId, retryable, err := ep.getExternalContactIdBySearch(ctx, search)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error searching exteral contact %s: %s", search, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(fmt.Errorf("No external contact found with search %s", search))
                }</span>

                <span class="cov8" title="1">d.SetId(contactId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package external_contacts

import (
        "context"
        "fmt"
        "log"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_externalcontacts_contact_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *externalContactsContactsProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllExternalContactsFunc func(ctx context.Context, p *externalContactsContactsProxy) (*[]platformclientv2.Externalcontact, error)
type createExternalContactFunc func(ctx context.Context, p *externalContactsContactsProxy, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error)
type deleteExternalContactFunc func(ctx context.Context, p *externalContactsContactsProxy, externalContactId string) (responseCode int, err error)
type getExternalContactByIdFunc func(ctx context.Context, p *externalContactsContactsProxy, externalContactId string) (externalContact *platformclientv2.Externalcontact, responseCode int, err error)
type getExternalContactIdBySearchFunc func(ctx context.Context, p *externalContactsContactsProxy, search string) (externalContactId string, retryable bool, err error)
type updateExternalContactFunc func(ctx context.Context, p *externalContactsContactsProxy, externalContactId string, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error)

// externalContactsContactsProxy contains all of the methods that call genesys cloud APIs.
type externalContactsContactsProxy struct {
        clientConfig                     *platformclientv2.Configuration
        externalContactsApi              *platformclientv2.ExternalContactsApi
        getAllExternalContactsAttr       getAllExternalContactsFunc
        createExternalContactAttr        createExternalContactFunc
        deleteExternalContactByIdAttr    deleteExternalContactFunc
        getExternalContactByIdAttr       getExternalContactByIdFunc
        getExternalContactIdBySearchAttr getExternalContactIdBySearchFunc
        updateExternalContactAttr        updateExternalContactFunc
}

// newExternalContactsContactsProxy initializes the External Contacts proxy with all of the data needed to communicate with Genesys Cloud
func newExternalContactsContactsProxy(clientConfig *platformclientv2.Configuration) *externalContactsContactsProxy <span class="cov8" title="1">{
        api := platformclientv2.NewExternalContactsApiWithConfig(clientConfig)
        return &amp;externalContactsContactsProxy{
                clientConfig:                     clientConfig,
                externalContactsApi:              api,
                getAllExternalContactsAttr:       getAllExternalContactsFn,
                createExternalContactAttr:        createExternalContactFn,
                getExternalContactByIdAttr:       getExternalContactByIdFn,
                deleteExternalContactByIdAttr:    deleteExternalContactsFn,
                getExternalContactIdBySearchAttr: getExternalContactIdBySearchFn,
                updateExternalContactAttr:        updateExternalContactFn,
        }
}</span>

// getExternalContactsContactsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getExternalContactsContactsProxy(clientConfig *platformclientv2.Configuration) *externalContactsContactsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newExternalContactsContactsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllExternalContacts retrieves all Genesys Cloud External Contacts
func (p *externalContactsContactsProxy) getAllExternalContacts(ctx context.Context) (*[]platformclientv2.Externalcontact, error) <span class="cov0" title="0">{
        return p.getAllExternalContactsAttr(ctx, p)
}</span>

// createExternalContact creates a Genesys Cloud External Contact
func (p *externalContactsContactsProxy) createExternalContact(ctx context.Context, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error) <span class="cov8" title="1">{
        return p.createExternalContactAttr(ctx, p, externalContact)
}</span>

// DeleteExternalContact deletes a Genesys Cloud External Contact by Id
func (p *externalContactsContactsProxy) deleteExternalContactId(ctx context.Context, externalContactId string) (int, error) <span class="cov8" title="1">{
        return p.deleteExternalContactByIdAttr(ctx, p, externalContactId)
}</span>

// getExternalContactById returns a single Genesys Cloud External Contact by Id
func (p *externalContactsContactsProxy) getExternalContactById(ctx context.Context, externalContactId string) (*platformclientv2.Externalcontact, int, error) <span class="cov8" title="1">{
        return p.getExternalContactByIdAttr(ctx, p, externalContactId)
}</span>

// getExternalContactIdBySearch returns a single Genesys Cloud External Contact by a search term
func (p *externalContactsContactsProxy) getExternalContactIdBySearch(ctx context.Context, search string) (externalContactId string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getExternalContactIdBySearchAttr(ctx, p, search)
}</span>

// updateExternalContact updates a Genesys Cloud External Contact
func (p *externalContactsContactsProxy) updateExternalContact(ctx context.Context, externalContactId string, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error) <span class="cov8" title="1">{
        return p.updateExternalContactAttr(ctx, p, externalContactId, externalContact)
}</span>

// getAllExternalContactsFn is the implementation for retrieving all external contacts in Genesys Cloud
func getAllExternalContactsFn(ctx context.Context, p *externalContactsContactsProxy) (*[]platformclientv2.Externalcontact, error) <span class="cov0" title="0">{
        var allExternalContacts []platformclientv2.Externalcontact

        cursor := ""
        for </span><span class="cov0" title="0">{
                externalContacts, _, err := p.externalContactsApi.GetExternalcontactsScanContacts(100, cursor)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get external contacts: %v", err)
                }</span>

                <span class="cov0" title="0">if externalContacts.Entities == nil || len(*externalContacts.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, externalContact := range *externalContacts.Entities </span><span class="cov0" title="0">{
                        allExternalContacts = append(allExternalContacts, externalContact)
                }</span>

                <span class="cov0" title="0">if externalContacts.Cursors == nil || externalContacts.Cursors.After == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cursor = *externalContacts.Cursors.After</span>
        }

        <span class="cov0" title="0">return &amp;allExternalContacts, nil</span>
}

// createExternalContactFn is an implementation function for creating a Genesys Cloud External Contact
func createExternalContactFn(ctx context.Context, p *externalContactsContactsProxy, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error) <span class="cov8" title="1">{
        contact, _, err := p.externalContactsApi.PostExternalcontactsContacts(*externalContact)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create external contact: %s", err)
        }</span>

        <span class="cov8" title="1">return contact, nil</span>
}

// deleteExternalContactsFn is an implementation function for deleting a Genesys Cloud External Contact
func deleteExternalContactsFn(ctx context.Context, p *externalContactsContactsProxy, externalContactId string) (int, error) <span class="cov8" title="1">{
        _, resp, err := p.externalContactsApi.DeleteExternalcontactsContact(externalContactId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete external contact: %s", err)
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}

// getExternalContactByIdFn is an implementation of the function to get a Genesys Cloud External Contact by Id
func getExternalContactByIdFn(ctx context.Context, p *externalContactsContactsProxy, externalContactId string) (*platformclientv2.Externalcontact, int, error) <span class="cov8" title="1">{
        externalContact, resp, err := p.externalContactsApi.GetExternalcontactsContact(externalContactId, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve external contact by id %s: %s", externalContactId, err)
        }</span>

        <span class="cov8" title="1">return externalContact, 0, nil</span>
}

// getExternalContactIdBySearchFn is an implementation of the function to get a Genesys Cloud External contact by a search team
func getExternalContactIdBySearchFn(ctx context.Context, p *externalContactsContactsProxy, search string) (externalContactId string, retryable bool, err error) <span class="cov8" title="1">{
        const pageNum = 1
        const pageSize = 100
        contacts, _, err := p.externalContactsApi.GetExternalcontactsContacts(pageSize, pageNum, search, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("Error searching external contact %s: %s", search, err)
        }</span>

        <span class="cov8" title="1">if contacts.Entities == nil || len(*contacts.Entities) == 0 </span><span class="cov8" title="1">{
                return "", true, fmt.Errorf("No external contact found with search %s", search)
        }</span>

        <span class="cov8" title="1">if len(*contacts.Entities) &gt; 1 </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("Too many values returned in look for external contact.  Unable to choose 1 external contact.  Please refine search and continue.")
        }</span>

        <span class="cov8" title="1">log.Printf("Retrieved the external contact search id %s by name %s", *(*contacts.Entities)[0].Id, search)
        contact := (*contacts.Entities)[0]
        return *contact.Id, false, nil</span>
}

// updateExternalContactFn is an implementation of the function to update a Genesys Cloud external contact
func updateExternalContactFn(ctx context.Context, p *externalContactsContactsProxy, externalContactId string, externalContact *platformclientv2.Externalcontact) (*platformclientv2.Externalcontact, error) <span class="cov8" title="1">{
        externalContact, _, err := p.externalContactsApi.PutExternalcontactsContact(externalContactId, *externalContact)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update external contact: %s", err)
        }</span>
        <span class="cov8" title="1">return externalContact, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package external_contacts

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_externalcontacts_contact.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesycloud_externalcontacts_contacts)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

1.  All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

2.  In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a
utils function in the package.  This will keep the code manageable and easy to work through.
*/
// getAllAuthExternalContacts retrieves all of the external contacts via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthExternalContacts(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        ep := getExternalContactsContactsProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        externalContacts, err := ep.getAllExternalContacts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get external contacts: %v", err)
        }</span>

        <span class="cov0" title="0">for _, externalContact := range *externalContacts </span><span class="cov0" title="0">{
                log.Printf("Dealing with external contact id : %s", *externalContact.Id)
                resources[*externalContact.Id] = &amp;resourceExporter.ResourceMeta{Name: *externalContact.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createExternalContact is used by the externalcontacts_contacts resource to create Genesyscloud external_contacts
func createExternalContact(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ep := getExternalContactsContactsProxy(sdkConfig)

        externalContact := getExternalContactFromResourceData(d)

        contact, err := ep.createExternalContact(ctx, &amp;externalContact)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create external contact: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*contact.Id)
        log.Printf("Created external contact %s", *contact.Id)
        return readExternalContact(ctx, d, meta)</span>
}

// readExternalContacts is used by the externalcontacts_contact resource to read an external contact from genesys cloud.
func readExternalContact(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ep := getExternalContactsContactsProxy(sdkConfig)

        log.Printf("Reading contact %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                externalContact, respCode, getErr := ep.getExternalContactById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read external contact %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read external contact %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceExternalContact())

                resourcedata.SetNillableValue(d, "first_name", externalContact.FirstName)
                resourcedata.SetNillableValue(d, "middle_name", externalContact.MiddleName)
                resourcedata.SetNillableValue(d, "last_name", externalContact.LastName)
                resourcedata.SetNillableValue(d, "salutation", externalContact.Salutation)
                resourcedata.SetNillableValue(d, "title", externalContact.Title)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "work_phone", externalContact.WorkPhone, flattenPhoneNumber)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "cell_phone", externalContact.CellPhone, flattenPhoneNumber)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "home_phone", externalContact.HomePhone, flattenPhoneNumber)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "other_phone", externalContact.OtherPhone, flattenPhoneNumber)
                resourcedata.SetNillableValue(d, "work_email", externalContact.WorkEmail)
                resourcedata.SetNillableValue(d, "personal_email", externalContact.WorkEmail)
                resourcedata.SetNillableValue(d, "other_email", externalContact.OtherEmail)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "address", externalContact.Address, flattenSdkAddress)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "twitter_id", externalContact.TwitterId, flattenSdkTwitterId)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "line_id", externalContact.LineId, flattenSdkLineId)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "whatsapp_id", externalContact.WhatsAppId, flattenSdkWhatsAppId)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "facebook_id", externalContact.FacebookId, flattenSdkFacebookId)
                resourcedata.SetNillableValue(d, "survey_opt_out", externalContact.SurveyOptOut)
                resourcedata.SetNillableValue(d, "external_system_url", externalContact.ExternalSystemUrl)

                log.Printf("Read external contact %s", d.Id())
                return cc.CheckState()</span>
        })
}

// updateExternalContacts is used by the externalcontacts_contacts resource to update an external contact in Genesys Cloud
func updateExternalContact(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ep := getExternalContactsContactsProxy(sdkConfig)

        externalContact := getExternalContactFromResourceData(d)
        _, err := ep.updateExternalContact(ctx, d.Id(), &amp;externalContact)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update external contact: %s", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated external contact")

        return readExternalContact(ctx, d, meta)</span>
}

// deleteExternalContacts is used by the externalcontacts_contacts resource to delete an external contact from Genesys cloud.
func deleteExternalContact(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ep := getExternalContactsContactsProxy(sdkConfig)

        _, err := ep.deleteExternalContactId(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete external contact %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, respCode, err := ep.getExternalContactById(ctx, d.Id())

                if err == nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error deleting external contact %s: %s", d.Id(), err))
                }</span>
                <span class="cov8" title="1">if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                        // Success  : External contact deleted
                        log.Printf("Deleted external contact %s", d.Id())
                        return nil
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("External contact %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package external_contacts

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_externalcontacts_contacts_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the externalcontacts_contacts resource.
3.  The datasource schema definitions for the externalcontacts_contacts datasource.
4.  The resource exporter configuration for the externalcontacts_contacts exporter.
*/
const resourceName = "genesyscloud_externalcontacts_contact"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceExternalContactsContact())
        l.RegisterResource(resourceName, ResourceExternalContact())
        l.RegisterExporter(resourceName, ExternalContactExporter())
}</span>

// ResourceExternalContact registers the genesyscloud_externalcontacts_contact resource with Terraform
func ResourceExternalContact() *schema.Resource <span class="cov8" title="1">{
        phoneNumber := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "display": {
                                Description: "Display string of the phone number.",
                                Type:        schema.TypeString,
                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov8" title="1">{
                                        return hashFormattedPhoneNumber(old) == hashFormattedPhoneNumber(new)
                                }</span>,
                                Optional: true,
                                Computed: true,
                        },
                        "extension": {
                                Description: "Phone extension.",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "accepts_sms": {
                                Description: "If contact accept SMS.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "e164": {
                                Description:      "Phone number in e164 format.",
                                Type:             schema.TypeString,
                                Optional:         true,
                                Computed:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                        "country_code": {
                                Description: "Phone number country code.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                },
        }

        <span class="cov8" title="1">address := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "address1": {
                                Description: "Contact address 1.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "address2": {
                                Description: "Contact address 2.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "city": {
                                Description: "Contact address city.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "state": {
                                Description: "Contact address state.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "postal_code": {
                                Description: "Contact address postal code.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "country_code": {
                                Description:      "Contact address country code.",
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidateCountryCode,
                        },
                },
        }

        twitterId := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "id": {
                                Description: "Contact twitter id.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "name": {
                                Description: "Contact twitter name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "screen_name": {
                                Description: "Contact twitter screen name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "profile_url": {
                                Description: "Contact twitter account url.",
                                Type:        schema.TypeString,
                                Computed:    true,
                        },
                },
        }

        lineIds := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "user_id": {
                                Description: "Contact line id.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        lineId := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "ids": {
                                Description: "Contact line id.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        lineIds,
                        },
                        "display_name": {
                                Description: "Contact line display name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        whatsappId := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "phone_number": {
                                Description: "Contact whatsapp phone number.",
                                Type:        schema.TypeList,
                                Required:    true,
                                Elem:        phoneNumber,
                        },
                        "display_name": {
                                Description: "Contact whatsapp display name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }

        facebookIds := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "scoped_id": {
                                Description: "Contact facebook scoped id.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        facebookId := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "ids": {
                                Description: "Contact facebook scoped id.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        facebookIds,
                        },
                        "display_name": {
                                Description: "Contact whatsapp display name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud External Contact",

                CreateContext: gcloud.CreateWithPooledClient(createExternalContact),
                ReadContext:   gcloud.ReadWithPooledClient(readExternalContact),
                UpdateContext: gcloud.UpdateWithPooledClient(updateExternalContact),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteExternalContact),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "first_name": {
                                Description: "The first name of the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "middle_name": {
                                Description: "The middle name of the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "last_name": {
                                Description: "The last name of the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "salutation": {
                                Description: "The salutation of the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "title": {
                                Description: "The title of the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "work_phone": {
                                Description: "Contact work phone settings.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Computed:    true,
                                Elem:        phoneNumber,
                        },
                        "cell_phone": {
                                Description: "Contact call phone settings.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        phoneNumber,
                        },
                        "home_phone": {
                                Description: "Contact home phone settings.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        phoneNumber,
                        },
                        "other_phone": {
                                Description: "Contact other phone settings.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        phoneNumber,
                        },
                        "work_email": {
                                Description: "Contact work email.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "personal_email": {
                                Description: "Contact personal email.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "other_email": {
                                Description: "Contact other email.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "address": {
                                Description: "Contact address.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        address,
                        },
                        "twitter_id": {
                                Description: "Contact twitter account informations.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        twitterId,
                        },
                        "line_id": {
                                Description: "Contact line account informations.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        lineId,
                        },
                        "whatsapp_id": {
                                Description: "Contact whatsapp account informations.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Computed:    true,
                                Elem:        whatsappId,
                        },
                        "facebook_id": {
                                Description: "Contact facebook account informations.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        facebookId,
                        },
                        "survey_opt_out": {
                                Description: "Contact survey opt out preference.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "external_system_url": {
                                Description: "Contact external system url.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }</span>
}

// ExternalContactExporter returns the resourceExporter object used to hold the genesyscloud_externalcontacts_contact exporter's config
func ExternalContactExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthExternalContacts),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "external_organization": {}, //Need to add this when we external orgs implemented
                },
        }
}</span>

// DataSourceExternalContactsContact registers the genesyscloud_externalcontacts_contact data source
func DataSourceExternalContactsContact() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud external contacts. Select a contact by any string search.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceExternalContactsContactRead),
                Schema: map[string]*schema.Schema{
                        "search": {
                                Description: "The search string for the contact.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package external_contacts

import (
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "github.com/nyaruka/phonenumbers"
)

/*
The resource_genesyscloud_externalcontacts_contacts_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

// getExternalContactFromResourceData maps data from schema ResourceData object to a platformclientv2.Externalcontact
func getExternalContactFromResourceData(d *schema.ResourceData) platformclientv2.Externalcontact <span class="cov8" title="1">{
        firstName := d.Get("first_name").(string)
        middleName := d.Get("middle_name").(string)
        lastName := d.Get("last_name").(string)
        salutation := d.Get("salutation").(string)
        title := d.Get("title").(string)
        workEmail := d.Get("work_email").(string)
        personalEmail := d.Get("personal_email").(string)
        otherEmail := d.Get("other_email").(string)
        surveyOptOut := d.Get("survey_opt_out").(bool)
        externalSystemUrl := d.Get("external_system_url").(string)

        return platformclientv2.Externalcontact{
                FirstName:         &amp;firstName,
                MiddleName:        &amp;middleName,
                LastName:          &amp;lastName,
                Salutation:        &amp;salutation,
                Title:             &amp;title,
                WorkPhone:         buildSdkPhoneNumber(d, "work_phone"),
                CellPhone:         buildSdkPhoneNumber(d, "cell_phone"),
                HomePhone:         buildSdkPhoneNumber(d, "home_phone"),
                OtherPhone:        buildSdkPhoneNumber(d, "other_phone"),
                WorkEmail:         &amp;workEmail,
                PersonalEmail:     &amp;personalEmail,
                OtherEmail:        &amp;otherEmail,
                Address:           buildSdkAddress(d, "address"),
                TwitterId:         buildSdkTwitterId(d, "twitter_id"),
                LineId:            buildSdkLineId(d, "line_id"),
                WhatsAppId:        buildSdkWhatsAppId(d, "whatsapp_id"),
                FacebookId:        buildSdkFacebookId(d, "facebook_id"),
                SurveyOptOut:      &amp;surveyOptOut,
                ExternalSystemUrl: &amp;externalSystemUrl,
        }
}</span>

// buildPhonenumberFromData is a helper method to map phone data to the GenesysCloud platformclientv2.PhoneNumber
func buildPhonenumberFromData(phoneData []interface{}) *platformclientv2.Phonenumber <span class="cov8" title="1">{
        phoneMap := phoneData[0].(map[string]interface{})

        display := phoneMap["display"].(string)
        extension := phoneMap["extension"].(int)
        acceptSMS := phoneMap["accepts_sms"].(bool)
        e164 := phoneMap["e164"].(string)
        countryCode := phoneMap["country_code"].(string)

        return &amp;platformclientv2.Phonenumber{
                Display:     &amp;display,
                Extension:   &amp;extension,
                AcceptsSMS:  &amp;acceptSMS,
                E164:        &amp;e164,
                CountryCode: &amp;countryCode,
        }
}</span>

// buildSdkPhoneNumber is a helper method to build a Genesys Cloud SDK PhoneNumber
func buildSdkPhoneNumber(d *schema.ResourceData, key string) *platformclientv2.Phonenumber <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                phoneData := d.Get(key).([]interface{})

                if len(phoneData) &gt; 0 </span><span class="cov8" title="1">{
                        return buildPhonenumberFromData(phoneData)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenPhoneNumber converts a platformclientv2.Phonenumber into a map and then into array for consumption by Terraform
func flattenPhoneNumber(phonenumber *platformclientv2.Phonenumber) []interface{} <span class="cov8" title="1">{
        phonenumberInterface := make(map[string]interface{})
        if phonenumber.Display != nil </span><span class="cov8" title="1">{
                phonenumberInterface["display"] = *phonenumber.Display
        }</span>
        <span class="cov8" title="1">if phonenumber.Extension != nil </span><span class="cov8" title="1">{
                phonenumberInterface["extension"] = *phonenumber.Extension
        }</span>
        <span class="cov8" title="1">if phonenumber.AcceptsSMS != nil </span><span class="cov8" title="1">{
                phonenumberInterface["accepts_sms"] = *phonenumber.AcceptsSMS
        }</span>
        <span class="cov8" title="1">if phonenumber.E164 != nil </span><span class="cov8" title="1">{
                phonenumberInterface["e164"] = *phonenumber.E164
        }</span>
        <span class="cov8" title="1">if phonenumber.CountryCode != nil </span><span class="cov8" title="1">{
                phonenumberInterface["country_code"] = *phonenumber.CountryCode
        }</span>
        <span class="cov8" title="1">return []interface{}{phonenumberInterface}</span>
}

// buildSdkAddress constructs a platformclientv2.Contactaddress structure
func buildSdkAddress(d *schema.ResourceData, key string) *platformclientv2.Contactaddress <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                addressData := d.Get(key).([]interface{})
                if len(addressData) &gt; 0 </span><span class="cov8" title="1">{
                        addressMap := addressData[0].(map[string]interface{})
                        address1 := addressMap["address1"].(string)
                        address2 := addressMap["address2"].(string)
                        city := addressMap["city"].(string)
                        state := addressMap["state"].(string)
                        postalcode := addressMap["postal_code"].(string)
                        countrycode := addressMap["country_code"].(string)

                        return &amp;platformclientv2.Contactaddress{
                                Address1:    &amp;address1,
                                Address2:    &amp;address2,
                                City:        &amp;city,
                                State:       &amp;state,
                                PostalCode:  &amp;postalcode,
                                CountryCode: &amp;countrycode,
                        }
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenflattenSdkAddress converts a *platformclientv2.Contactaddress into a map and then into array for consumption by Terraform
func flattenSdkAddress(address *platformclientv2.Contactaddress) []interface{} <span class="cov8" title="1">{
        addressInterface := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(addressInterface, "address1", address.Address1)
        resourcedata.SetMapValueIfNotNil(addressInterface, "address2", address.Address2)
        resourcedata.SetMapValueIfNotNil(addressInterface, "city", address.City)
        resourcedata.SetMapValueIfNotNil(addressInterface, "state", address.State)
        resourcedata.SetMapValueIfNotNil(addressInterface, "postal_code", address.PostalCode)
        resourcedata.SetMapValueIfNotNil(addressInterface, "country_code", address.CountryCode)

        return []interface{}{addressInterface}
}</span>

// buildSdkTwitterid maps data from a Terraform data object into a Genesys Cloud *platformclientv2.Twitterid
func buildSdkTwitterId(d *schema.ResourceData, key string) *platformclientv2.Twitterid <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                twitterData := d.Get(key).([]interface{})
                if len(twitterData) &gt; 0 </span><span class="cov8" title="1">{
                        twitterMap := twitterData[0].(map[string]interface{})
                        id := twitterMap["id"].(string)
                        name := twitterMap["name"].(string)
                        screenname := twitterMap["screen_name"].(string)
                        profileurl := twitterMap["profile_url"].(string)

                        return &amp;platformclientv2.Twitterid{
                                Id:         &amp;id,
                                Name:       &amp;name,
                                ScreenName: &amp;screenname,
                                ProfileUrl: &amp;profileurl,
                        }
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenSdkTwitterId maps a Genesys Cloud platformclientv2.Twitterid into a []interface{}
func flattenSdkTwitterId(twitterId *platformclientv2.Twitterid) []interface{} <span class="cov8" title="1">{
        twitterInterface := make(map[string]interface{})
        resourcedata.SetMapValueIfNotNil(twitterInterface, "id", twitterId.Id)
        resourcedata.SetMapValueIfNotNil(twitterInterface, "name", twitterId.Name)
        if twitterId.ScreenName != nil </span><span class="cov8" title="1">{
                url := "https://www.twitter.com/" + *twitterId.ScreenName
                twitterInterface["screen_name"] = twitterId.ScreenName
                twitterInterface["profile_url"] = &amp;url
        }</span>

        <span class="cov8" title="1">resourcedata.SetMapValueIfNotNil(twitterInterface, "profile_url", twitterId.ProfileUrl)

        return []interface{}{twitterInterface}</span>
}

// buildSdkLineId builds platformclientv2.Lineid struct from a Terramform resource data struct
func buildSdkLineId(d *schema.ResourceData, key string) *platformclientv2.Lineid <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                lineData := d.Get(key).([]interface{})
                if len(lineData) &gt; 0 </span><span class="cov8" title="1">{
                        lineMap := lineData[0].(map[string]interface{})
                        displayname := lineMap["display_name"].(string)
                        userId := lineMap["ids"].([]interface{})[0].(map[string]interface{})["user_id"].(string)

                        ids := []platformclientv2.Lineuserid{
                                {
                                        UserId: &amp;userId,
                                },
                        }
                        lineId := platformclientv2.Lineid{
                                DisplayName: &amp;displayname,
                                Ids:         &amp;ids,
                        }
                        return &amp;lineId
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenSdkLineId maps platformclientv2.Lineid to a []interace{}
func flattenSdkLineId(lineId *platformclientv2.Lineid) []interface{} <span class="cov8" title="1">{
        lineInterface := make(map[string]interface{})
        flattenUserid := flattenSdkLineUserId(lineId.Ids)
        lineInterface["display_name"] = *lineId.DisplayName
        lineInterface["ids"] = &amp;flattenUserid
        return []interface{}{lineInterface}
}</span>

// flattenSdkLineUserId maps an []platformclientv2.Lineuserid to a []interface{}
func flattenSdkLineUserId(lineUserdid *[]platformclientv2.Lineuserid) []interface{} <span class="cov8" title="1">{
        lineUseridInterface := make(map[string]interface{})
        if (*lineUserdid)[0].UserId != nil </span><span class="cov8" title="1">{
                lineUseridInterface["user_id"] = (*lineUserdid)[0].UserId
        }</span>
        <span class="cov8" title="1">return []interface{}{lineUseridInterface}</span>
}

// buildSdkWhatsAppId maps a Terraform schema.ResourceData to a Genesys Cloud platformclientv2.Whatsappid
func buildSdkWhatsAppId(d *schema.ResourceData, key string) *platformclientv2.Whatsappid <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                whatsappData := d.Get(key).([]interface{})
                if len(whatsappData) &gt; 0 </span><span class="cov8" title="1">{
                        whatsappMap := whatsappData[0].(map[string]interface{})
                        displayName := whatsappMap["display_name"].(string)

                        return &amp;platformclientv2.Whatsappid{
                                DisplayName: &amp;displayName,
                                PhoneNumber: buildPhonenumberFromData(whatsappMap["phone_number"].([]interface{})),
                        }
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenSdkWhatsAppId maps a Genesys Cloud platformclientv2.Whatsappid to a []interface{}
func flattenSdkWhatsAppId(whatsappId *platformclientv2.Whatsappid) []interface{} <span class="cov8" title="1">{
        whatsappInterface := make(map[string]interface{})
        flattenPhonenumber := flattenPhoneNumber(whatsappId.PhoneNumber)
        whatsappInterface["display_name"] = *whatsappId.DisplayName
        whatsappInterface["phone_number"] = &amp;flattenPhonenumber
        return []interface{}{whatsappInterface}
}</span>

// buildSdkFacebookId maps a Terraform schema.ResourceData struct to a Genesys Cloud platformclientv2.Facebookid
func buildSdkFacebookId(d *schema.ResourceData, key string) *platformclientv2.Facebookid <span class="cov8" title="1">{
        if d.Get(key) != nil </span><span class="cov8" title="1">{
                facebookData := d.Get(key).([]interface{})
                if len(facebookData) &gt; 0 </span><span class="cov8" title="1">{
                        facebookMap := facebookData[0].(map[string]interface{})
                        displayname := facebookMap["display_name"].(string)
                        scopedId := facebookMap["ids"].([]interface{})[0].(map[string]interface{})["scoped_id"].(string)

                        facebookIds := []platformclientv2.Facebookscopedid{
                                {
                                        ScopedId: &amp;scopedId,
                                },
                        }
                        facebookId := platformclientv2.Facebookid{
                                DisplayName: &amp;displayname,
                                Ids:         &amp;facebookIds,
                        }
                        return &amp;facebookId
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// flattenSdkFacebookId maps a Genesys Cloud platformclientv2.Facebookid object to a []interface{}
func flattenSdkFacebookId(facebookid *platformclientv2.Facebookid) []interface{} <span class="cov8" title="1">{
        whatsappInterface := make(map[string]interface{})
        flattenScopedid := flattenSdkFacebookScopedId(facebookid.Ids)
        whatsappInterface["display_name"] = *facebookid.DisplayName
        whatsappInterface["ids"] = &amp;flattenScopedid
        return []interface{}{whatsappInterface}
}</span>

// flattenSdkFacebookScopedId maps a Genesys Cloud platformclientv2.Facebookscopedid struct ot a []interface{}
func flattenSdkFacebookScopedId(facebookScopedid *[]platformclientv2.Facebookscopedid) []interface{} <span class="cov8" title="1">{
        facebookScopedidInterface := make(map[string]interface{})
        if (*facebookScopedid)[0].ScopedId != nil </span><span class="cov8" title="1">{
                facebookScopedidInterface["scoped_id"] = (*facebookScopedid)[0].ScopedId
        }</span>
        <span class="cov8" title="1">return []interface{}{facebookScopedidInterface}</span>
}

// formatPhoneNumber formats a given string to E164 format and hashes it for comparison
func hashFormattedPhoneNumber(val string) int <span class="cov8" title="1">{
        formattedNumber := ""

        number, err := phonenumbers.Parse(val, "US")
        if err == nil </span><span class="cov8" title="1">{
                formattedNumber = phonenumbers.Format(number, phonenumbers.E164)
        }</span>

        <span class="cov8" title="1">return schema.HashString(formattedNumber)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package flow_milestone

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_flow_milestone.go contains the data source implementation
   for the resource.
*/

// dataSourceFlowMilestoneRead retrieves by name the id in question
func dataSourceFlowMilestoneRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newFlowMilestoneProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                flowMilestoneId, retryable, err := proxy.getFlowMilestoneIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error searching flow milestone %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(fmt.Errorf("No flow milestone found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(flowMilestoneId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package flow_milestone

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
)

/*
The genesyscloud_flow_milestone_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *flowMilestoneProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createFlowMilestoneFunc func(ctx context.Context, p *flowMilestoneProxy, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error)
type getAllFlowMilestoneFunc func(ctx context.Context, p *flowMilestoneProxy) (*[]platformclientv2.Flowmilestone, error)
type getFlowMilestoneIdByNameFunc func(ctx context.Context, p *flowMilestoneProxy, name string) (id string, retryable bool, err error)
type getFlowMilestoneByIdFunc func(ctx context.Context, p *flowMilestoneProxy, id string) (flowMilestone *platformclientv2.Flowmilestone, responseCode int, err error)
type updateFlowMilestoneFunc func(ctx context.Context, p *flowMilestoneProxy, id string, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error)
type deleteFlowMilestoneFunc func(ctx context.Context, p *flowMilestoneProxy, id string) (responseCode int, err error)

// flowMilestoneProxy contains all of the methods that call genesys cloud APIs.
type flowMilestoneProxy struct {
        clientConfig                 *platformclientv2.Configuration
        architectApi                 *platformclientv2.ArchitectApi
        createFlowMilestoneAttr      createFlowMilestoneFunc
        getAllFlowMilestoneAttr      getAllFlowMilestoneFunc
        getFlowMilestoneIdByNameAttr getFlowMilestoneIdByNameFunc
        getFlowMilestoneByIdAttr     getFlowMilestoneByIdFunc
        updateFlowMilestoneAttr      updateFlowMilestoneFunc
        deleteFlowMilestoneAttr      deleteFlowMilestoneFunc
}

// newFlowMilestoneProxy initializes the flow milestone proxy with all of the data needed to communicate with Genesys Cloud
func newFlowMilestoneProxy(clientConfig *platformclientv2.Configuration) *flowMilestoneProxy <span class="cov8" title="1">{
        api := platformclientv2.NewArchitectApiWithConfig(clientConfig)
        return &amp;flowMilestoneProxy{
                clientConfig:                 clientConfig,
                architectApi:                 api,
                createFlowMilestoneAttr:      createFlowMilestoneFn,
                getAllFlowMilestoneAttr:      getAllFlowMilestoneFn,
                getFlowMilestoneIdByNameAttr: getFlowMilestoneIdByNameFn,
                getFlowMilestoneByIdAttr:     getFlowMilestoneByIdFn,
                updateFlowMilestoneAttr:      updateFlowMilestoneFn,
                deleteFlowMilestoneAttr:      deleteFlowMilestoneFn,
        }
}</span>

// getFlowMilestoneProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getFlowMilestoneProxy(clientConfig *platformclientv2.Configuration) *flowMilestoneProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newFlowMilestoneProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// createFlowMilestone creates a Genesys Cloud flow milestone
func (p *flowMilestoneProxy) createFlowMilestone(ctx context.Context, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error) <span class="cov8" title="1">{
        return p.createFlowMilestoneAttr(ctx, p, flowMilestone)
}</span>

// getFlowMilestone retrieves all Genesys Cloud flow milestone
func (p *flowMilestoneProxy) getAllFlowMilestone(ctx context.Context) (*[]platformclientv2.Flowmilestone, error) <span class="cov0" title="0">{
        return p.getAllFlowMilestoneAttr(ctx, p)
}</span>

// getFlowMilestoneIdByName returns a single Genesys Cloud flow milestone by a name
func (p *flowMilestoneProxy) getFlowMilestoneIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getFlowMilestoneIdByNameAttr(ctx, p, name)
}</span>

// getFlowMilestoneById returns a single Genesys Cloud flow milestone by Id
func (p *flowMilestoneProxy) getFlowMilestoneById(ctx context.Context, id string) (flowMilestone *platformclientv2.Flowmilestone, statusCode int, err error) <span class="cov8" title="1">{
        return p.getFlowMilestoneByIdAttr(ctx, p, id)
}</span>

// updateFlowMilestone updates a Genesys Cloud flow milestone
func (p *flowMilestoneProxy) updateFlowMilestone(ctx context.Context, id string, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error) <span class="cov8" title="1">{
        return p.updateFlowMilestoneAttr(ctx, p, id, flowMilestone)
}</span>

// deleteFlowMilestone deletes a Genesys Cloud flow milestone by Id
func (p *flowMilestoneProxy) deleteFlowMilestone(ctx context.Context, id string) (statusCode int, err error) <span class="cov8" title="1">{
        return p.deleteFlowMilestoneAttr(ctx, p, id)
}</span>

// createFlowMilestoneFn is an implementation function for creating a Genesys Cloud flow milestone
func createFlowMilestoneFn(ctx context.Context, p *flowMilestoneProxy, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error) <span class="cov8" title="1">{
        flowMilestone, _, err := p.architectApi.PostFlowsMilestones(*flowMilestone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create flow milestone: %s", err)
        }</span>

        <span class="cov8" title="1">return flowMilestone, nil</span>
}

// getAllFlowMilestoneFn is the implementation for retrieving all flow milestone in Genesys Cloud
func getAllFlowMilestoneFn(ctx context.Context, p *flowMilestoneProxy) (*[]platformclientv2.Flowmilestone, error) <span class="cov0" title="0">{
        var allFlowMilestones []platformclientv2.Flowmilestone
        const pageSize = 100

        flowMilestones, _, err := p.architectApi.GetFlowsMilestones(1, pageSize, "", "", nil, "", "", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get flow milestone: %v", err)
        }</span>
        <span class="cov0" title="0">if flowMilestones.Entities == nil || len(*flowMilestones.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allFlowMilestones, nil
        }</span>
        <span class="cov0" title="0">for _, flowMilestone := range *flowMilestones.Entities </span><span class="cov0" title="0">{
                allFlowMilestones = append(allFlowMilestones, flowMilestone)
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *flowMilestones.PageCount; pageNum++ </span><span class="cov0" title="0">{
                flowMilestones, _, err := p.architectApi.GetFlowsMilestones(pageNum, pageSize, "", "", nil, "", "", "", nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get flow milestone: %v", err)
                }</span>

                <span class="cov0" title="0">if flowMilestones.Entities == nil || len(*flowMilestones.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, flowMilestone := range *flowMilestones.Entities </span><span class="cov0" title="0">{
                        allFlowMilestones = append(allFlowMilestones, flowMilestone)
                }</span>
        }

        <span class="cov0" title="0">return &amp;allFlowMilestones, nil</span>
}

// getFlowMilestoneIdByNameFn is an implementation of the function to get a Genesys Cloud flow milestone by name
func getFlowMilestoneIdByNameFn(ctx context.Context, p *flowMilestoneProxy, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        flowMilestones, _, err := p.architectApi.GetFlowsMilestones(1, 100, "", "", nil, name, "", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov8" title="1">if flowMilestones.Entities == nil || len(*flowMilestones.Entities) == 0 </span><span class="cov8" title="1">{
                return "", true, fmt.Errorf("No flow milestone found with name %s", name)
        }</span>

        <span class="cov8" title="1">for _, flowMilestoneSdk := range *flowMilestones.Entities </span><span class="cov8" title="1">{
                if *flowMilestoneSdk.Name == name </span><span class="cov8" title="1">{
                        log.Printf("Retrieved the flow milestone id %s by name %s", *flowMilestoneSdk.Id, name)
                        return *flowMilestoneSdk.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("Unable to find flow milestone with name %s", name)</span>
}

// getFlowMilestoneByIdFn is an implementation of the function to get a Genesys Cloud flow milestone by Id
func getFlowMilestoneByIdFn(ctx context.Context, p *flowMilestoneProxy, id string) (flowMilestone *platformclientv2.Flowmilestone, statusCode int, err error) <span class="cov8" title="1">{
        flowMilestone, resp, err := p.architectApi.GetFlowsMilestone(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve flow milestone by id %s: %s", id, err)
        }</span>

        <span class="cov8" title="1">return flowMilestone, resp.StatusCode, nil</span>
}

// updateFlowMilestoneFn is an implementation of the function to update a Genesys Cloud flow milestone
func updateFlowMilestoneFn(ctx context.Context, p *flowMilestoneProxy, id string, flowMilestone *platformclientv2.Flowmilestone) (*platformclientv2.Flowmilestone, error) <span class="cov8" title="1">{
        flowMilestone, _, err := p.architectApi.PutFlowsMilestone(id, *flowMilestone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update flow milestone: %s", err)
        }</span>
        <span class="cov8" title="1">return flowMilestone, nil</span>
}

// deleteFlowMilestoneFn is an implementation function for deleting a Genesys Cloud flow milestone
func deleteFlowMilestoneFn(ctx context.Context, p *flowMilestoneProxy, id string) (statusCode int, err error) <span class="cov8" title="1">{
        _, resp, err := p.architectApi.DeleteFlowsMilestone(id)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete flow milestone: %s", err)
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package flow_milestone

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "time"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

/*
The resource_genesyscloud_flow_milestone.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthFlowMilestone retrieves all of the flow milestone via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthFlowMilestones(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := newFlowMilestoneProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        flowMilestones, err := proxy.getAllFlowMilestone(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get flow milestone: %v", err)
        }</span>

        <span class="cov0" title="0">for _, flowMilestone := range *flowMilestones </span><span class="cov0" title="0">{
                resources[*flowMilestone.Id] = &amp;resourceExporter.ResourceMeta{Name: *flowMilestone.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createFlowMilestone is used by the flow_milestone resource to create Genesys cloud flow milestone
func createFlowMilestone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowMilestoneProxy(sdkConfig)

        flowMilestone := getFlowMilestoneFromResourceData(d)

        log.Printf("Creating flow milestone %s", *flowMilestone.Name)
        flowMilestoneSdk, err := proxy.createFlowMilestone(ctx, &amp;flowMilestone)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create flow milestone: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*flowMilestoneSdk.Id)
        log.Printf("Created flow milestone %s", *flowMilestoneSdk.Id)
        return readFlowMilestone(ctx, d, meta)</span>
}

// readFlowMilestone is used by the flow_milestone resource to read a flow milestone from genesys cloud
func readFlowMilestone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowMilestoneProxy(sdkConfig)

        log.Printf("Reading flow milestone %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                flowMilestone, respCode, getErr := proxy.getFlowMilestoneById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read flow milestone %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read flow milestone %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceFlowMilestone())

                resourcedata.SetNillableValue(d, "name", flowMilestone.Name)
                resourcedata.SetNillableReferenceWritableDivision(d, "division_id", flowMilestone.Division)
                resourcedata.SetNillableValue(d, "description", flowMilestone.Description)

                log.Printf("Read flow milestone %s %s", d.Id(), *flowMilestone.Name)
                return cc.CheckState()</span>
        })
}

// updateFlowMilestone is used by the flow_milestone resource to update an flow milestone in Genesys Cloud
func updateFlowMilestone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowMilestoneProxy(sdkConfig)

        flowMilestone := getFlowMilestoneFromResourceData(d)

        log.Printf("Updating flow milestone %s", *flowMilestone.Name)
        flowMilestoneSdk, err := proxy.updateFlowMilestone(ctx, d.Id(), &amp;flowMilestone)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update flow milestone: %s", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated flow milestone %s", *flowMilestoneSdk.Id)
        return readFlowMilestone(ctx, d, meta)</span>
}

// deleteFlowMilestone is used by the flow_milestone resource to delete a flow milestone from Genesys cloud
func deleteFlowMilestone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowMilestoneProxy(sdkConfig)

        _, err := proxy.deleteFlowMilestone(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete flow milestone %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, respCode, err := proxy.getFlowMilestoneById(ctx, d.Id())

                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                                log.Printf("Deleted flow milestone %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting flow milestone %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("flow milestone %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package flow_milestone

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_flow_milestone_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the flow_milestone resource.
3.  The datasource schema definitions for the flow_milestone datasource.
4.  The resource exporter configuration for the flow_milestone exporter.
*/
const resourceName = "genesyscloud_flow_milestone"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceFlowMilestone())
        regInstance.RegisterDataSource(resourceName, DataSourceFlowMilestone())
        regInstance.RegisterExporter(resourceName, FlowMilestoneExporter())
}</span>

// ResourceFlowMilestone registers the genesyscloud_flow_milestone resource with Terraform
func ResourceFlowMilestone() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud flow milestone`,

                CreateContext: gcloud.CreateWithPooledClient(createFlowMilestone),
                ReadContext:   gcloud.ReadWithPooledClient(readFlowMilestone),
                UpdateContext: gcloud.UpdateWithPooledClient(updateFlowMilestone),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteFlowMilestone),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The flow milestone name.",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        "division_id": {
                                Description: "The division to which this entity belongs.",
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        "description": {
                                Description: "The flow milestone description.",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
}</span>

// FlowMilestoneExporter returns the resourceExporter object used to hold the genesyscloud_flow_milestone exporter's config
func FlowMilestoneExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthFlowMilestones),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "division_id": {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

// DataSourceFlowMilestone registers the genesyscloud_flow_milestone data source
func DataSourceFlowMilestone() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud flow milestone data source. Select a flow milestone by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceFlowMilestoneRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `flow milestone name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package flow_milestone

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_flow_outcome_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.
*/

// getFlowMilestoneFromResourceData maps data from schema ResourceData object to a platformclientv2.Flowmilestone
func getFlowMilestoneFromResourceData(d *schema.ResourceData) platformclientv2.Flowmilestone <span class="cov8" title="1">{
        divisionId := d.Get("division_id").(string)
        description := d.Get("description").(string)

        milestone := platformclientv2.Flowmilestone{
                Name: platformclientv2.String(d.Get("name").(string)),
        }
        if divisionId != "" </span><span class="cov8" title="1">{
                milestone.Division = &amp;platformclientv2.Writabledivision{Id: &amp;divisionId}
        }</span>
        <span class="cov8" title="1">if description != "" </span><span class="cov8" title="1">{
                milestone.Description = &amp;description
        }</span>

        <span class="cov8" title="1">return milestone</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package flow_outcome

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_flow_outcome.go contains the data source implementation
   for the resource.
*/

// dataSourceFlowOutcomeRead retrieves by name the id in question
func dataSourceFlowOutcomeRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newFlowOutcomeProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                flowOutcomeId, retryable, err := proxy.getFlowOutcomeIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error searching flow outcome %s: %s", name, err))
                }</span>

                <span class="cov0" title="0">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No flow outcome found with name %s", name))
                }</span>

                <span class="cov0" title="0">d.SetId(flowOutcomeId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package flow_outcome

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
)

/*
The genesyscloud_flow_outcome_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *flowOutcomeProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createFlowOutcomeFunc func(ctx context.Context, p *flowOutcomeProxy, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error)
type getAllFlowOutcomeFunc func(ctx context.Context, p *flowOutcomeProxy) (*[]platformclientv2.Flowoutcome, error)
type getFlowOutcomeIdByNameFunc func(ctx context.Context, p *flowOutcomeProxy, name string) (id string, retryable bool, err error)
type getFlowOutcomeByIdFunc func(ctx context.Context, p *flowOutcomeProxy, id string) (flowOutcome *platformclientv2.Flowoutcome, responseCode int, err error)
type updateFlowOutcomeFunc func(ctx context.Context, p *flowOutcomeProxy, id string, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error)

// flowOutcomeProxy contains all of the methods that call genesys cloud APIs.
type flowOutcomeProxy struct {
        clientConfig               *platformclientv2.Configuration
        architectApi               *platformclientv2.ArchitectApi
        createFlowOutcomeAttr      createFlowOutcomeFunc
        getAllFlowOutcomeAttr      getAllFlowOutcomeFunc
        getFlowOutcomeIdByNameAttr getFlowOutcomeIdByNameFunc
        getFlowOutcomeByIdAttr     getFlowOutcomeByIdFunc
        updateFlowOutcomeAttr      updateFlowOutcomeFunc
}

// newFlowOutcomeProxy initializes the flow outcome proxy with all of the data needed to communicate with Genesys Cloud
func newFlowOutcomeProxy(clientConfig *platformclientv2.Configuration) *flowOutcomeProxy <span class="cov0" title="0">{
        api := platformclientv2.NewArchitectApiWithConfig(clientConfig)
        return &amp;flowOutcomeProxy{
                clientConfig:               clientConfig,
                architectApi:               api,
                createFlowOutcomeAttr:      createFlowOutcomeFn,
                getAllFlowOutcomeAttr:      getAllFlowOutcomeFn,
                getFlowOutcomeIdByNameAttr: getFlowOutcomeIdByNameFn,
                getFlowOutcomeByIdAttr:     getFlowOutcomeByIdFn,
                updateFlowOutcomeAttr:      updateFlowOutcomeFn,
        }
}</span>

// getFlowOutcomeProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getFlowOutcomeProxy(clientConfig *platformclientv2.Configuration) *flowOutcomeProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newFlowOutcomeProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// createFlowOutcome creates a Genesys Cloud flow outcome
func (p *flowOutcomeProxy) createFlowOutcome(ctx context.Context, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        return p.createFlowOutcomeAttr(ctx, p, flowOutcome)
}</span>

// getFlowOutcome retrieves all Genesys Cloud flow outcome
func (p *flowOutcomeProxy) getAllFlowOutcome(ctx context.Context) (*[]platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        return p.getAllFlowOutcomeAttr(ctx, p)
}</span>

// getFlowOutcomeIdByName returns a single Genesys Cloud flow outcome by a name
func (p *flowOutcomeProxy) getFlowOutcomeIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov0" title="0">{
        return p.getFlowOutcomeIdByNameAttr(ctx, p, name)
}</span>

// getFlowOutcomeById returns a single Genesys Cloud flow outcome by Id
func (p *flowOutcomeProxy) getFlowOutcomeById(ctx context.Context, id string) (flowOutcome *platformclientv2.Flowoutcome, statusCode int, err error) <span class="cov0" title="0">{
        return p.getFlowOutcomeByIdAttr(ctx, p, id)
}</span>

// updateFlowOutcome updates a Genesys Cloud flow outcome
func (p *flowOutcomeProxy) updateFlowOutcome(ctx context.Context, id string, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        return p.updateFlowOutcomeAttr(ctx, p, id, flowOutcome)
}</span>

// createFlowOutcomeFn is an implementation function for creating a Genesys Cloud flow outcome
func createFlowOutcomeFn(ctx context.Context, p *flowOutcomeProxy, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        flowOutcome, _, err := p.architectApi.PostFlowsOutcomes(*flowOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create flow outcome: %s", err)
        }</span>

        <span class="cov0" title="0">return flowOutcome, nil</span>
}

// getAllFlowOutcomeFn is the implementation for retrieving all flow outcome in Genesys Cloud
func getAllFlowOutcomeFn(ctx context.Context, p *flowOutcomeProxy) (*[]platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        var allFlowOutcomes []platformclientv2.Flowoutcome
        const pageSize = 100

        flowOutcomes, _, err := p.architectApi.GetFlowsOutcomes(1, pageSize, "", "", nil, "", "", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get flow outcome: %v", err)
        }</span>
        <span class="cov0" title="0">if flowOutcomes.Entities == nil || len(*flowOutcomes.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allFlowOutcomes, nil
        }</span>
        <span class="cov0" title="0">for _, flowOutcome := range *flowOutcomes.Entities </span><span class="cov0" title="0">{
                allFlowOutcomes = append(allFlowOutcomes, flowOutcome)
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *flowOutcomes.PageCount; pageNum++ </span><span class="cov0" title="0">{
                flowOutcomes, _, err := p.architectApi.GetFlowsOutcomes(pageNum, pageSize, "", "", nil, "", "", "", nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get flow outcome: %v", err)
                }</span>

                <span class="cov0" title="0">if flowOutcomes.Entities == nil || len(*flowOutcomes.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, flowOutcome := range *flowOutcomes.Entities </span><span class="cov0" title="0">{
                        allFlowOutcomes = append(allFlowOutcomes, flowOutcome)
                }</span>
        }

        <span class="cov0" title="0">return &amp;allFlowOutcomes, nil</span>
}

// getFlowOutcomeIdByNameFn is an implementation of the function to get a Genesys Cloud flow outcome by name
func getFlowOutcomeIdByNameFn(ctx context.Context, p *flowOutcomeProxy, name string) (id string, retryable bool, err error) <span class="cov0" title="0">{
        flowOutcomes, _, err := p.architectApi.GetFlowsOutcomes(1, 100, "", "", nil, name, "", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">if flowOutcomes.Entities == nil || len(*flowOutcomes.Entities) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("No flow outcome found with name %s", name)
        }</span>

        <span class="cov0" title="0">for _, flowOutcomeSdk := range *flowOutcomes.Entities </span><span class="cov0" title="0">{
                if *flowOutcomeSdk.Name == name </span><span class="cov0" title="0">{
                        log.Printf("Retrieved the flow outcome id %s by name %s", *flowOutcomeSdk.Id, name)
                        return *flowOutcomeSdk.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("Unable to find flow outcome with name %s", name)</span>
}

// getFlowOutcomeByIdFn is an implementation of the function to get a Genesys Cloud flow outcome by Id
func getFlowOutcomeByIdFn(ctx context.Context, p *flowOutcomeProxy, id string) (flowOutcome *platformclientv2.Flowoutcome, statusCode int, err error) <span class="cov0" title="0">{
        flowOutcome, resp, err := p.architectApi.GetFlowsOutcome(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve flow outcome by id %s: %s", id, err)
        }</span>

        <span class="cov0" title="0">return flowOutcome, resp.StatusCode, nil</span>
}

// updateFlowOutcomeFn is an implementation of the function to update a Genesys Cloud flow outcome
func updateFlowOutcomeFn(ctx context.Context, p *flowOutcomeProxy, id string, flowOutcome *platformclientv2.Flowoutcome) (*platformclientv2.Flowoutcome, error) <span class="cov0" title="0">{
        _, _, err := p.architectApi.PutFlowsOutcome(id, *flowOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update flow outcome: %s", err)
        }</span>
        <span class="cov0" title="0">return flowOutcome, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package flow_outcome

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

/*
The resource_genesyscloud_flow_outcome.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthFlowOutcome retrieves all of the flow outcome via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthFlowOutcomes(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := newFlowOutcomeProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        flowOutcomes, err := proxy.getAllFlowOutcome(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get flow outcome: %v", err)
        }</span>

        <span class="cov0" title="0">for _, flowOutcome := range *flowOutcomes </span><span class="cov0" title="0">{
                resources[*flowOutcome.Id] = &amp;resourceExporter.ResourceMeta{Name: *flowOutcome.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createFlowOutcome is used by the flow_outcome resource to create Genesys cloud flow outcome
func createFlowOutcome(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowOutcomeProxy(sdkConfig)

        flowOutcome := getFlowOutcomeFromResourceData(d)

        log.Printf("Creating flow outcome %s", *flowOutcome.Name)
        outcome, err := proxy.createFlowOutcome(ctx, &amp;flowOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create flow outcome: %s", err)
        }</span>

        <span class="cov0" title="0">d.SetId(*outcome.Id)
        log.Printf("Created flow outcome %s", *outcome.Id)
        return readFlowOutcome(ctx, d, meta)</span>
}

// readFlowOutcome is used by the flow_outcome resource to read an flow outcome from genesys cloud
func readFlowOutcome(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowOutcomeProxy(sdkConfig)

        log.Printf("Reading flow outcome %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                flowOutcome, respCode, getErr := proxy.getFlowOutcomeById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read flow outcome %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read flow outcome %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceFlowOutcome())

                resourcedata.SetNillableValue(d, "name", flowOutcome.Name)
                resourcedata.SetNillableReferenceWritableDivision(d, "division_id", flowOutcome.Division)
                resourcedata.SetNillableValue(d, "description", flowOutcome.Description)

                log.Printf("Read flow outcome %s %s", d.Id(), *flowOutcome.Name)
                return cc.CheckState()</span>
        })
}

// updateFlowOutcome is used by the flow_outcome resource to update an flow outcome in Genesys Cloud
func updateFlowOutcome(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getFlowOutcomeProxy(sdkConfig)

        flowOutcome := getFlowOutcomeFromResourceData(d)

        log.Printf("Updating flow outcome %s", *flowOutcome.Name)
        _, err := proxy.updateFlowOutcome(ctx, d.Id(), &amp;flowOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update flow outcome: %s", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated flow outcome %s", d.Id())
        return readFlowOutcome(ctx, d, meta)</span>
}

// deleteFlowOutcome is used by the flow_outcome resource to delete an flow outcome from Genesys cloud
func deleteFlowOutcome(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package flow_outcome

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_flow_outcome_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the flow_outcome resource.
3.  The datasource schema definitions for the flow_outcome datasource.
4.  The resource exporter configuration for the flow_outcome exporter.
*/
const resourceName = "genesyscloud_flow_outcome"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceFlowOutcome())
        regInstance.RegisterDataSource(resourceName, DataSourceFlowOutcome())
        regInstance.RegisterExporter(resourceName, FlowOutcomeExporter())
}</span>

// ResourceFlowOutcome registers the genesyscloud_flow_outcome resource with Terraform
func ResourceFlowOutcome() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud flow outcome`,

                CreateContext: gcloud.CreateWithPooledClient(createFlowOutcome),
                ReadContext:   gcloud.ReadWithPooledClient(readFlowOutcome),
                UpdateContext: gcloud.UpdateWithPooledClient(updateFlowOutcome),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteFlowOutcome),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The flow outcome name.",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        "division_id": {
                                Description: "The division to which this entity belongs.",
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        "description": {
                                Description: "This is a description for the flow outcome.",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
}</span>

// FlowOutcomeExporter returns the resourceExporter object used to hold the genesyscloud_flow_outcome exporter's config
func FlowOutcomeExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthFlowOutcomes),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "division_id": {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

// DataSourceFlowOutcome registers the genesyscloud_flow_outcome data source
func DataSourceFlowOutcome() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud flow outcome data source. Select a flow outcome by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceFlowOutcomeRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `flow outcome name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package flow_outcome

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_flow_outcome_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.
*/

// getFlowOutcomeFromResourceData maps data from schema ResourceData object to a platformclientv2.Flowoutcome
func getFlowOutcomeFromResourceData(d *schema.ResourceData) platformclientv2.Flowoutcome <span class="cov0" title="0">{
        divisionId := d.Get("division_id").(string)
        description := d.Get("description").(string)

        outcome := platformclientv2.Flowoutcome{
                Name: platformclientv2.String(d.Get("name").(string)),
        }

        if divisionId != "" </span><span class="cov0" title="0">{
                outcome.Division = &amp;platformclientv2.Writabledivision{Id: &amp;divisionId}
        }</span>
        <span class="cov0" title="0">if description != "" </span><span class="cov0" title="0">{
                outcome.Description = &amp;description
        }</span>

        <span class="cov0" title="0">return outcome</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package integration

import (
        "context"
        "fmt"
        "time"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_integration.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

// dataSourceIntegrationRead retrieves by name the integration id in question
func dataSourceIntegrationRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationsProxy(sdkConfig)

        integrationName := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                integration, retryable, err := ip.getIntegrationByName(ctx, integrationName)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("failed to get page of integrations: %s. %s", integrationName, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("failed to get integration %s", integrationName))
                }</span>

                <span class="cov8" title="1">d.SetId(*integration.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package integration

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_integration_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *integrationsProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllIntegrationsFunc func(ctx context.Context, p *integrationsProxy) (*[]platformclientv2.Integration, error)
type createIntegrationFunc func(ctx context.Context, p *integrationsProxy, integration *platformclientv2.Createintegrationrequest) (*platformclientv2.Integration, error)
type getIntegrationByIdFunc func(ctx context.Context, p *integrationsProxy, integrationId string) (integration *platformclientv2.Integration, response *platformclientv2.APIResponse, err error)
type getIntegrationByNameFunc func(ctx context.Context, p *integrationsProxy, integrationName string) (integration *platformclientv2.Integration, retryable bool, err error)
type updateIntegrationFunc func(ctx context.Context, p *integrationsProxy, integrationId string, integration *platformclientv2.Integration) (*platformclientv2.Integration, error)
type deleteIntegrationFunc func(ctx context.Context, p *integrationsProxy, integrationId string) (responseCode int, err error)
type getIntegrationConfigFunc func(ctx context.Context, p *integrationsProxy, integrationId string) (config *platformclientv2.Integrationconfiguration, response *platformclientv2.APIResponse, err error)
type updateIntegrationConfigFunc func(ctx context.Context, p *integrationsProxy, integrationId string, integrationConfig *platformclientv2.Integrationconfiguration) (integration *platformclientv2.Integrationconfiguration, response *platformclientv2.APIResponse, err error)

// integrationProxy contains all of the methods that call genesys cloud APIs.
type integrationsProxy struct {
        clientConfig                *platformclientv2.Configuration
        integrationsApi             *platformclientv2.IntegrationsApi
        getAllIntegrationsAttr      getAllIntegrationsFunc
        createIntegrationAttr       createIntegrationFunc
        getIntegrationByIdAttr      getIntegrationByIdFunc
        getIntegrationByNameAttr    getIntegrationByNameFunc
        updateIntegrationAttr       updateIntegrationFunc
        updateIntegrationConfigAttr updateIntegrationConfigFunc
        deleteIntegrationAttr       deleteIntegrationFunc
        getIntegrationConfigAttr    getIntegrationConfigFunc
}

// newIntegrationsProxy initializes the Integrations proxy with all of the data needed to communicate with Genesys Cloud
func newIntegrationsProxy(clientConfig *platformclientv2.Configuration) *integrationsProxy <span class="cov8" title="1">{
        api := platformclientv2.NewIntegrationsApiWithConfig(clientConfig)
        return &amp;integrationsProxy{
                clientConfig:                clientConfig,
                integrationsApi:             api,
                getAllIntegrationsAttr:      getAllIntegrationsFn,
                createIntegrationAttr:       createIntegrationFn,
                getIntegrationByIdAttr:      getIntegrationByIdFn,
                getIntegrationByNameAttr:    getIntegrationByNameFn,
                updateIntegrationAttr:       updateIntegrationFn,
                updateIntegrationConfigAttr: updateIntegrationConfigFn,
                deleteIntegrationAttr:       deleteIntegrationFn,
                getIntegrationConfigAttr:    getIntegrationConfigFn,
        }
}</span>

// getIntegrationsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getIntegrationsProxy(clientConfig *platformclientv2.Configuration) *integrationsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newIntegrationsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllIntegrations retrieves all Genesys Cloud Integrations
func (p *integrationsProxy) getAllIntegrations(ctx context.Context) (*[]platformclientv2.Integration, error) <span class="cov0" title="0">{
        return p.getAllIntegrationsAttr(ctx, p)
}</span>

// createIntegration creates a Genesys Cloud Integration
func (p *integrationsProxy) createIntegration(ctx context.Context, integrationReq *platformclientv2.Createintegrationrequest) (*platformclientv2.Integration, error) <span class="cov8" title="1">{
        return p.createIntegrationAttr(ctx, p, integrationReq)
}</span>

// getIntegrationById gets Genesys Cloud Integration by id
func (p *integrationsProxy) getIntegrationById(ctx context.Context, integrationId string) (*platformclientv2.Integration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getIntegrationByIdAttr(ctx, p, integrationId)
}</span>

// getIntegrationByName gets a Genesys Cloud Integration by name
func (p *integrationsProxy) getIntegrationByName(ctx context.Context, integrationName string) (*platformclientv2.Integration, bool, error) <span class="cov8" title="1">{
        return p.getIntegrationByNameAttr(ctx, p, integrationName)
}</span>

// updateIntegration updates a Genesys Cloud Integration
func (p *integrationsProxy) updateIntegration(ctx context.Context, integrationId string, integration *platformclientv2.Integration) (*platformclientv2.Integration, error) <span class="cov8" title="1">{
        return p.updateIntegrationAttr(ctx, p, integrationId, integration)
}</span>

// deleteIntegration deletes a Genesys Cloud Integration
func (p *integrationsProxy) deleteIntegration(ctx context.Context, integrationId string) (responseCode int, err error) <span class="cov8" title="1">{
        return p.deleteIntegrationAttr(ctx, p, integrationId)
}</span>

// getIntegrationConfig get the current config of a Genesys Cloud Integration
func (p *integrationsProxy) getIntegrationConfig(ctx context.Context, integrationId string) (*platformclientv2.Integrationconfiguration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getIntegrationConfigAttr(ctx, p, integrationId)
}</span>

// updateIntegrationConfig updates the config of a Genesys Cloud Integration
func (p *integrationsProxy) updateIntegrationConfig(ctx context.Context, integrationId string, integrationConfig *platformclientv2.Integrationconfiguration) (*platformclientv2.Integrationconfiguration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.updateIntegrationConfigAttr(ctx, p, integrationId, integrationConfig)
}</span>

// getAllIntegrationsFn is the implementation for retrieving all integrations in Genesys Cloud
func getAllIntegrationsFn(ctx context.Context, p *integrationsProxy) (*[]platformclientv2.Integration, error) <span class="cov0" title="0">{
        var allIntegrations []platformclientv2.Integration

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                integrations, _, err := p.integrationsApi.GetIntegrations(pageSize, pageNum, "", nil, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if integrations.Entities == nil || len(*integrations.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">allIntegrations = append(allIntegrations, *integrations.Entities...)</span>
        }

        <span class="cov0" title="0">return &amp;allIntegrations, nil</span>
}

// createIntegrationFn is the implementation for creating an integration in Genesys Cloud
func createIntegrationFn(ctx context.Context, p *integrationsProxy, integrationReq *platformclientv2.Createintegrationrequest) (*platformclientv2.Integration, error) <span class="cov8" title="1">{
        integration, _, err := p.integrationsApi.PostIntegrations(*integrationReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return integration, nil</span>
}

// getIntegrationByIdFn is the implementation for getting a Genesys Cloud Integration by id
func getIntegrationByIdFn(ctx context.Context, p *integrationsProxy, integrationId string) (*platformclientv2.Integration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        const pageSize = 100
        const pageNum = 1
        integration, resp, err := p.integrationsApi.GetIntegration(integrationId, pageSize, pageNum, "", nil, "", "")
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return integration, resp, nil</span>
}

// getIntegrationByNameFn is the implementation for getting a Genesys Cloud Integration by name
func getIntegrationByNameFn(ctx context.Context, p *integrationsProxy, integrationName string) (*platformclientv2.Integration, bool, error) <span class="cov8" title="1">{
        var foundIntegration *platformclientv2.Integration

        const pageSize = 100
        for pageNum := 1; ; pageNum++ </span><span class="cov8" title="1">{
                integrations, _, err := p.integrationsApi.GetIntegrations(pageSize, pageNum, "", nil, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>

                <span class="cov8" title="1">if integrations.Entities == nil || len(*integrations.Entities) == 0 </span><span class="cov0" title="0">{
                        return nil, true, fmt.Errorf("no integrations found with name: %s", integrationName)
                }</span>

                <span class="cov8" title="1">for _, integration := range *integrations.Entities </span><span class="cov8" title="1">{
                        if integration.Name != nil &amp;&amp; *integration.Name == integrationName </span><span class="cov8" title="1">{
                                foundIntegration = &amp;integration
                                break</span>
                        }
                }
                <span class="cov8" title="1">if foundIntegration != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return foundIntegration, false, nil</span>
}

// updateIntegrationFn is the implementation for updating a Genesys Cloud Integration
func updateIntegrationFn(ctx context.Context, p *integrationsProxy, integrationId string, integration *platformclientv2.Integration) (*platformclientv2.Integration, error) <span class="cov8" title="1">{
        const pageSize = 25
        const pageNum = 1
        integration, _, err := p.integrationsApi.PatchIntegration(integrationId, pageSize, pageNum, "", nil, "", "", *integration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return integration, nil</span>
}

// deleteIntegrationFn is the implementation for deleting a Genesys Cloud Integration
func deleteIntegrationFn(ctx context.Context, p *integrationsProxy, integrationId string) (responseCode int, err error) <span class="cov8" title="1">{
        _, resp, err := p.integrationsApi.DeleteIntegration(integrationId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>
        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}

// getIntegrationConfigFn is the implementation for getting the current config of a Genesys Cloud Integration
func getIntegrationConfigFn(ctx context.Context, p *integrationsProxy, integrationId string) (*platformclientv2.Integrationconfiguration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        config, resp, err := p.integrationsApi.GetIntegrationConfigCurrent(integrationId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return config, resp, nil</span>
}

// updateIntegrationConfigFn is the implementation for updating a Genesys Cloud Integration Config
func updateIntegrationConfigFn(ctx context.Context, p *integrationsProxy, integrationId string, integrationConfig *platformclientv2.Integrationconfiguration) (*platformclientv2.Integrationconfiguration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        config, resp, err := p.integrationsApi.PutIntegrationConfigCurrent(integrationId, *integrationConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return config, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package integration

import (
        "context"
        "fmt"
        "log"
        "time"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesycloud_integration)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

 1. All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

 2. In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a

utils function in the package.  This will keep the code manageable and easy to work through.
*/

// getAllIntegrations retrieves all of the integrations via Terraform in the Genesys Cloud and is used for the exporter
func getAllIntegrations(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        ip := getIntegrationsProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        integrations, err := ip.getAllIntegrations(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get all integrations: %v", err)
        }</span>

        <span class="cov0" title="0">for _, integration := range *integrations </span><span class="cov0" title="0">{
                log.Printf("Dealing with integration id : %s", *integration.Id)
                resources[*integration.Id] = &amp;resourceExporter.ResourceMeta{Name: *integration.Name}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createIntegration is used by the integrations resource to create Genesyscloud integration
func createIntegration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        intendedState := d.Get("intended_state").(string)
        integrationType := d.Get("integration_type").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationsProxy(sdkConfig)

        createIntegrationReq := &amp;platformclientv2.Createintegrationrequest{
                IntegrationType: &amp;platformclientv2.Integrationtype{
                        Id: &amp;integrationType,
                },
        }
        integration, err := ip.createIntegration(ctx, createIntegrationReq)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create integration: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*integration.Id)

        //Update integration config separately
        diagErr, name := updateIntegrationConfigFromResourceData(ctx, d, ip)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        // Set attributes that can only be modified in a patch
        <span class="cov8" title="1">if d.HasChange("intended_state") </span><span class="cov8" title="1">{
                log.Printf("Updating additional attributes for integration %s", name)
                _, patchErr := ip.updateIntegration(ctx, d.Id(), &amp;platformclientv2.Integration{
                        IntendedState: &amp;intendedState,
                })

                if patchErr != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to update integration %s: %v", name, patchErr)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Created integration %s %s", name, *integration.Id)
        return readIntegration(ctx, d, meta)</span>
}

// readIntegration is used by the integration resource to read an integration from genesys cloud.
func readIntegration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationsProxy(sdkConfig)

        log.Printf("Reading integration %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                currentIntegration, resp, getErr := ip.getIntegrationById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read integration %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read integration %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">d.Set("integration_type", *currentIntegration.IntegrationType.Id)
                resourcedata.SetNillableValue(d, "intended_state", currentIntegration.IntendedState)

                // Use returned ID to get current config, which contains complete configuration
                integrationConfig, _, err := ip.getIntegrationConfig(ctx, *currentIntegration.Id)

                if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("failed to read config of integration %s: %s", d.Id(), getErr))
                }</span>

                <span class="cov8" title="1">d.Set("config", flattenIntegrationConfig(integrationConfig))

                log.Printf("Read integration %s %s", d.Id(), *currentIntegration.Name)

                return nil</span>
        })
}

// updateIntegration is used by the integration resource to update an integration in Genesys Cloud
func updateIntegration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        intendedState := d.Get("intended_state").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationsProxy(sdkConfig)

        diagErr, name := updateIntegrationConfigFromResourceData(ctx, d, ip)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">if d.HasChange("intended_state") </span><span class="cov8" title="1">{
                log.Printf("Updating integration %s", name)
                _, patchErr := ip.updateIntegration(ctx, d.Id(), &amp;platformclientv2.Integration{
                        IntendedState: &amp;intendedState,
                })
                if patchErr != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to update integration %s: %s", name, patchErr)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Updated integration %s %s", name, d.Id())
        return readIntegration(ctx, d, meta)</span>
}

// deleteIntegration is used by the integration resource to delete an integration from Genesys cloud.
func deleteIntegration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationsProxy(sdkConfig)

        _, err := ip.deleteIntegration(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete the integration %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := ip.getIntegrationById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Integration deleted
                                log.Printf("Deleted Integration %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting integration %s: %s", d.Id(), err))</span>
                }
                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("integration %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package integration

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

/*
resource_genesyscloud_integration_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the integration resource.
3.  The datasource schema definitions for the integration datasource.
4.  The resource exporter configuration for the integration exporter.
*/
const resourceName = "genesyscloud_integration"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceIntegration())
        l.RegisterResource(resourceName, ResourceIntegration())
        l.RegisterExporter(resourceName, IntegrationExporter())
}</span>

// ResourceIntegration registers the genesyscloud_integration resource with Terraform
func ResourceIntegration() *schema.Resource <span class="cov8" title="1">{
        integrationConfigResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Integration name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                        "notes": {
                                Description: "Integration notes.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "properties": {
                                Description:      "Integration config properties (JSON string).",
                                Type:             schema.TypeString,
                                Optional:         true,
                                Computed:         true,
                                DiffSuppressFunc: gcloud.SuppressEquivalentJsonDiffs,
                        },
                        "advanced": {
                                Description:      "Integration advanced config (JSON string).",
                                Type:             schema.TypeString,
                                Optional:         true,
                                Computed:         true,
                                DiffSuppressFunc: gcloud.SuppressEquivalentJsonDiffs,
                        },
                        "credentials": {
                                Description: "Credentials required for the integration. The required keys are indicated in the credentials property of the Integration Type.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud Integration",

                CreateContext: gcloud.CreateWithPooledClient(createIntegration),
                ReadContext:   gcloud.ReadWithPooledClient(readIntegration),
                UpdateContext: gcloud.UpdateWithPooledClient(updateIntegration),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteIntegration),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "intended_state": {
                                Description:  "Integration state (ENABLED | DISABLED | DELETED).",
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DISABLED",
                                ValidateFunc: validation.StringInSlice([]string{"ENABLED", "DISABLED", "DELETED"}, false),
                        },
                        "integration_type": {
                                Description: "Integration type.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "config": {
                                Description: "Integration config. Each integration type has different schema, use [GET /api/v2/integrations/types/{typeId}/configschemas/{configType}](https://developer.mypurecloud.com/api/rest/v2/integrations/#get-api-v2-integrations-types--typeId--configschemas--configType-) to check schema, then use the correct attribute names for properties.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Computed:    true,
                                Elem:        integrationConfigResource,
                        },
                },
        }
}</span>

// IntegrationExporter returns the resourceExporter object used to hold the genesyscloud_integration exporter's config
func IntegrationExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllIntegrations),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "config.credentials.*": {RefType: "genesyscloud_integration_credential"},
                },
                JsonEncodeAttributes: []string{"config.properties", "config.advanced"},
                EncodedRefAttrs: map[*resourceExporter.JsonEncodeRefAttr]*resourceExporter.RefAttrSettings{
                        {Attr: "config.properties", NestedAttr: "groups"}: {RefType: "genesyscloud_group"},
                },
        }
}</span>

// DataSourceIntegration registers the genesyscloud_integration data source
func DataSourceIntegration() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud integration. Select an integration by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceIntegrationRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the integration",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package integration

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

// flattenIntegrationConfig converts a platformclientv2.Integrationconfiguration into a map and then into single-element array for consumption by Terraform
func flattenIntegrationConfig(config *platformclientv2.Integrationconfiguration) []interface{} <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var (
                configName        string
                configNotes       string
                configProperties  string
                configAdvanced    string
                configCredentials map[string]interface{}
        )

        if config.Name != nil </span><span class="cov8" title="1">{
                configName = *config.Name
        }</span>
        <span class="cov8" title="1">if config.Notes != nil </span><span class="cov8" title="1">{
                if *config.Notes == "node_dynamodb_empty_string" </span><span class="cov0" title="0">{
                        *config.Notes = ""
                }</span>
                <span class="cov8" title="1">configNotes = *config.Notes</span>
        }
        <span class="cov8" title="1">if config.Properties != nil </span><span class="cov8" title="1">{
                propJSONStr, err := json.Marshal(*config.Properties)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to marshal integration config properties. Error message: %s", err)
                }</span> else<span class="cov8" title="1"> {
                        configProperties = string(propJSONStr)
                }</span>
        }
        <span class="cov8" title="1">if config.Advanced != nil </span><span class="cov8" title="1">{
                advJSONStr, err := json.Marshal(*config.Advanced)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to marshal integration config advanced properties. Error message: %s", err)
                }</span> else<span class="cov8" title="1"> {
                        configAdvanced = string(advJSONStr)
                }</span>
        }
        <span class="cov8" title="1">if config.Credentials != nil </span><span class="cov8" title="1">{
                configCredentials = flattenConfigCredentials(*config.Credentials)
        }</span>

        <span class="cov8" title="1">return []interface{}{map[string]interface{}{
                "name":        configName,
                "notes":       configNotes,
                "properties":  configProperties,
                "advanced":    configAdvanced,
                "credentials": configCredentials,
        }}</span>
}

// flattenConfigCredentials converts a map of platformclientv2.Credentialinfo into a map of only the credential IDs for consumption by Terraform
func flattenConfigCredentials(credentials map[string]platformclientv2.Credentialinfo) map[string]interface{} <span class="cov8" title="1">{
        if len(credentials) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">results := make(map[string]interface{})
        for k, v := range credentials </span><span class="cov8" title="1">{
                results[k] = *v.Id
        }</span>
        <span class="cov8" title="1">return results</span>
}

// updateIntegrationConfigFromResourceData takes the integrationsProxy to update updates the config of an integration
// Returns a diag error and the name of the integration
func updateIntegrationConfigFromResourceData(ctx context.Context, d *schema.ResourceData, p *integrationsProxy) (diag.Diagnostics, string) <span class="cov8" title="1">{
        if d.HasChange("config") </span><span class="cov8" title="1">{
                if configInput := d.Get("config").([]interface{}); configInput != nil </span><span class="cov8" title="1">{

                        integrationConfig, _, err := p.getIntegrationConfig(ctx, d.Id())
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.Errorf("Failed to get the integration config for integration %s before updating its config: %s", d.Id(), err), ""
                        }</span>

                        <span class="cov8" title="1">name := *integrationConfig.Name
                        notes := *integrationConfig.Notes
                        propJSON := *integrationConfig.Properties
                        advJSON := *integrationConfig.Advanced
                        credential := *integrationConfig.Credentials

                        if len(configInput) &gt; 0 </span><span class="cov8" title="1">{
                                configMap := configInput[0].(map[string]interface{})

                                if configMap["name"].(string) != "" </span><span class="cov8" title="1">{
                                        name = configMap["name"].(string)
                                }</span>

                                <span class="cov8" title="1">notes = configMap["notes"].(string)

                                if properties := configMap["properties"].(string); len(properties) &gt; 0 </span><span class="cov8" title="1">{
                                        if err := json.Unmarshal([]byte(properties), &amp;propJSON); err != nil </span><span class="cov0" title="0">{
                                                return diag.Errorf("Failed to convert properties string to JSON for integration %s: %s", d.Id(), err), name
                                        }</span>
                                }

                                <span class="cov8" title="1">if advanced := configMap["advanced"].(string); len(advanced) &gt; 0 </span><span class="cov8" title="1">{
                                        if err := json.Unmarshal([]byte(advanced), &amp;advJSON); err != nil </span><span class="cov0" title="0">{
                                                return diag.Errorf("Failed to convert advanced property string to JSON for integration %s: %s", d.Id(), err), name
                                        }</span>
                                }

                                <span class="cov8" title="1">credential = buildConfigCredentials(configMap["credentials"].(map[string]interface{}))</span>
                        }

                        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{

                                // Get latest config version
                                integrationConfig, resp, err := p.getIntegrationConfig(ctx, d.Id())
                                if err != nil </span><span class="cov0" title="0">{
                                        return resp, diag.Errorf("Failed to get the integration config for integration %s before updating its config: %s", d.Id(), err)
                                }</span>

                                <span class="cov8" title="1">_, resp, err = p.updateIntegrationConfig(ctx, d.Id(), &amp;platformclientv2.Integrationconfiguration{
                                        Name:        &amp;name,
                                        Notes:       &amp;notes,
                                        Version:     integrationConfig.Version,
                                        Properties:  &amp;propJSON,
                                        Advanced:    &amp;advJSON,
                                        Credentials: &amp;credential,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return resp, diag.Errorf("Failed to update config for integration %s: %s", d.Id(), err)
                                }</span>
                                <span class="cov8" title="1">return nil, nil</span>
                        })
                        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                                return diagErr, ""
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil, ""</span>
}

// buildConfigCredentials takes a map of credential IDs and turns it into a map of platformclientv2.Credentialinfo
func buildConfigCredentials(credentials map[string]interface{}) map[string]platformclientv2.Credentialinfo <span class="cov8" title="1">{
        results := make(map[string]platformclientv2.Credentialinfo)
        if len(credentials) &gt; 0 </span><span class="cov8" title="1">{
                for k, v := range credentials </span><span class="cov8" title="1">{
                        credID := v.(string)
                        results[k] = platformclientv2.Credentialinfo{Id: &amp;credID}
                }</span>
                <span class="cov8" title="1">return results</span>
        }
        <span class="cov8" title="1">return results</span>
}

// GenerateIntegrationResource builds the terraform string for creating an integration
func GenerateIntegrationResource(resourceID string, intendedState string, integrationType string, attrs ...string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`resource "genesyscloud_integration" "%s" {
        intended_state = %s
        integration_type = %s
        %s
        }
        `, resourceID, intendedState, integrationType, strings.Join(attrs, "\n"))
}</span>

func GenerateIntegrationConfig(name string, notes string, cred string, props string, adv string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`config {
        name = %s
        notes = %s
        credentials = {
            %s
        }
        properties = %s
        advanced = %s
        }
        `, name, notes, cred, props, adv)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package integration_action

import (
        "context"
        "fmt"
        "time"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_integration_action.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

// dataSourceIntegrationActionRead retrieves by name the integration action id in question
func dataSourceIntegrationActionRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        iap := getIntegrationActionsProxy(sdkConfig)

        actionName := d.Get("name").(string)

        // Query for integration actions by name. Retry in case new action is not yet indexed by search.
        // As action names are non-unique, fail in case of multiple results.
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                actions, err := iap.getIntegrationActionsByName(ctx, actionName)

                if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting data action %s: %s", actionName, err))
                }</span>

                <span class="cov0" title="0">if len(*actions) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no data actions found with name %s", actionName))
                }</span>

                <span class="cov0" title="0">if len(*actions) &gt; 1 </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("ambiguous data action name: %s", actionName))
                }</span>

                <span class="cov0" title="0">action := (*actions)[0]
                d.SetId(*action.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package integration_action

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_integration_action_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.
*/

/*
NOTE: Most of the integration action methods invokes the API manually instead of using the Genesys Cloud Go SDK types
and API methods. This is due to the limitation of the output contract.
In the SDK the input and output contracts are of the Jsonschemadocument type. This defines a JSON schema
for the contract. The type has the usual properties like 'Name' and 'Properties' however it is missing the 'Items'
property which is needed to define the item type of an array.
In the API, the output contract allows the root to be of 'array' type instead of 'object'. If that is the case it requires
the 'Items' property to define the 'object' schema it allows. Since it's impossible to do with the SDK,
helper methods and types are created to invoke the APIs with Genesys Cloud.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *integrationActionsProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllIntegrationActionsFunc func(ctx context.Context, p *integrationActionsProxy) (*[]platformclientv2.Action, error)
type createIntegrationActionFunc func(ctx context.Context, p *integrationActionsProxy, action *IntegrationAction) (*IntegrationAction, *platformclientv2.APIResponse, error)
type getIntegrationActionByIdFunc func(ctx context.Context, p *integrationActionsProxy, actionId string) (*IntegrationAction, *platformclientv2.APIResponse, error)
type getIntegrationActionsByNameFunc func(ctx context.Context, p *integrationActionsProxy, actionName string) (actions *[]platformclientv2.Action, err error)
type updateIntegrationActionFunc func(ctx context.Context, p *integrationActionsProxy, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error)
type deleteIntegrationActionFunc func(ctx context.Context, p *integrationActionsProxy, actionId string) (*platformclientv2.APIResponse, error)
type getIntegrationActionTemplateFunc func(ctx context.Context, p *integrationActionsProxy, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error)

// integrationActionsProxy contains all of the methods that call genesys cloud APIs.
type integrationActionsProxy struct {
        clientConfig                     *platformclientv2.Configuration
        integrationsApi                  *platformclientv2.IntegrationsApi
        getAllIntegrationActionsAttr     getAllIntegrationActionsFunc
        createIntegrationActionAttr      createIntegrationActionFunc
        getIntegrationActionByIdAttr     getIntegrationActionByIdFunc
        getIntegrationActionsByNameAttr  getIntegrationActionsByNameFunc
        updateIntegrationActionAttr      updateIntegrationActionFunc
        deleteIntegrationActionAttr      deleteIntegrationActionFunc
        getIntegrationActionTemplateAttr getIntegrationActionTemplateFunc
}

// newIntegrationActionsProxy initializes the integrationActionsProxy with all of the data needed to communicate with Genesys Cloud
func newIntegrationActionsProxy(clientConfig *platformclientv2.Configuration) *integrationActionsProxy <span class="cov0" title="0">{
        api := platformclientv2.NewIntegrationsApiWithConfig(clientConfig)
        return &amp;integrationActionsProxy{
                clientConfig:                     clientConfig,
                integrationsApi:                  api,
                getAllIntegrationActionsAttr:     getAllIntegrationActionsFn,
                createIntegrationActionAttr:      createIntegrationActionFn,
                getIntegrationActionByIdAttr:     getIntegrationActionByIdFn,
                getIntegrationActionsByNameAttr:  getIntegrationActionsByNameFn,
                updateIntegrationActionAttr:      updateIntegrationActionFn,
                deleteIntegrationActionAttr:      deleteIntegrationActionFn,
                getIntegrationActionTemplateAttr: getIntegrationActionTemplateFn,
        }
}</span>

// getIntegrationActionsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getIntegrationActionsProxy(clientConfig *platformclientv2.Configuration) *integrationActionsProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newIntegrationActionsProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// getAllIntegrationActions retrieves all Genesys Cloud Integration Actions
func (p *integrationActionsProxy) getAllIntegrationActions(ctx context.Context) (*[]platformclientv2.Action, error) <span class="cov0" title="0">{
        return p.getAllIntegrationActionsAttr(ctx, p)
}</span>

// createIntegrationAction creates a Genesys Cloud Integration Action
func (p *integrationActionsProxy) createIntegrationAction(ctx context.Context, actionInput *IntegrationAction) (*IntegrationAction, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.createIntegrationActionAttr(ctx, p, actionInput)
}</span>

// getIntegrationActionById gets a Genesys Cloud Integration Action by id
func (p *integrationActionsProxy) getIntegrationActionById(ctx context.Context, actionId string) (action *IntegrationAction, response *platformclientv2.APIResponse, err error) <span class="cov0" title="0">{
        return p.getIntegrationActionByIdAttr(ctx, p, actionId)
}</span>

// getIntegrationActionsByName gets a Genesys Cloud Integration Action by name
func (p *integrationActionsProxy) getIntegrationActionsByName(ctx context.Context, actionName string) (actions *[]platformclientv2.Action, err error) <span class="cov0" title="0">{
        return p.getIntegrationActionsByNameAttr(ctx, p, actionName)
}</span>

// updateIntegrationAction updates a Genesys Cloud Integration Action
func (p *integrationActionsProxy) updateIntegrationAction(ctx context.Context, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.updateIntegrationActionAttr(ctx, p, actionId, updateAction)
}</span>

// deleteIntegrationAction deletes a Genesys Cloud Integration Action
func (p *integrationActionsProxy) deleteIntegrationAction(ctx context.Context, actionId string) (*platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.deleteIntegrationActionAttr(ctx, p, actionId)
}</span>

// getIntegrationActionTemplate gets a Genesys Cloud Integration Action Contract Template by its filename
func (p *integrationActionsProxy) getIntegrationActionTemplate(ctx context.Context, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.getIntegrationActionTemplateAttr(ctx, p, actionId, fileName)
}</span>

// getAllIntegrationActionsFn is the implementation for retrieving all integration actions in Genesys Cloud
func getAllIntegrationActionsFn(ctx context.Context, p *integrationActionsProxy) (*[]platformclientv2.Action, error) <span class="cov0" title="0">{
        actions := []platformclientv2.Action{}

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                actionsList, _, err := p.integrationsApi.GetIntegrationsActions(pageSize, pageNum, "", "", "", "", "", "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if actionsList.Entities == nil || len(*actionsList.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">actions = append(actions, *actionsList.Entities...)</span>
        }

        <span class="cov0" title="0">return &amp;actions, nil</span>
}

// createIntegrationActionFn is the implementation for creating an integration action in Genesys Cloud
func createIntegrationActionFn(ctx context.Context, p *integrationActionsProxy, actionInput *IntegrationAction) (*IntegrationAction, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        action, resp, err := sdkPostIntegrationAction(actionInput, p.integrationsApi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov0" title="0">return action, resp, nil</span>
}

// getIntegrationActionByIdFn is the implementation for getting an integration action by id in Genesys Cloud
func getIntegrationActionByIdFn(ctx context.Context, p *integrationActionsProxy, actionId string) (*IntegrationAction, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        action, resp, err := sdkGetIntegrationAction(actionId, p.integrationsApi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov0" title="0">return action, resp, nil</span>
}

// getIntegrationActionsByNameFn is the implementation for getting an integration action by name in Genesys Cloud
func getIntegrationActionsByNameFn(ctx context.Context, p *integrationActionsProxy, actionName string) (*[]platformclientv2.Action, error) <span class="cov0" title="0">{
        var actions []platformclientv2.Action

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                integrationAction, _, err := p.integrationsApi.GetIntegrationsActions(pageSize, pageNum, "", "", "", "", "", actionName, "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if integrationAction.Entities == nil || len(*integrationAction.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, action := range *integrationAction.Entities </span><span class="cov0" title="0">{
                        if action.Name != nil &amp;&amp; *action.Name == actionName </span><span class="cov0" title="0">{
                                actions = append(actions, action)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;actions, nil</span>
}

// updateIntegrationActionFn is the implementation for updating an integration action in Genesys Cloud
func updateIntegrationActionFn(ctx context.Context, p *integrationActionsProxy, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        action, resp, err := p.integrationsApi.PatchIntegrationsAction(actionId, *updateAction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov0" title="0">return action, resp, nil</span>
}

// deleteIntegrationActionFn is the implementation for deleting an integration action in Genesys Cloud
func deleteIntegrationActionFn(ctx context.Context, p *integrationActionsProxy, actionId string) (*platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        resp, err := p.integrationsApi.DeleteIntegrationsAction(actionId)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// getIntegrationActionTemplateFn is the implementation for getting the integration action template in Genesys Cloud
func getIntegrationActionTemplateFn(ctx context.Context, p *integrationActionsProxy, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        template, resp, err := sdkGetIntegrationActionTemplate(actionId, fileName, p.integrationsApi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov0" title="0">return template, resp, nil</span>
}

// sdkPostIntegrationAction is the non-sdk helper method for creating an Integration Action
func sdkPostIntegrationAction(body *IntegrationAction, api *platformclientv2.IntegrationsApi) (*IntegrationAction, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        apiClient := &amp;api.Configuration.APIClient

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/integrations/actions"

        headerParams := make(map[string]string)

        // add default headers if any
        for key := range api.Configuration.DefaultHeader </span><span class="cov0" title="0">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov0" title="0">headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        var successPayload *IntegrationAction
        response, err := apiClient.CallAPI(path, http.MethodPost, body, headerParams, nil, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov0" title="0"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov0" title="0"> {
                err = json.Unmarshal([]byte(response.RawBody), &amp;successPayload)
        }</span>
        <span class="cov0" title="0">return successPayload, response, err</span>
}

// sdkGetIntegrationAction is the non-sdk helper method for getting an Integration Action
func sdkGetIntegrationAction(actionId string, api *platformclientv2.IntegrationsApi) (*IntegrationAction, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        apiClient := &amp;api.Configuration.APIClient

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/integrations/actions/" + actionId

        headerParams := make(map[string]string)
        queryParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov0" title="0">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov0" title="0">for key := range api.Configuration.DefaultHeader </span><span class="cov0" title="0">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov0" title="0">queryParams["expand"] = "contract"
        queryParams["includeConfig"] = "true"

        headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        var successPayload *IntegrationAction
        response, err := apiClient.CallAPI(path, http.MethodGet, nil, headerParams, queryParams, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov0" title="0"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov0" title="0"> {
                err = json.Unmarshal([]byte(response.RawBody), &amp;successPayload)
        }</span>
        <span class="cov0" title="0">return successPayload, response, err</span>
}

// sdkGetIntegrationActionTemplate is the non-sdk helper method for getting an Integration Action Template
func sdkGetIntegrationActionTemplate(actionId, templateName string, api *platformclientv2.IntegrationsApi) (*string, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        apiClient := &amp;api.Configuration.APIClient

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/integrations/actions/" + actionId + "/templates/" + templateName

        headerParams := make(map[string]string)
        queryParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov0" title="0">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov0" title="0">for key := range api.Configuration.DefaultHeader </span><span class="cov0" title="0">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov0" title="0">headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "*/*"

        var successPayload *string
        response, err := apiClient.CallAPI(path, http.MethodGet, nil, headerParams, queryParams, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov0" title="0"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov0" title="0"> {
                templateStr := string(response.RawBody)
                successPayload = &amp;templateStr
        }</span>
        <span class="cov0" title="0">return successPayload, response, err</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package integration_action

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration_action.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesycloud_integration_action)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

 1. All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

 2. In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a

utils function in the package.  This will keep the code manageable and easy to work through.
*/

// getAllIntegrationActions retrieves all of the integration action via Terraform in the Genesys Cloud and is used for the exporter
func getAllIntegrationActions(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        iap := getIntegrationActionsProxy(clientConfig)

        actions, err := iap.getAllIntegrationActions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get page of integration actions: %v", err)
        }</span>

        <span class="cov0" title="0">for _, action := range *actions </span><span class="cov0" title="0">{
                // Don't include "static" actions
                if strings.HasPrefix(*action.Id, "static") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">resources[*action.Id] = &amp;resourceExporter.ResourceMeta{Name: *action.Name}</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createIntegrationAction is used by the integration actions resource to create Genesyscloud integration action
func createIntegrationAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        name := d.Get("name").(string)
        category := d.Get("category").(string)
        integrationId := d.Get("integration_id").(string)
        secure := d.Get("secure").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        iap := getIntegrationActionsProxy(sdkConfig)

        log.Printf("Creating integration action %s", name)

        actionContract, diagErr := BuildSdkActionContract(d)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">diagErr = gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov0" title="0">{
                action, resp, err := iap.createIntegrationAction(ctx, &amp;IntegrationAction{
                        Name:          &amp;name,
                        Category:      &amp;category,
                        IntegrationId: &amp;integrationId,
                        Secure:        &amp;secure,
                        Contract:      actionContract,
                        Config:        BuildSdkActionConfig(d),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to create integration action %s: %s", name, err)
                }</span>
                <span class="cov0" title="0">d.SetId(*action.Id)

                log.Printf("Created integration action %s %s", name, *action.Id)
                return resp, nil</span>
        })
        <span class="cov0" title="0">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">return readIntegrationAction(ctx, d, meta)</span>
}

// readIntegrationAction is used by the integration action resource to read an action from genesys cloud.
func readIntegrationAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        iap := getIntegrationActionsProxy(sdkConfig)

        log.Printf("Reading integration action %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                action, resp, err := iap.getIntegrationActionById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read integration action %s: %s", d.Id(), err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read integration action %s: %s", d.Id(), err))</span>
                }

                // Retrieve config request/response templates
                <span class="cov0" title="0">reqTemp, resp, err := iap.getIntegrationActionTemplate(ctx, d.Id(), reqTemplateFileName)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                d.SetId("")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read request template for integration action %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">successTemp, resp, err := iap.getIntegrationActionTemplate(ctx, d.Id(), successTemplateFileName)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                d.SetId("")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read success template for integration action %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceIntegrationAction())

                resourcedata.SetNillableValue(d, "name", action.Name)
                resourcedata.SetNillableValue(d, "category", action.Category)
                resourcedata.SetNillableValue(d, "integration_id", action.IntegrationId)
                resourcedata.SetNillableValue(d, "secure", action.Secure)
                resourcedata.SetNillableValue(d, "config_timeout_seconds", action.Config.TimeoutSeconds)

                if action.Contract != nil &amp;&amp; action.Contract.Input != nil &amp;&amp; action.Contract.Input.InputSchema != nil </span><span class="cov0" title="0">{
                        input, err := flattenActionContract(*action.Contract.Input.InputSchema)
                        if err != nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("%v", err))
                        }</span>
                        <span class="cov0" title="0">d.Set("contract_input", input)</span>
                } else<span class="cov0" title="0"> {
                        d.Set("contract_input", nil)
                }</span>

                <span class="cov0" title="0">if action.Contract != nil &amp;&amp; action.Contract.Output != nil &amp;&amp; action.Contract.Output.SuccessSchema != nil </span><span class="cov0" title="0">{
                        output, err := flattenActionContract(*action.Contract.Output.SuccessSchema)
                        if err != nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("%v", err))
                        }</span>
                        <span class="cov0" title="0">d.Set("contract_output", output)</span>
                } else<span class="cov0" title="0"> {
                        d.Set("contract_output", nil)
                }</span>

                <span class="cov0" title="0">if action.Config != nil &amp;&amp; action.Config.Request != nil </span><span class="cov0" title="0">{
                        action.Config.Request.RequestTemplate = reqTemp
                        d.Set("config_request", FlattenActionConfigRequest(*action.Config.Request))
                }</span> else<span class="cov0" title="0"> {
                        d.Set("config_request", nil)
                }</span>

                <span class="cov0" title="0">if action.Config != nil &amp;&amp; action.Config.Response != nil </span><span class="cov0" title="0">{
                        action.Config.Response.SuccessTemplate = successTemp
                        d.Set("config_response", FlattenActionConfigResponse(*action.Config.Response))
                }</span> else<span class="cov0" title="0"> {
                        d.Set("config_response", nil)
                }</span>

                <span class="cov0" title="0">log.Printf("Read integration action %s %s", d.Id(), *action.Name)
                return cc.CheckState()</span>
        })
}

// updateIntegrationAction is used by the integration action resource to update an action in Genesys Cloud
func updateIntegrationAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        iap := getIntegrationActionsProxy(sdkConfig)

        name := d.Get("name").(string)
        category := d.Get("category").(string)

        log.Printf("Updating integration action %s", name)

        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov0" title="0">{
                // Get the latest action version to send with PATCH
                action, resp, err := iap.getIntegrationActionById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read integration action %s: %s", d.Id(), err)
                }</span>

                <span class="cov0" title="0">_, resp, err = iap.updateIntegrationAction(ctx, d.Id(), &amp;platformclientv2.Updateactioninput{
                        Name:     &amp;name,
                        Category: &amp;category,
                        Version:  action.Version,
                        Config:   BuildSdkActionConfig(d),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update integration action %s: %s", name, err)
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        })
        <span class="cov0" title="0">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">log.Printf("Updated integration action %s", name)
        return readIntegrationAction(ctx, d, meta)</span>
}

// deleteIntegrationAction is used by the integration action resource to delete an action from Genesys cloud.
func deleteIntegrationAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        iap := getIntegrationActionsProxy(sdkConfig)

        log.Printf("Deleting integration action %s", name)
        resp, err := iap.deleteIntegrationAction(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                        // Parent integration was probably deleted which caused the action to be deleted
                        log.Printf("Integration action already deleted %s", d.Id())
                        return nil
                }</span>
                <span class="cov0" title="0">return diag.Errorf("Failed to delete Integration action %s: %s", d.Id(), err)</span>
        }

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, resp, err := iap.getIntegrationActionById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                // Integration action deleted
                                log.Printf("Deleted Integration action %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting integration action %s: %s", d.Id(), err))</span>
                }
                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("integration action %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package integration_action

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

/*
resource_genesyscloud_integration_action_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the integration_action resource.
3.  The datasource schema definitions for the integration_action datasource.
4.  The resource exporter configuration for the integration_action exporter.
*/
const resourceName = "genesyscloud_integration_action"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceIntegrationAction())
        l.RegisterResource(resourceName, ResourceIntegrationAction())
        l.RegisterExporter(resourceName, IntegrationActionExporter())
}</span>

// ResourceIntegrationAction registers the genesyscloud_integration_action resource with Terraform
func ResourceIntegrationAction() *schema.Resource <span class="cov8" title="1">{
        actionConfigRequest := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "request_url_template": {
                                Description: "URL that may include placeholders for requests to 3rd party service.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "request_type": {
                                Description:  "HTTP method to use for request (GET | PUT | POST | PATCH | DELETE).",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"GET", "PUT", "POST", "PATCH", "DELETE"}, false),
                        },
                        "request_template": {
                                Description: "Velocity template to define request body sent to 3rd party service. Any instances of '${' must be properly escaped as '$${'",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                        "headers": {
                                Description: "Map of headers in name, value pairs to include in request.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }

        actionConfigResponse := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "translation_map": {
                                Description: "Map 'attribute name' and 'JSON path' pairs used to extract data from REST response.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "translation_map_defaults": {
                                Description: "Map 'attribute name' and 'default value' pairs used as fallback values if JSON path extraction fails for specified key.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "success_template": {
                                Description: "Velocity template to build response to return from Action. Any instances of '${' must be properly escaped as '$${'.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud Integration Actions. See this page for detailed information on configuring Actions: https://help.mypurecloud.com/articles/add-configuration-custom-actions-integrations/",

                CreateContext: gcloud.CreateWithPooledClient(createIntegrationAction),
                ReadContext:   gcloud.ReadWithPooledClient(readIntegrationAction),
                UpdateContext: gcloud.UpdateWithPooledClient(updateIntegrationAction),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteIntegrationAction),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description:  "Name of the action. Can be up to 256 characters long",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringLenBetween(1, 256),
                        },
                        "category": {
                                Description:  "Category of action. Can be up to 256 characters long.",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringLenBetween(1, 256),
                        },
                        "integration_id": {
                                Description: "The ID of the integration this action is associated with. Changing the integration_id attribute will cause the existing integration_action to be dropped and recreated with a new ID.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "secure": {
                                Description: "Indication of whether or not the action is designed to accept sensitive data. Changing the secure attribute will cause the existing integration_action to be dropped and recreated with a new ID.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                ForceNew:    true,
                        },
                        "config_timeout_seconds": {
                                Description:  "Optional 1-60 second timeout enforced on the execution or test of this action. This setting is invalid for Custom Authentication Actions.",
                                Type:         schema.TypeInt,
                                Optional:     true,
                                ValidateFunc: validation.IntBetween(1, 60),
                        },
                        "contract_input": {
                                Description:      "JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. Changing the contract_input attribute will cause the existing integration_action to be dropped and recreated with a new ID.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ForceNew:         true,
                                DiffSuppressFunc: gcloud.SuppressEquivalentJsonDiffs,
                        },
                        "contract_output": {
                                Description:      "JSON schema that defines the transformed, successful result that will be sent back to the caller. Changing the contract_output attribute will cause the existing integration_action to be dropped and recreated with a new ID.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ForceNew:         true,
                                DiffSuppressFunc: gcloud.SuppressEquivalentJsonDiffs,
                        },
                        "config_request": {
                                Description: "Configuration of outbound request.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Elem:        actionConfigRequest,
                        },
                        "config_response": {
                                Description: "Configuration of response processing.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Computed:    true,
                                MaxItems:    1,
                                Elem:        actionConfigResponse,
                        },
                },
        }
}</span>

// IntegrationActionExporter returns the resourceExporter object used to hold the genesyscloud_integration_action exporter's config
func IntegrationActionExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllIntegrationActions),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "integration_id": {RefType: "genesyscloud_integration"},
                },
                JsonEncodeAttributes: []string{"contract_input", "contract_output"},
        }
}</span>

// DataSourceIntegrationAction registers the genesyscloud_integration_action data source
func DataSourceIntegrationAction() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud integration action. Select an integration action by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceIntegrationActionRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the integration action",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package integration_action

import (
        "encoding/json"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
)

/*
The resource_genesyscloud_integration_action_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

const (
        reqTemplateFileName     = "requesttemplate.vm"
        successTemplateFileName = "successtemplate.vm"
)

type ActionInput struct {
        InputSchema *interface{} `json:"inputSchema,omitempty"`
}
type ActionOutput struct {
        SuccessSchema *interface{} `json:"successSchema,omitempty"`
}

type ActionContract struct {
        Output *ActionOutput `json:"output,omitempty"`
        Input  *ActionInput  `json:"input,omitempty"`
}

type IntegrationAction struct {
        Id            *string                        `json:"id,omitempty"`
        Name          *string                        `json:"name,omitempty"`
        Category      *string                        `json:"category,omitempty"`
        IntegrationId *string                        `json:"integrationId,omitempty"`
        Secure        *bool                          `json:"secure,omitempty"`
        Config        *platformclientv2.Actionconfig `json:"config,omitempty"`
        Contract      *ActionContract                `json:"contract,omitempty"`
        Version       *int                           `json:"version,omitempty"`
}

// BuildSdkActionContract takes the resource data and builds the custom ActionContract from it
func BuildSdkActionContract(d *schema.ResourceData) (*ActionContract, diag.Diagnostics) <span class="cov0" title="0">{
        configInput := d.Get("contract_input").(string)
        inputVal, err := gcloud.JsonStringToInterface(configInput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to parse contract input %s: %v", configInput, err)
        }</span>

        <span class="cov0" title="0">configOutput := d.Get("contract_output").(string)
        outputVal, err := gcloud.JsonStringToInterface(configOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to parse contract output %s: %v", configInput, err)
        }</span>

        <span class="cov0" title="0">return &amp;ActionContract{
                Input:  &amp;ActionInput{InputSchema: &amp;inputVal},
                Output: &amp;ActionOutput{SuccessSchema: &amp;outputVal},
        }, nil</span>
}

// buildSdkActionConfig takes the resource data and builds the SDK platformclientv2.Actionconfig from it
func BuildSdkActionConfig(d *schema.ResourceData) *platformclientv2.Actionconfig <span class="cov0" title="0">{
        ConfigTimeoutSeconds := d.Get("config_timeout_seconds").(int)
        ActionConfig := &amp;platformclientv2.Actionconfig{
                Request:  BuildSdkActionConfigRequest(d),
                Response: BuildSdkActionConfigResponse(d),
        }

        if ConfigTimeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                ActionConfig.TimeoutSeconds = &amp;ConfigTimeoutSeconds
        }</span>

        <span class="cov0" title="0">return ActionConfig</span>
}

// buildSdkActionConfigRequest takes the resource data and builds the SDK platformclientv2.Requestconfig from it
func BuildSdkActionConfigRequest(d *schema.ResourceData) *platformclientv2.Requestconfig <span class="cov0" title="0">{
        if configRequest := d.Get("config_request"); configRequest != nil </span><span class="cov0" title="0">{
                if configList := configRequest.([]interface{}); len(configList) &gt; 0 </span><span class="cov0" title="0">{
                        configMap := configList[0].(map[string]interface{})

                        urlTemplate := configMap["request_url_template"].(string)
                        template := configMap["request_template"].(string)
                        reqType := configMap["request_type"].(string)
                        headers := map[string]string{}
                        if headerVal, ok := configMap["headers"]; ok &amp;&amp; headerVal != nil </span><span class="cov0" title="0">{
                                for key, val := range headerVal.(map[string]interface{}) </span><span class="cov0" title="0">{
                                        headers[key] = val.(string)
                                }</span>
                        }

                        <span class="cov0" title="0">return &amp;platformclientv2.Requestconfig{
                                RequestUrlTemplate: &amp;urlTemplate,
                                RequestTemplate:    &amp;template,
                                RequestType:        &amp;reqType,
                                Headers:            &amp;headers,
                        }</span>
                }
        }
        <span class="cov0" title="0">return &amp;platformclientv2.Requestconfig{}</span>
}

// buildSdkActionConfigResponse takes the resource data and builds the SDK platformclientv2.Responseconfig from it
func BuildSdkActionConfigResponse(d *schema.ResourceData) *platformclientv2.Responseconfig <span class="cov0" title="0">{
        if configResponse := d.Get("config_response"); configResponse != nil </span><span class="cov0" title="0">{
                if configList := configResponse.([]interface{}); len(configList) &gt; 0 </span><span class="cov0" title="0">{
                        configMap := configList[0].(map[string]interface{})

                        transMap := map[string]string{}
                        if mapVal, ok := configMap["translation_map"]; ok &amp;&amp; mapVal != nil </span><span class="cov0" title="0">{
                                for key, val := range mapVal.(map[string]interface{}) </span><span class="cov0" title="0">{
                                        transMap[key] = val.(string)
                                }</span>
                        }
                        <span class="cov0" title="0">transMapDefaults := map[string]string{}
                        if mapVal, ok := configMap["translation_map_defaults"]; ok &amp;&amp; mapVal != nil </span><span class="cov0" title="0">{
                                for key, val := range mapVal.(map[string]interface{}) </span><span class="cov0" title="0">{
                                        transMapDefaults[key] = val.(string)
                                }</span>
                        }
                        <span class="cov0" title="0">var successTemplate string
                        if tempVal, ok := configMap["success_template"]; ok </span><span class="cov0" title="0">{
                                successTemplate = tempVal.(string)
                        }</span>

                        <span class="cov0" title="0">return &amp;platformclientv2.Responseconfig{
                                TranslationMap:         &amp;transMap,
                                TranslationMapDefaults: &amp;transMapDefaults,
                                SuccessTemplate:        &amp;successTemplate,
                        }</span>
                }
        }
        <span class="cov0" title="0">return &amp;platformclientv2.Responseconfig{}</span>
}

// flattenActionContract converts the custom ActionContract into a JSON-encoded string
func flattenActionContract(schema interface{}) (string, diag.Diagnostics) <span class="cov0" title="0">{
        if schema == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">schemaBytes, err := json.Marshal(schema)
        if err != nil </span><span class="cov0" title="0">{
                return "", diag.Errorf("Error marshalling action contract %v: %v", schema, err)
        }</span>
        <span class="cov0" title="0">return string(schemaBytes), nil</span>
}

// flattenActionConfigRequest converts the platformclientv2.Requestconfig into a map
func FlattenActionConfigRequest(sdkRequest platformclientv2.Requestconfig) []interface{} <span class="cov0" title="0">{
        requestMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(requestMap, "request_url_template", sdkRequest.RequestUrlTemplate)
        resourcedata.SetMapValueIfNotNil(requestMap, "request_type", sdkRequest.RequestType)
        resourcedata.SetMapValueIfNotNil(requestMap, "request_template", sdkRequest.RequestTemplate)
        resourcedata.SetMapValueIfNotNil(requestMap, "headers", sdkRequest.Headers)

        return []interface{}{requestMap}
}</span>

// FlattenActionConfigResponse converts the the platformclientv2.Responseconfig into a map
func FlattenActionConfigResponse(sdkResponse platformclientv2.Responseconfig) []interface{} <span class="cov0" title="0">{
        responseMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(responseMap, "translation_map", sdkResponse.TranslationMap)
        resourcedata.SetMapValueIfNotNil(responseMap, "translation_map_defaults", sdkResponse.TranslationMapDefaults)
        resourcedata.SetMapValueIfNotNil(responseMap, "success_template", sdkResponse.SuccessTemplate)

        return []interface{}{responseMap}
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package integration_credential

import (
        "context"
        "fmt"
        "time"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_integration_credential.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

// dataSourceIntegrationCredentialRead retrieves by name the integration action id in question
func dataSourceIntegrationCredentialRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationCredsProxy(sdkConfig)

        credName := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                credential, retryable, err := ip.getIntegrationCredByName(ctx, credName)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("failed to get integration credential: %s. %s", credential, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no integration credential found: %s", credName))
                }</span>

                <span class="cov8" title="1">d.SetId(*credential.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package integration_credential

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_integration_credential_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *integrationCredsProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllIntegrationCredsFunc func(ctx context.Context, p *integrationCredsProxy) (*[]platformclientv2.Credentialinfo, error)
type createIntegrationCredFunc func(ctx context.Context, p *integrationCredsProxy, createCredential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error)
type getIntegrationCredByIdFunc func(ctx context.Context, p *integrationCredsProxy, credentialId string) (credential *platformclientv2.Credential, response *platformclientv2.APIResponse, err error)
type getIntegrationCredByNameFunc func(ctx context.Context, p *integrationCredsProxy, credentialName string) (credential *platformclientv2.Credentialinfo, retryable bool, err error)
type updateIntegrationCredFunc func(ctx context.Context, p *integrationCredsProxy, credentialId string, credential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error)
type deleteIntegrationCredFunc func(ctx context.Context, p *integrationCredsProxy, credentialId string) (responseCode int, err error)

// integrationCredsProxy contains all of the methods that call genesys cloud APIs.
type integrationCredsProxy struct {
        clientConfig                 *platformclientv2.Configuration
        integrationsApi              *platformclientv2.IntegrationsApi
        getAllIntegrationCredsAttr   getAllIntegrationCredsFunc
        createIntegrationCredAttr    createIntegrationCredFunc
        getIntegrationCredByIdAttr   getIntegrationCredByIdFunc
        getIntegrationCredByNameAttr getIntegrationCredByNameFunc
        updateIntegrationCredAttr    updateIntegrationCredFunc
        deleteIntegrationCredAttr    deleteIntegrationCredFunc
}

// newIntegrationCredsProxy initializes the Integration Credentials proxy with all of the data needed to communicate with Genesys Cloud
func newIntegrationCredsProxy(clientConfig *platformclientv2.Configuration) *integrationCredsProxy <span class="cov8" title="1">{
        api := platformclientv2.NewIntegrationsApiWithConfig(clientConfig)
        return &amp;integrationCredsProxy{
                clientConfig:                 clientConfig,
                integrationsApi:              api,
                getAllIntegrationCredsAttr:   getAllIntegrationCredsFn,
                createIntegrationCredAttr:    createIntegrationCredFn,
                getIntegrationCredByIdAttr:   getIntegrationCredByIdFn,
                getIntegrationCredByNameAttr: getIntegrationCredByNameFn,
                updateIntegrationCredAttr:    updateIntegrationCredFn,
                deleteIntegrationCredAttr:    deleteIntegrationCredFn,
        }
}</span>

// getIntegrationsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getIntegrationCredsProxy(clientConfig *platformclientv2.Configuration) *integrationCredsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newIntegrationCredsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllIntegrationCredentials retrieves all Genesys Cloud Integrations
func (p *integrationCredsProxy) getAllIntegrationCreds(ctx context.Context) (*[]platformclientv2.Credentialinfo, error) <span class="cov0" title="0">{
        return p.getAllIntegrationCredsAttr(ctx, p)
}</span>

// createIntegrationCred creates a Genesys Cloud Crdential
func (p *integrationCredsProxy) createIntegrationCred(ctx context.Context, createCredential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error) <span class="cov8" title="1">{
        return p.createIntegrationCredAttr(ctx, p, createCredential)
}</span>

// getIntegrationCredById gets a Genesys Cloud Integration Credential by id
func (p *integrationCredsProxy) getIntegrationCredById(ctx context.Context, credentialId string) (credential *platformclientv2.Credential, response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.getIntegrationCredByIdAttr(ctx, p, credentialId)
}</span>

// getIntegrationCredByName gets a Genesys Cloud Integration Credential by name
func (p *integrationCredsProxy) getIntegrationCredByName(ctx context.Context, credentialName string) (*platformclientv2.Credentialinfo, bool, error) <span class="cov8" title="1">{
        return p.getIntegrationCredByNameAttr(ctx, p, credentialName)
}</span>

// updateIntegrationCred udpates a Genesys Cloud Integration Credential
func (p *integrationCredsProxy) updateIntegrationCred(ctx context.Context, credentialId string, credential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error) <span class="cov8" title="1">{
        return p.updateIntegrationCredAttr(ctx, p, credentialId, credential)
}</span>

// deleteIntegrationCred deletes a Genesys Cloud Integration Credential
func (p *integrationCredsProxy) deleteIntegrationCred(ctx context.Context, credentialId string) (responseCode int, err error) <span class="cov8" title="1">{
        return p.deleteIntegrationCredAttr(ctx, p, credentialId)
}</span>

// getAllIntegrationCredsFn is the implementation for getting all integration credentials in Genesys Cloud
func getAllIntegrationCredsFn(ctx context.Context, p *integrationCredsProxy) (*[]platformclientv2.Credentialinfo, error) <span class="cov0" title="0">{
        var allCreds []platformclientv2.Credentialinfo

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                credentials, _, err := p.integrationsApi.GetIntegrationsCredentials(pageNum, pageSize)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if credentials.Entities == nil || len(*credentials.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">allCreds = append(allCreds, *credentials.Entities...)</span>
        }

        <span class="cov0" title="0">return &amp;allCreds, nil</span>
}

// createIntegrationCredFn is the implementation for creating an integration credential in Genesys Cloud
func createIntegrationCredFn(ctx context.Context, p *integrationCredsProxy, createCredential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error) <span class="cov8" title="1">{
        credential, _, err := p.integrationsApi.PostIntegrationsCredentials(*createCredential)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return credential, nil</span>
}

// getIntegrationCredByIdFn is the implementation for getting an integration credential by id in Genesys Cloud
func getIntegrationCredByIdFn(ctx context.Context, p *integrationCredsProxy, credentialId string) (*platformclientv2.Credential, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        credential, resp, err := p.integrationsApi.GetIntegrationsCredential(credentialId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return credential, resp, nil</span>
}

// getIntegrationCredByNameFn is the implementation for getting an integration credential by name in Genesys Cloud
func getIntegrationCredByNameFn(ctx context.Context, p *integrationCredsProxy, credentialName string) (*platformclientv2.Credentialinfo, bool, error) <span class="cov8" title="1">{
        var foundCred *platformclientv2.Credentialinfo

        for pageNum := 1; ; pageNum++ </span><span class="cov8" title="1">{
                const pageSize = 100
                integrationCredentials, _, err := p.integrationsApi.GetIntegrationsCredentials(pageNum, pageSize)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>

                <span class="cov8" title="1">if integrationCredentials.Entities == nil || len(*integrationCredentials.Entities) == 0 </span><span class="cov0" title="0">{
                        return nil, true, fmt.Errorf("no integration credentials found with name: %s", credentialName)
                }</span>

                <span class="cov8" title="1">for _, credential := range *integrationCredentials.Entities </span><span class="cov8" title="1">{
                        if credential.Name != nil &amp;&amp; *credential.Name == credentialName </span><span class="cov8" title="1">{
                                foundCred = &amp;credential
                                break</span>
                        }
                }
                <span class="cov8" title="1">if foundCred != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return foundCred, false, nil</span>
}

// updateIntegrationCredFn is the implementation for updating an integration credential in Genesys Cloud
func updateIntegrationCredFn(ctx context.Context, p *integrationCredsProxy, credentialId string, credential *platformclientv2.Credential) (*platformclientv2.Credentialinfo, error) <span class="cov8" title="1">{
        credInfo, _, err := p.integrationsApi.PutIntegrationsCredential(credentialId, *credential)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return credInfo, nil</span>
}

// deleteIntegrationCredFn is the implementation for deleting an integration credential in Genesys Cloud
func deleteIntegrationCredFn(ctx context.Context, p *integrationCredsProxy, credentialId string) (responseCode int, err error) <span class="cov8" title="1">{
        resp, err := p.integrationsApi.DeleteIntegrationsCredential(credentialId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package integration_credential

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration_credential.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesycloud_integration_credential)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

 1. All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

 2. In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a

utils function in the package.  This will keep the code manageable and easy to work through.
*/

// getAllCredentials retrieves all of the integration credentials via Terraform in the Genesys Cloud and is used for the exporter
func getAllCredentials(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        ip := getIntegrationCredsProxy(clientConfig)

        credentials, err := ip.getAllIntegrationCreds(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get all credentials: %v", err)
        }</span>

        <span class="cov0" title="0">for _, cred := range *credentials </span><span class="cov0" title="0">{
                log.Printf("Dealing with credential id : %s", *cred.Id)
                if cred.Name != nil </span><span class="cov0" title="0">{ // Credential is possible to have no name
                        resources[*cred.Id] = &amp;resourceExporter.ResourceMeta{Name: *cred.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createCredential is used by the integration credential resource to create Genesyscloud integration credential
func createCredential(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        cred_type := d.Get("credential_type_name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationCredsProxy(sdkConfig)

        createCredential := platformclientv2.Credential{
                Name: &amp;name,
                VarType: &amp;platformclientv2.Credentialtype{
                        Name: &amp;cred_type,
                },
                CredentialFields: buildCredentialFields(d),
        }

        credential, err := ip.createIntegrationCred(ctx, &amp;createCredential)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create credential %s : %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*credential.Id)

        log.Printf("Created credential %s, %s", name, *credential.Id)
        return readCredential(ctx, d, meta)</span>
}

// readCredential is used by the integration credential resource to read a  credential from genesys cloud.
func readCredential(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationCredsProxy(sdkConfig)

        log.Printf("Reading credential %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                currentCredential, resp, err := ip.getIntegrationCredById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read credential %s: %s", d.Id(), err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read credential %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceIntegrationCredential())
                d.Set("name", *currentCredential.Name)
                d.Set("credential_type_name", *currentCredential.VarType.Name)

                log.Printf("Read credential %s %s", d.Id(), *currentCredential.Name)

                return cc.CheckState()</span>
        })
}

// updateCredential is used by the integration credential resource to update a credential in Genesys Cloud
func updateCredential(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        cred_type := d.Get("credential_type_name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationCredsProxy(sdkConfig)

        if d.HasChanges("name", "credential_type_name", "fields") </span><span class="cov8" title="1">{
                log.Printf("Updating credential %s", name)

                _, err := ip.updateIntegrationCred(ctx, d.Id(), &amp;platformclientv2.Credential{
                        Name: &amp;name,
                        VarType: &amp;platformclientv2.Credentialtype{
                                Name: &amp;cred_type,
                        },
                        CredentialFields: buildCredentialFields(d),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to update credential %s: %s", name, err)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Updated credential %s %s", name, d.Id())
        return readCredential(ctx, d, meta)</span>
}

// deleteCredential is used by the integration credential resource to delete a credential from Genesys cloud.
func deleteCredential(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        ip := getIntegrationCredsProxy(sdkConfig)

        _, err := ip.deleteIntegrationCred(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete the credential %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := ip.getIntegrationCredById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Integration credential deleted
                                log.Printf("Deleted Integration credential %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting credential action %s: %s", d.Id(), err))</span>
                }
                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("integration credential %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package integration_credential

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_integration_credential_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the integration_credential resource.
3.  The datasource schema definitions for the integration_credential datasource.
4.  The resource exporter configuration for the integration_credential exporter.
*/
const resourceName = "genesyscloud_integration_credential"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceIntegrationCredential())
        l.RegisterResource(resourceName, ResourceIntegrationCredential())
        l.RegisterExporter(resourceName, IntegrationCredentialExporter())
}</span>

// ResourceIntegrationCredential registers the genesyscloud_integration_credential resource with Terraform
func ResourceIntegrationCredential() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Genesys Cloud Credential",

                CreateContext: gcloud.CreateWithPooledClient(createCredential),
                ReadContext:   gcloud.ReadWithPooledClient(readCredential),
                UpdateContext: gcloud.UpdateWithPooledClient(updateCredential),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteCredential),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Credential name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "credential_type_name": {
                                Description: "Credential type name. Use [GET /api/v2/integrations/credentials/types](https://developer.genesys.cloud/api/rest/v2/integrations/#get-api-v2-integrations-credentials-types) to see the list of available integration credential types. ",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "fields": {
                                Description: "Credential fields. Different credential types require different fields. Missing any correct required fields will result API request failure. Use [GET /api/v2/integrations/credentials/types](https://developer.genesys.cloud/api/rest/v2/integrations/#get-api-v2-integrations-credentials-types) to check out the specific credential type schema to find out what fields are required. ",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Computed:    true,
                                Sensitive:   true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }
}</span>

// IntegrationCredentialExporter returns the resourceExporter object used to hold the genesyscloud_integration_credential exporter's config
func IntegrationCredentialExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllCredentials),
                RefAttrs:         map[string]*resourceExporter.RefAttrSettings{}, // No Reference
                UnResolvableAttributes: map[string]*schema.Schema{
                        "fields": ResourceIntegrationCredential().Schema["fields"],
                },
        }
}</span>

// DataSourceIntegrationCredential registers the genesyscloud_integration_credential data source
func DataSourceIntegrationCredential() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud integration credential. Select an integration credential by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceIntegrationCredentialRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the integration credential",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package integration_credential

import (
        "fmt"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
The resource_genesyscloud_integration_credential_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

// buildCredentialFields builds a map of credential fields from the resource
func buildCredentialFields(d *schema.ResourceData) *map[string]string <span class="cov8" title="1">{
        results := make(map[string]string)
        if fields, ok := d.GetOk("fields"); ok </span><span class="cov8" title="1">{
                fieldMap := fields.(map[string]interface{})
                for k, v := range fieldMap </span><span class="cov8" title="1">{
                        results[k] = v.(string)
                }</span>
                <span class="cov8" title="1">return &amp;results</span>
        }
        <span class="cov0" title="0">return &amp;results</span>
}

// GenerateCredentialResource generates the terraform string for creating genesyscloud_integration_credential resource. Used for testing.
func GenerateCredentialResource(resourceID string, name string, credentialType string, fields string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`resource "genesyscloud_integration_credential" "%s" {
        name = %s
        credential_type_name = %s
        %s
        }
        `, resourceID, name, credentialType, fields)
}</span>

// GenerateCredentialFields builds a terraform string for multiple credential fields
func GenerateCredentialFields(fields ...string) string <span class="cov8" title="1">{
        return gcloud.GenerateMapAttr("fields", fields...)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package integration_custom_auth_action

import (
        "context"
        "fmt"
        "time"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_integration_custom_auth_action.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

// dataSourceIntegrationCustomAuthActionRead retrieves the custom auth action id from the integration name
func dataSourceIntegrationCustomAuthActionRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        cap := getCustomAuthActionsProxy(sdkConfig)

        integrationId := d.Get("parent_integration_id").(string)

        return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                integration, resp, getErr := cap.getIntegrationById(ctx, integrationId)
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read integration %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read integration %s: %s", d.Id(), getErr))</span>
                }

                // Get the custom auth action for the integration
                <span class="cov8" title="1">authActionId := getCustomAuthIdFromIntegration(*integration.Id)
                authAction, resp, err := cap.getCustomAuthActionById(ctx, authActionId)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("cannot find custom auth action of integration %s: %v", *integration.Name, err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting integration %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">d.SetId(*authAction.Id)

                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package integration_custom_auth_action

import (
        "context"
        "fmt"
        "strings"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_integration_custom_auth_action_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *customAuthActionsProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllIntegrationCustomAuthActionsFunc func(ctx context.Context, p *customAuthActionsProxy) (*[]platformclientv2.Action, error)
type getCustomAuthActionByIdFunc func(ctx context.Context, p *customAuthActionsProxy, actionId string) (*platformclientv2.Action, *platformclientv2.APIResponse, error)
type updateCustomAuthActionFunc func(ctx context.Context, p *customAuthActionsProxy, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error)
type getIntegrationActionTemplateFunc func(ctx context.Context, p *customAuthActionsProxy, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error)
type getIntegrationTypeFunc func(ctx context.Context, p *customAuthActionsProxy, integrationId string) (string, error)
type getIntegrationCredentialsTypeFunc func(ctx context.Context, p *customAuthActionsProxy, integrationId string) (string, error)
type getIntegrationByIdFunc func(ctx context.Context, p *customAuthActionsProxy, integrationName string) (integration *platformclientv2.Integration, resp *platformclientv2.APIResponse, err error)

// customAuthActionsProxy contains all of the methods that call genesys cloud APIs.
type customAuthActionsProxy struct {
        clientConfig                           *platformclientv2.Configuration
        integrationsApi                        *platformclientv2.IntegrationsApi
        getAllIntegrationCustomAuthActionsAttr getAllIntegrationCustomAuthActionsFunc
        getCustomAuthActionByIdAttr            getCustomAuthActionByIdFunc
        updateCustomAuthActionAttr             updateCustomAuthActionFunc
        getIntegrationActionTemplateAttr       getIntegrationActionTemplateFunc
        getIntegrationTypeAttr                 getIntegrationTypeFunc
        getIntegrationCredentialsTypeAttr      getIntegrationCredentialsTypeFunc
        getIntegrationByIdAttr                 getIntegrationByIdFunc
}

// newCustomAuthActionsProxy initializes the customAuthActionsProxy with all of the data needed to communicate with Genesys Cloud
func newCustomAuthActionsProxy(clientConfig *platformclientv2.Configuration) *customAuthActionsProxy <span class="cov8" title="1">{
        api := platformclientv2.NewIntegrationsApiWithConfig(clientConfig)
        return &amp;customAuthActionsProxy{
                clientConfig:                           clientConfig,
                integrationsApi:                        api,
                getAllIntegrationCustomAuthActionsAttr: getAllIntegrationCustomAuthActionsFn,
                getCustomAuthActionByIdAttr:            getCustomAuthActionByIdFn,
                updateCustomAuthActionAttr:             updateCustomAuthActionFn,
                getIntegrationActionTemplateAttr:       getIntegrationActionTemplateFn,
                getIntegrationTypeAttr:                 getIntegrationTypeFn,
                getIntegrationCredentialsTypeAttr:      getIntegrationCredentialsTypeFn,
                getIntegrationByIdAttr:                 getIntegrationByIdFn,
        }
}</span>

// getCustomAuthActionsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getCustomAuthActionsProxy(clientConfig *platformclientv2.Configuration) *customAuthActionsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newCustomAuthActionsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllIntegrationCustomAuthActions retrieves all Genesys Cloud Integration Custom Auth Actions
func (p *customAuthActionsProxy) getAllIntegrationCustomAuthActions(ctx context.Context) (*[]platformclientv2.Action, error) <span class="cov0" title="0">{
        return p.getAllIntegrationCustomAuthActionsAttr(ctx, p)
}</span>

// getCustomAuthActionById retrieve a Genesys Cloud Integration Custom Auth Action by ID
func (p *customAuthActionsProxy) getCustomAuthActionById(ctx context.Context, actionId string) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getCustomAuthActionByIdAttr(ctx, p, actionId)
}</span>

// updateCustomAuthAction updates a Genesys Cloud Integration Custom Auth Action
func (p *customAuthActionsProxy) updateCustomAuthAction(ctx context.Context, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.updateCustomAuthActionAttr(ctx, p, actionId, updateAction)
}</span>

// getIntegrationActionTemplate retrieves a Genesys Cloud Integration Action Template
func (p *customAuthActionsProxy) getIntegrationActionTemplate(ctx context.Context, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getIntegrationActionTemplateAttr(ctx, p, actionId, fileName)
}</span>

// getIntegrationType retrieves the type of a Genesys Cloud Integration
func (p *customAuthActionsProxy) getIntegrationType(ctx context.Context, integrationId string) (string, error) <span class="cov8" title="1">{
        return p.getIntegrationTypeAttr(ctx, p, integrationId)
}</span>

// getIntegrationCredentialsType retrieves the type of a Genesys Cloud Integration Credential
func (p *customAuthActionsProxy) getIntegrationCredentialsType(ctx context.Context, integrationId string) (string, error) <span class="cov8" title="1">{
        return p.getIntegrationCredentialsTypeAttr(ctx, p, integrationId)
}</span>

// getIntegrationById gets a Genesys Cloud Integration by id
func (p *customAuthActionsProxy) getIntegrationById(ctx context.Context, integrationName string) (*platformclientv2.Integration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getIntegrationByIdAttr(ctx, p, integrationName)
}</span>

// getAllIntegrationCustomAuthActionsFn is the implementation for getting all integration custom auth actions in Genesys Cloud
func getAllIntegrationCustomAuthActionsFn(ctx context.Context, p *customAuthActionsProxy) (*[]platformclientv2.Action, error) <span class="cov0" title="0">{
        actions := []platformclientv2.Action{}
        const pageSize = 100

        actionsList, _, err := p.integrationsApi.GetIntegrationsActions(pageSize, 1, "", "", "", "", "", "", "", "", "true")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, action := range *actionsList.Entities </span><span class="cov0" title="0">{
                if !strings.HasPrefix(*action.Id, customAuthIdPrefix) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">actions = append(actions, action)</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *actionsList.PageCount; pageNum++ </span><span class="cov0" title="0">{
                actionsList, _, err := p.integrationsApi.GetIntegrationsActions(pageSize, pageNum, "", "", "", "", "", "", "", "", "true")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if actionsList.Entities == nil || len(*actionsList.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, action := range *actionsList.Entities </span><span class="cov0" title="0">{
                        if !strings.HasPrefix(*action.Id, customAuthIdPrefix) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">actions = append(actions, action)</span>
                }
        }

        <span class="cov0" title="0">return &amp;actions, nil</span>
}

// getCustomAuthActionByIdFn is the implementation for getting an integration custom auth actions by id in Genesys Cloud
func getCustomAuthActionByIdFn(ctx context.Context, p *customAuthActionsProxy, actionId string) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        action, resp, err := p.integrationsApi.GetIntegrationsAction(actionId, "", true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return action, resp, nil</span>
}

// updateCustomAuthActionFn is the implementation for updating an integration custom auth action in Genesys Cloud
func updateCustomAuthActionFn(ctx context.Context, p *customAuthActionsProxy, actionId string, updateAction *platformclientv2.Updateactioninput) (*platformclientv2.Action, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        action, resp, err := p.integrationsApi.PatchIntegrationsAction(actionId, *updateAction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return action, resp, nil</span>
}

// getIntegrationActionTemplateFn is the implementation for getting the integration action template in Genesys Cloud
func getIntegrationActionTemplateFn(ctx context.Context, p *customAuthActionsProxy, actionId string, fileName string) (*string, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        template, resp, err := p.integrationsApi.GetIntegrationsActionTemplate(actionId, fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov8" title="1">return template, resp, nil</span>
}

// getIntegrationTypeFn is the implementation for getting the type of an integration in Genesys Cloud
func getIntegrationTypeFn(ctx context.Context, p *customAuthActionsProxy, integrationId string) (string, error) <span class="cov8" title="1">{
        integration, _, err := p.integrationsApi.GetIntegration(integrationId, 1, 1, "", nil, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *integration.IntegrationType.Id, nil</span>
}

// getIntegrationCredentialsTypeFn is the implementation for getting the type of an integration credential in Genesys Cloud
func getIntegrationCredentialsTypeFn(ctx context.Context, p *customAuthActionsProxy, integrationId string) (string, error) <span class="cov8" title="1">{
        integrationConfig, _, err := p.integrationsApi.GetIntegrationConfigCurrent(integrationId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if integrationConfig.Credentials == nil || len(*integrationConfig.Credentials) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no credentials set for integration %s", integrationId)
        }</span>

        <span class="cov8" title="1">basicAuth, found := (*integrationConfig.Credentials)["basicAuth"]
        if !found </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no 'basicAuth' credentials set for integration %s", integrationId)
        }</span>

        <span class="cov8" title="1">credential, _, err := p.integrationsApi.GetIntegrationsCredential(*basicAuth.Id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *credential.VarType.Name, nil</span>
}

// getIntegrationByIdFn is the implementation for getting a Genesys Cloud Integration by id
func getIntegrationByIdFn(ctx context.Context, p *customAuthActionsProxy, integrationId string) (*platformclientv2.Integration, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        const pageSize = 100
        const pageNum = 1
        integration, resp, err := p.integrationsApi.GetIntegration(integrationId, pageSize, pageNum, "", nil, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return integration, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package integration_custom_auth_action

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        integrationAction "terraform-provider-genesyscloud/genesyscloud/integration_action"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration_custom_auth_action.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesyscloud_integration_custom_auth_action)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

 1. All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

 2. In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a

utils function in the package.  This will keep the code manageable and easy to work through.
*/

// getAllModifiedCustomAuthActions retrieves only the custom auth actions that were modified at least
// once for use in the exporter (version &gt; 1). ie. Unmodified custom auth actions are not to be exported since the defaults
// are created and managed by Genesys itself based on the Integration configuration.
func getAllModifiedCustomAuthActions(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        cap := getCustomAuthActionsProxy(clientConfig)

        actions, err := cap.getAllIntegrationCustomAuthActions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("failed to get integration custom auth actions: %v", err)
        }</span>

        <span class="cov0" title="0">for _, action := range *actions </span><span class="cov0" title="0">{
                if *action.Version == 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">resources[*action.Id] = &amp;resourceExporter.ResourceMeta{Name: *action.Name}</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createIntegrationCustomAuthAction is used by the custom auth actions resource to manage the Genesyscloud integration custom auth action
func createIntegrationCustomAuthAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        cap := getCustomAuthActionsProxy(sdkConfig)

        integrationId := d.Get("integration_id").(string)
        authActionId := getCustomAuthIdFromIntegration(integrationId)

        name := resourcedata.GetNillableValue[string](d, "name")

        // Precheck that integration type and its credential type if it should have a custom auth data action
        if ok, err := isIntegrationAndCredTypesCorrect(ctx, cap, integrationId); !ok || err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("configuration of integration %s does not allow for a custom auth data action. %v", integrationId, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Retrieving the custom auth action of integration %s", integrationId)

        // Retrieve the automatically-generated custom auth action
        // to make sure it exists before updating
        diagErr := gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                authAction, resp, err := cap.getCustomAuthActionById(ctx, authActionId)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("cannot find custom auth action of integration %s: %v", integrationId, err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error getting custom auth action %s: %s", d.Id(), err))</span>
                }

                // Get default name if not to be overriden
                <span class="cov8" title="1">if name == nil </span><span class="cov8" title="1">{
                        name = authAction.Name
                }</span>

                <span class="cov8" title="1">d.SetId(*authAction.Id)

                return nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updating custom auth action of integration %s", integrationId)

        // Update the custom auth action with the actual configuration
        diagErr = gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get the latest action version to send with PATCH
                action, resp, err := cap.getCustomAuthActionById(ctx, authActionId)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read integration custom auth action %s: %s", authActionId, err)
                }</span>

                <span class="cov8" title="1">_, resp, err = cap.updateCustomAuthAction(ctx, authActionId, &amp;platformclientv2.Updateactioninput{
                        Name:    name,
                        Version: action.Version,
                        Config:  BuildSdkCustomAuthActionConfig(d),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update integration action %s: %s", *name, err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated custom auth action %s", *name)

        return readIntegrationCustomAuthAction(ctx, d, meta)</span>
}

// readIntegrationCustomAuthAction is used by the integration action resource to read a custom auth action from genesys cloud
func readIntegrationCustomAuthAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        cap := getCustomAuthActionsProxy(sdkConfig)

        log.Printf("Reading integration action %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                action, resp, err := cap.getCustomAuthActionById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read integration custom auth action %s: %s", d.Id(), err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read integration custom auth action %s: %s", d.Id(), err))</span>
                }

                // Retrieve config request/response templates
                <span class="cov8" title="1">reqTemp, resp, err := cap.getIntegrationActionTemplate(ctx, d.Id(), reqTemplateFileName)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                d.SetId("")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read request template for integration action %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">successTemp, resp, err := cap.getIntegrationActionTemplate(ctx, d.Id(), successTemplateFileName)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                d.SetId("")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read success template for integration action %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceIntegrationCustomAuthAction())

                resourcedata.SetNillableValue(d, "name", action.Name)
                resourcedata.SetNillableValue(d, "integration_id", action.IntegrationId)

                if action.Config != nil &amp;&amp; action.Config.Request != nil </span><span class="cov8" title="1">{
                        action.Config.Request.RequestTemplate = reqTemp
                        d.Set("config_request", integrationAction.FlattenActionConfigRequest(*action.Config.Request))
                }</span> else<span class="cov0" title="0"> {
                        d.Set("config_request", nil)
                }</span>

                <span class="cov8" title="1">if action.Config != nil &amp;&amp; action.Config.Response != nil </span><span class="cov8" title="1">{
                        action.Config.Response.SuccessTemplate = successTemp
                        d.Set("config_response", integrationAction.FlattenActionConfigResponse(*action.Config.Response))
                }</span> else<span class="cov0" title="0"> {
                        d.Set("config_response", nil)
                }</span>

                <span class="cov8" title="1">log.Printf("Read integration action %s %s", d.Id(), *action.Name)
                return cc.CheckState()</span>
        })
}

// updateIntegrationCustomAuthAction is used by the integration action resource to update a custom auth in Genesys Cloud
func updateIntegrationCustomAuthAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        cap := getCustomAuthActionsProxy(sdkConfig)

        name := resourcedata.GetNillableValue[string](d, "name")

        log.Printf("Updating integration custom auth action %s", *name)

        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get the latest action version to send with PATCH
                action, resp, err := cap.getCustomAuthActionById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read integration custom auth action %s: %s", d.Id(), err)
                }</span>
                <span class="cov8" title="1">if name == nil </span><span class="cov0" title="0">{
                        name = action.Name
                }</span>

                <span class="cov8" title="1">_, resp, err = cap.updateCustomAuthAction(ctx, d.Id(), &amp;platformclientv2.Updateactioninput{
                        Name:    name,
                        Version: action.Version,
                        Config:  BuildSdkCustomAuthActionConfig(d),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update integration action %s: %s", *name, err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated custom auth action %s", *name)

        return readIntegrationCustomAuthAction(ctx, d, meta)</span>
}

// deleteIntegrationCustomAuthAction does not do anything as deleting a custom auth action is not possible
func deleteIntegrationCustomAuthAction(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)

        log.Printf("Removing terraform resource integration_custom_auth_action %s will not remove the Data Action itself in the org", name)
        log.Printf("The Custom Auth Data Action cannot be removed unless the Web Services Data Action Integration itself is deleted or if the Credentials type is changed from 'User Defined (OAuth)' to a different type")

        return nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package integration_custom_auth_action

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

/*
resource_genesyscloud_integration_custom_auth_action_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the integration_custom_auth_action resource.
3.  The datasource schema definitions for the integration_custom_auth_action datasource.
4.  The resource exporter configuration for the integration_custom_auth_action exporter.
*/
const resourceName = "genesyscloud_integration_custom_auth_action"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceIntegrationCustomAuthAction())
        l.RegisterResource(resourceName, ResourceIntegrationCustomAuthAction())
        l.RegisterExporter(resourceName, IntegrationCustomAuthActionExporter())
}</span>

// ResourceIntegrationCustomAuthAction registers the genesyscloud_integration_custom_auth_action resource with Terraform
func ResourceIntegrationCustomAuthAction() *schema.Resource <span class="cov8" title="1">{
        actionConfigRequest := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "request_url_template": {
                                Description: "URL that may include placeholders for requests to 3rd party service.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "request_type": {
                                Description:  "HTTP method to use for request (GET | PUT | POST | PATCH | DELETE).",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"GET", "PUT", "POST", "PATCH", "DELETE"}, false),
                        },
                        "request_template": {
                                Description: "Velocity template to define request body sent to 3rd party service. Any instances of '${' must be properly escaped as '$${'",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                        "headers": {
                                Description: "Map of headers in name, value pairs to include in request.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }

        actionConfigResponse := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "translation_map": {
                                Description: "Map 'attribute name' and 'JSON path' pairs used to extract data from REST response.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "translation_map_defaults": {
                                Description: "Map 'attribute name' and 'default value' pairs used as fallback values if JSON path extraction fails for specified key.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "success_template": {
                                Description: "Velocity template to build response to return from Action. Any instances of '${' must be properly escaped as '$${'.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud Integration Actions. See this page for detailed information on configuring Actions: https://help.mypurecloud.com/articles/add-configuration-custom-actions-integrations/",

                CreateContext: gcloud.CreateWithPooledClient(createIntegrationCustomAuthAction),
                ReadContext:   gcloud.ReadWithPooledClient(readIntegrationCustomAuthAction),
                UpdateContext: gcloud.UpdateWithPooledClient(updateIntegrationCustomAuthAction),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteIntegrationCustomAuthAction),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "integration_id": {
                                Description: "The ID of the integration this action is associated with. The integration is required to be of type `custom-rest-actions` and its credentials type set as `userDefinedOAuth`.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "name": {
                                Description:  "Name of the action to override the default name. Can be up to 256 characters long",
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ValidateFunc: validation.StringLenBetween(1, 256),
                        },
                        "config_request": {
                                Description: "Configuration of outbound request.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Elem:        actionConfigRequest,
                        },
                        "config_response": {
                                Description: "Configuration of response processing.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Computed:    true,
                                MaxItems:    1,
                                Elem:        actionConfigResponse,
                        },
                },
        }
}</span>

// IntegrationCustomAuthActionExporter returns the resourceExporter object used to hold the genesyscloud_integration_custom_auth_action exporter's config
func IntegrationCustomAuthActionExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllModifiedCustomAuthActions),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "integration_id": {RefType: "genesyscloud_integration"},
                },
        }
}</span>

// DataSourceIntegrationCustomAuthAction registers the genesyscloud_integration_custom_auth_action data source
func DataSourceIntegrationCustomAuthAction() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud integration custom auth action. Select the custom auth action by its associated integration's id.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceIntegrationCustomAuthActionRead),
                Schema: map[string]*schema.Schema{
                        "parent_integration_id": {
                                Description: "The id of the integration associated with the custom auth action",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package integration_custom_auth_action

import (
        "context"
        "fmt"
        integrationAction "terraform-provider-genesyscloud/genesyscloud/integration_action"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_integration_action_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

const (
        customAuthIdPrefix        = "customAuth" // Custom Auth Data Action IDs start with this
        customAuthCredentialType  = "userDefinedOAuth"
        customRestIntegrationType = "custom-rest-actions"

        reqTemplateFileName     = "requesttemplate.vm"
        successTemplateFileName = "successtemplate.vm"
)

// BuildSdkCustomAuthActionConfig takes the resource data and builds the SDK platformclientv2.Actionconfig from it
// This is a stripped version of the integrationAction.BuildSdkActionConfig because 'timeoutSeconds'
// is invalid for Custom Auth Actions
func BuildSdkCustomAuthActionConfig(d *schema.ResourceData) *platformclientv2.Actionconfig <span class="cov8" title="1">{
        ActionConfig := &amp;platformclientv2.Actionconfig{
                Request:  integrationAction.BuildSdkActionConfigRequest(d),
                Response: integrationAction.BuildSdkActionConfigResponse(d),
        }

        return ActionConfig
}</span>

// isIntegrationAndCredTypesCorrect checks if the integration is of type Web Services Data Action ("custom-rest-actions")
// and checks that the credential is configured as "userDefinedOAuth" which are the requirements
// for a Custom Auth Data Action(Genesys Cloud managed) to exist for the integration.
func isIntegrationAndCredTypesCorrect(ctx context.Context, cap *customAuthActionsProxy, integrationId string) (bool, error) <span class="cov8" title="1">{
        // Check that the integration is the correct type
        integType, err := cap.getIntegrationType(ctx, integrationId)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot identify integration type of integration %s: %v", integrationId, err)
        }</span>
        <span class="cov8" title="1">if integType != customRestIntegrationType </span><span class="cov0" title="0">{
                return false, fmt.Errorf("integration should be of type %v to use custom auth action. Actual: %v", customRestIntegrationType, integType)
        }</span>

        // Check credentials
        <span class="cov8" title="1">credType, err := cap.getIntegrationCredentialsType(ctx, integrationId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if credType != customAuthCredentialType </span><span class="cov0" title="0">{
                return false, fmt.Errorf("credentials type of integration %s should be %s", integrationId, customAuthCredentialType)
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// getCustomAuthIdFromIntegration gets the expected custom auth action ID from the integration ID.
func getCustomAuthIdFromIntegration(integrationId string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_-_%s", customAuthIdPrefix, integrationId)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundCallabletimeset() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Clound Outbound Callable Timesets. Select a callable timeset by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundCallabletimesetRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Callable timeset name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundCallabletimesetRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        timesetName := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                for pageNum := 1; ; pageNum++ </span><span class="cov8" title="1">{
                        const pageSize = 100

                        timesets, _, getErr := outboundAPI.GetOutboundCallabletimesets(pageSize, pageNum, true, "", "", "", "")
                        if getErr != nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("error requesting callable timeset %s: %s", timesetName, getErr))
                        }</span>
                        <span class="cov8" title="1">if timesets.Entities == nil || len(*timesets.Entities) == 0 </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("no callable timeset found with timesetName %s", timesetName))
                        }</span>

                        <span class="cov8" title="1">for _, timeset := range *timesets.Entities </span><span class="cov8" title="1">{
                                if timeset.Name != nil &amp;&amp; *timeset.Name == timesetName </span><span class="cov8" title="1">{
                                        d.SetId(*timeset.Id)
                                        return nil
                                }</span>
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundCallAnalysisResponseSet() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundCallAnalysisReponseSetRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Data source for Genesys Cloud Outbound Call Analysis Response Sets. Select a response set by name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundCallAnalysisReponseSetRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                responseSets, _, getErr := outboundAPI.GetOutboundCallanalysisresponsesets(pageSize, pageNum, true, "", name, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting call analysis response set %s: %s", name, getErr))
                }</span>
                <span class="cov8" title="1">if responseSets.Entities == nil || len(*responseSets.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no call analysis response sets found with name %s", name))
                }</span>
                <span class="cov8" title="1">responseSet := (*responseSets.Entities)[0]
                d.SetId(*responseSet.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func DataSourceOutboundAttemptLimit() *schema.Resource <span class="cov0" title="0">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Outbound Attempt Limits. Select an attempt limit by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundAttemptLimitRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Attempt Limit name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundAttemptLimitRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                const pageNum = 1
                const pageSize = 100
                attemptLimits, _, getErr := outboundAPI.GetOutboundAttemptlimits(pageSize, pageNum, true, "", name, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting attempt limit %s: %s", name, getErr))
                }</span>
                <span class="cov0" title="0">if attemptLimits.Entities == nil || len(*attemptLimits.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no attempt limits found with name %s", name))
                }</span>
                <span class="cov0" title="0">attemptLimit := (*attemptLimits.Entities)[0]
                d.SetId(*attemptLimit.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundContactListFilter() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Outbound Contact List Filters. Select a contact list filter by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundContactListFilterRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Contact List Filter name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundContactListFilterRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                contactListFilters, _, getErr := outboundAPI.GetOutboundContactlistfilters(pageSize, pageNum, true, "", name, "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting contact list filter %s: %s", name, getErr))
                }</span>
                <span class="cov8" title="1">if contactListFilters.Entities == nil || len(*contactListFilters.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no contact list filters found with name %s", name))
                }</span>
                <span class="cov8" title="1">contactListFilter := (*contactListFilters.Entities)[0]
                d.SetId(*contactListFilter.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundDncList() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Outbound DNC Lists. Select a DNC list by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundDncListRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "DNC List name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundDncListRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                dncLists, _, getErr := outboundAPI.GetOutboundDnclists(false, false, pageSize, pageNum, true, "", name, "", []string{}, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting dnc lists %s: %s", name, getErr))
                }</span>
                <span class="cov8" title="1">if dncLists.Entities == nil || len(*dncLists.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no dnc lists found with name %s", name))
                }</span>
                <span class="cov8" title="1">dncList := (*dncLists.Entities)[0]
                d.SetId(*dncList.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package outbound

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundMessagingcampaign() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Data source for Genesys Cloud Outbound Messaging Campaign. Select a Outbound Messaging Campaign by name.`,

                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundMessagingcampaignRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `Outbound Messaging Campaign name.`,
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundMessagingcampaignRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                        const pageSize = 100
                        sdkMessagingcampaignEntityListing, _, getErr := outboundApi.GetOutboundMessagingcampaigns(pageSize, pageNum, "", "", "", "", []string{}, "", "", []string{})
                        if getErr != nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("error requesting Outbound Messaging Campaign %s: %s", name, getErr))
                        }</span>

                        <span class="cov0" title="0">if sdkMessagingcampaignEntityListing.Entities == nil || len(*sdkMessagingcampaignEntityListing.Entities) == 0 </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("no Outbound Messaging Campaign found with name %s", name))
                        }</span>

                        <span class="cov0" title="0">for _, entity := range *sdkMessagingcampaignEntityListing.Entities </span><span class="cov0" title="0">{
                                if entity.Name != nil &amp;&amp; *entity.Name == name </span><span class="cov0" title="0">{
                                        d.SetId(*entity.Id)
                                        return nil
                                }</span>
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundcallabletimesetcallabletimeResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `time_slots`: {
                                Description: `The time intervals for which it is acceptable to place outbound calls.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundcallabletimesetcampaigntimeslotResource,
                        },
                        `time_zone_id`: {
                                Description: `The time zone for the time slots; for example, Africa/Abidjan`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
        outboundcallabletimesetcampaigntimeslotResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `start_time`: {
                                Description:      `The start time of the interval as an ISO-8601 string, i.e. HH:mm:ss`,
                                Required:         true,
                                ValidateDiagFunc: gcloud.ValidateTime,
                                Type:             schema.TypeString,
                        },
                        `stop_time`: {
                                Description:      `The end time of the interval as an ISO-8601 string, i.e. HH:mm:ss`,
                                Required:         true,
                                ValidateDiagFunc: gcloud.ValidateTime,
                                Type:             schema.TypeString,
                        },
                        `day`: {
                                Description:  `The day of the interval. Valid values: [1-7], representing Monday through Sunday`,
                                Required:     true,
                                ValidateFunc: validation.IntInSlice([]int{1, 2, 3, 4, 5, 6, 7}),
                                Type:         schema.TypeInt,
                        },
                },
        }
)

func ResourceOutboundCallabletimeset() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound callabletimeset`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundCallabletimeset),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundCallabletimeset),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundCallabletimeset),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundCallabletimeset),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the CallableTimeSet.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `callable_times`: {
                                Description: `The list of CallableTimes for which it is acceptable to place outbound calls.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundcallabletimesetcallabletimeResource,
                        },
                },
        }
}</span>

func OutboundCallableTimesetExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundCallableTimesets),
        }
}</span>

func getAllOutboundCallableTimesets(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                callableTimesetConfigs, _, getErr := outboundAPI.GetOutboundCallabletimesets(pageSize, pageNum, true, "", "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of callable timeset configs: %v", getErr)
                }</span>

                <span class="cov0" title="0">if callableTimesetConfigs.Entities == nil || len(*callableTimesetConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, callableTimesetConfig := range *callableTimesetConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*callableTimesetConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *callableTimesetConfig.Name}
                }</span>

        }
        <span class="cov0" title="0">return resources, nil</span>
}

func createOutboundCallabletimeset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkcallabletimeset := platformclientv2.Callabletimeset{
                CallableTimes: buildSdkoutboundcallabletimesetCallabletimeSlice(d.Get("callable_times").(*schema.Set)),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkcallabletimeset.Name = &amp;name
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Callabletimeset %s", name)
        outboundCallabletimeset, _, err := outboundApi.PostOutboundCallabletimesets(sdkcallabletimeset)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Callabletimeset %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundCallabletimeset.Id)

        log.Printf("Created Outbound Callabletimeset %s %s", name, *outboundCallabletimeset.Id)
        return readOutboundCallabletimeset(ctx, d, meta)</span>
}

func updateOutboundCallabletimeset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkcallabletimeset := platformclientv2.Callabletimeset{
                CallableTimes: buildSdkoutboundcallabletimesetCallabletimeSlice(d.Get("callable_times").(*schema.Set)),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkcallabletimeset.Name = &amp;name
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Callabletimeset %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Callabletimeset version
                outboundCallabletimeset, resp, getErr := outboundApi.GetOutboundCallabletimeset(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Callabletimeset %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkcallabletimeset.Version = outboundCallabletimeset.Version
                outboundCallabletimeset, _, updateErr := outboundApi.PutOutboundCallabletimeset(d.Id(), sdkcallabletimeset)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Callabletimeset %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Callabletimeset %s", name)
        return readOutboundCallabletimeset(ctx, d, meta)</span>
}

func readOutboundCallabletimeset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Callabletimeset %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkcallabletimeset, resp, getErr := outboundApi.GetOutboundCallabletimeset(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Callabletimeset %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Callabletimeset %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundCallabletimeset())

                if sdkcallabletimeset.Name != nil </span><span class="cov8" title="1">{
                        d.Set("name", *sdkcallabletimeset.Name)
                }</span>
                <span class="cov8" title="1">if sdkcallabletimeset.CallableTimes != nil </span><span class="cov8" title="1">{
                        // Remove the milliseconds added to start_time and stop_time by the API
                        trimTime(sdkcallabletimeset.CallableTimes)
                        d.Set("callable_times", flattenSdkoutboundcallabletimesetCallabletimeSlice(*sdkcallabletimeset.CallableTimes))
                }</span>

                <span class="cov8" title="1">log.Printf("Read Outbound Callabletimeset %s %s", d.Id(), *sdkcallabletimeset.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundCallabletimeset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Callabletimeset")
                resp, err := outboundApi.DeleteOutboundCallabletimeset(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Callabletimeset: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundCallabletimeset(d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Callabletimeset deleted
                                log.Printf("Deleted Outbound Callabletimeset %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting Outbound Callabletimeset %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Callabletimeset %s still exists", d.Id()))</span>
        })
}

func trimTime(values *[]platformclientv2.Callabletime) <span class="cov8" title="1">{
        for _, value := range *values </span><span class="cov8" title="1">{
                for _, slot := range *value.TimeSlots </span><span class="cov8" title="1">{
                        startTime := *slot.StartTime
                        *slot.StartTime = startTime[:8]

                        stopTime := *slot.StopTime
                        *slot.StopTime = stopTime[:8]
                }</span>
        }
}

func buildSdkoutboundcallabletimesetCampaigntimeslotSlice(campaigntimeslot *schema.Set) *[]platformclientv2.Campaigntimeslot <span class="cov8" title="1">{
        if campaigntimeslot == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkCampaigntimeslotSlice := make([]platformclientv2.Campaigntimeslot, 0)
        campaigntimeslotList := campaigntimeslot.List()
        for _, configcampaigntimeslot := range campaigntimeslotList </span><span class="cov8" title="1">{
                var sdkCampaigntimeslot platformclientv2.Campaigntimeslot

                campaigntimeslotMap := configcampaigntimeslot.(map[string]interface{})
                if startTime := campaigntimeslotMap["start_time"].(string); startTime != "" </span><span class="cov8" title="1">{
                        sdkCampaigntimeslot.StartTime = &amp;startTime
                }</span>
                <span class="cov8" title="1">if stopTime := campaigntimeslotMap["stop_time"].(string); stopTime != "" </span><span class="cov8" title="1">{
                        sdkCampaigntimeslot.StopTime = &amp;stopTime
                }</span>
                <span class="cov8" title="1">sdkCampaigntimeslot.Day = platformclientv2.Int(campaigntimeslotMap["day"].(int))

                sdkCampaigntimeslotSlice = append(sdkCampaigntimeslotSlice, sdkCampaigntimeslot)</span>
        }
        <span class="cov8" title="1">return &amp;sdkCampaigntimeslotSlice</span>
}

func buildSdkoutboundcallabletimesetCallabletimeSlice(callabletime *schema.Set) *[]platformclientv2.Callabletime <span class="cov8" title="1">{
        if callabletime == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkCallabletimeSlice := make([]platformclientv2.Callabletime, 0)
        callabletimeList := callabletime.List()
        for _, configcallabletime := range callabletimeList </span><span class="cov8" title="1">{
                var sdkCallabletime platformclientv2.Callabletime
                callabletimeMap := configcallabletime.(map[string]interface{})
                if timeSlots := callabletimeMap["time_slots"]; timeSlots != nil </span><span class="cov8" title="1">{
                        sdkCallabletime.TimeSlots = buildSdkoutboundcallabletimesetCampaigntimeslotSlice(timeSlots.(*schema.Set))
                }</span>
                <span class="cov8" title="1">if timeZoneId := callabletimeMap["time_zone_id"].(string); timeZoneId != "" </span><span class="cov8" title="1">{
                        sdkCallabletime.TimeZoneId = &amp;timeZoneId
                }</span>

                <span class="cov8" title="1">sdkCallabletimeSlice = append(sdkCallabletimeSlice, sdkCallabletime)</span>
        }
        <span class="cov8" title="1">return &amp;sdkCallabletimeSlice</span>
}

func flattenSdkoutboundcallabletimesetCampaigntimeslotSlice(campaigntimeslots []platformclientv2.Campaigntimeslot) *schema.Set <span class="cov8" title="1">{
        if len(campaigntimeslots) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">campaigntimeslotSet := schema.NewSet(schema.HashResource(outboundcallabletimesetcampaigntimeslotResource), []interface{}{})
        for _, campaigntimeslot := range campaigntimeslots </span><span class="cov8" title="1">{
                campaigntimeslotMap := make(map[string]interface{})

                if campaigntimeslot.StartTime != nil </span><span class="cov8" title="1">{
                        campaigntimeslotMap["start_time"] = *campaigntimeslot.StartTime
                }</span>
                <span class="cov8" title="1">if campaigntimeslot.StopTime != nil </span><span class="cov8" title="1">{
                        campaigntimeslotMap["stop_time"] = *campaigntimeslot.StopTime
                }</span>
                <span class="cov8" title="1">if campaigntimeslot.Day != nil </span><span class="cov8" title="1">{
                        campaigntimeslotMap["day"] = *campaigntimeslot.Day
                }</span>

                <span class="cov8" title="1">campaigntimeslotSet.Add(campaigntimeslotMap)</span>
        }

        <span class="cov8" title="1">return campaigntimeslotSet</span>
}

func flattenSdkoutboundcallabletimesetCallabletimeSlice(callabletimes []platformclientv2.Callabletime) *schema.Set <span class="cov8" title="1">{
        if len(callabletimes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">callabletimeSet := schema.NewSet(schema.HashResource(outboundcallabletimesetcallabletimeResource), []interface{}{})
        for _, callabletime := range callabletimes </span><span class="cov8" title="1">{
                callabletimeMap := make(map[string]interface{})

                if callabletime.TimeSlots != nil </span><span class="cov8" title="1">{
                        callabletimeMap["time_slots"] = flattenSdkoutboundcallabletimesetCampaigntimeslotSlice(*callabletime.TimeSlots)
                }</span>
                <span class="cov8" title="1">if callabletime.TimeZoneId != nil </span><span class="cov8" title="1">{
                        callabletimeMap["time_zone_id"] = *callabletime.TimeZoneId
                }</span>

                <span class="cov8" title="1">callabletimeSet.Add(callabletimeMap)</span>
        }

        <span class="cov8" title="1">return callabletimeSet</span>
}

func GenerateOutboundCallabletimeset(
        resourceId string,
        name string,
        nestedBlocks ...string) string <span class="cov8" title="1">{

        return fmt.Sprintf(`
                resource "genesyscloud_outbound_callabletimeset" "%s"{
                        name = "%s"
                        %s
                }
                `, resourceId, name, strings.Join(nestedBlocks, "\n"),
        )
}</span>

func GenerateCallableTimesBlock(
        timeZoneID string,
        attrs ...string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
                callable_times {
                        time_zone_id = "%s"
                        %s
                }
        `, timeZoneID, strings.Join(attrs, "\n"))
}</span>

func GenerateTimeSlotsBlock(
        startTime string,
        stopTime string,
        day string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
                time_slots {
                        start_time = "%s"
                        stop_time = "%s"
                        day = %s
                }
        `, startTime, stopTime, day)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundCallAnalysisResponseSetReaction = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `data`: {
                                Description: `Parameter for this reaction. For transfer_flow, this would be the outbound flow id.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `name`: {
                                Description: `Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `reaction_type`: {
                                Description:  `The reaction to take for a given call analysis result.`,
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{`hangup`, `transfer`, `transfer_flow`, `play_file`}, false),
                        },
                },
        }

        outboundCallAnalysisResponseSetResponses = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `callable_lineconnected`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_person`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_busy`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_noanswer`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_fax`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_disconnect`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_machine`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `callable_sit`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `uncallable_sit`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                        `uncallable_notfound`: {
                                Computed: true,
                                Type:     schema.TypeSet,
                                MaxItems: 1,
                                Optional: true,
                                Elem:     outboundCallAnalysisResponseSetReaction,
                        },
                },
        }
)

func getAllCallAnalysisResponseSets(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                responseSetConfigs, _, getErr := outboundAPI.GetOutboundCallanalysisresponsesets(pageSize, pageNum, true, "", "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of call analysis response set configs: %v", getErr)
                }</span>
                <span class="cov0" title="0">if responseSetConfigs.Entities == nil || len(*responseSetConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for _, responseSetConfig := range *responseSetConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*responseSetConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *responseSetConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundCallAnalysisResponseSetExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllCallAnalysisResponseSets),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "responses.callable_person.data":  {RefType: "genesyscloud_flow"},
                        "responses.callable_machine.data": {RefType: "genesyscloud_flow"},
                },
        }
}</span>

func ResourceOutboundCallAnalysisResponseSet() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound Call Analysis Response Set`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundCallAnalysisResponseSet),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundCallAnalysisResponseSet),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundCallAnalysisResponseSet),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundCallAnalysisResponseSet),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the Response Set.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `responses`: {
                                Description: `List of maps of disposition identifiers to reactions. Required if beep_detection_enabled = true.`,
                                Optional:    true,
                                MaxItems:    1,
                                Type:        schema.TypeList,
                                Elem:        outboundCallAnalysisResponseSetResponses,
                        },
                        `beep_detection_enabled`: {
                                Description: `Whether to enable answering machine beep detection`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                },
        }
}</span>

func createOutboundCallAnalysisResponseSet(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        responses := d.Get("responses").([]interface{})
        beepDetectionEnabled := d.Get("beep_detection_enabled").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkResponseSet := platformclientv2.Responseset{
                BeepDetectionEnabled: &amp;beepDetectionEnabled,
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkResponseSet.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if responses != nil &amp;&amp; len(responses) &gt; 0 </span><span class="cov8" title="1">{
                sdkResponseSet.Responses = buildSdkOutboundCallAnalysisResponseSetReaction(responses)
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Call Analysis Response Set %s", name)
        outboundCallanalysisresponseset, _, err := outboundApi.PostOutboundCallanalysisresponsesets(sdkResponseSet)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Call Analysis Response Set %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundCallanalysisresponseset.Id)

        log.Printf("Created Outbound Call Analysis Response Set %s %s", name, *outboundCallanalysisresponseset.Id)
        return readOutboundCallAnalysisResponseSet(ctx, d, meta)</span>
}

func updateOutboundCallAnalysisResponseSet(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        responses := d.Get("responses").([]interface{})
        beepDetectionEnabled := d.Get("beep_detection_enabled").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkResponseSet := platformclientv2.Responseset{
                BeepDetectionEnabled: &amp;beepDetectionEnabled,
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkResponseSet.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if responses != nil &amp;&amp; len(responses) &gt; 0 </span><span class="cov8" title="1">{
                sdkResponseSet.Responses = buildSdkOutboundCallAnalysisResponseSetReaction(responses)
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Call Analysis Response Set %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Callanalysisresponseset version
                outboundCallanalysisresponseset, resp, getErr := outboundApi.GetOutboundCallanalysisresponseset(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Call Analysis Response Set %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkResponseSet.Version = outboundCallanalysisresponseset.Version
                outboundCallanalysisresponseset, _, updateErr := outboundApi.PutOutboundCallanalysisresponseset(d.Id(), sdkResponseSet)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Call Analysis Response Set %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Call Analysis Response Set %s", name)
        return readOutboundCallAnalysisResponseSet(ctx, d, meta)</span>
}

func readOutboundCallAnalysisResponseSet(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Call Analysis Response Set %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkResponseSet, resp, getErr := outboundApi.GetOutboundCallanalysisresponseset(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound Call Analysis Response Set %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound Call Analysis Response Set %s: %s", d.Id(), getErr))</span>
                }
                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundCallAnalysisResponseSet())
                if sdkResponseSet.Name != nil </span><span class="cov8" title="1">{
                        _ = d.Set("name", *sdkResponseSet.Name)
                }</span>
                <span class="cov8" title="1">if sdkResponseSet.Responses != nil &amp;&amp; len(*sdkResponseSet.Responses) &gt; 0 </span><span class="cov8" title="1">{
                        _ = d.Set("responses", flattenSdkOutboundCallAnalysisResponseSetReaction(sdkResponseSet.Responses))
                }</span>
                <span class="cov8" title="1">if sdkResponseSet.BeepDetectionEnabled != nil </span><span class="cov8" title="1">{
                        _ = d.Set("beep_detection_enabled", *sdkResponseSet.BeepDetectionEnabled)
                }</span>
                <span class="cov8" title="1">log.Printf("Read Outbound Call Analysis Response Set %s %s", d.Id(), *sdkResponseSet.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundCallAnalysisResponseSet(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Call Analysis Response Set")
                resp, err := outboundApi.DeleteOutboundCallanalysisresponseset(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Call Analysis Response Set: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundCallanalysisresponseset(d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Call Analysis Response Set deleted
                                log.Printf("Deleted Outbound Call Analysis Response Set %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound Call Analysis Response Set %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Call Analysis Response Set %s still exists", d.Id()))</span>
        })
}

func buildSdkOutboundCallAnalysisResponseSetReaction(responses []interface{}) *map[string]platformclientv2.Reaction <span class="cov8" title="1">{
        if len(responses) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkResponses := map[string]platformclientv2.Reaction{}
        if responsesMap, ok := responses[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                types := []string{
                        "callable_lineconnected",
                        "callable_person",
                        "callable_busy",
                        "callable_noanswer",
                        "callable_fax",
                        "callable_disconnect",
                        "callable_machine",
                        "callable_sit",
                        "uncallable_sit",
                        "uncallable_notfound",
                }
                for _, t := range types </span><span class="cov8" title="1">{
                        reactionSet := responsesMap[t].(*schema.Set).List()
                        if len(reactionSet) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if reactionMap, ok := reactionSet[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                sdkKey := "disposition.classification." + strings.ReplaceAll(t, "_", ".")
                                sdkResponses[sdkKey] = *buildSdkReaction(reactionMap)
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;sdkResponses</span>
}

func buildSdkReaction(reactionMap map[string]interface{}) *platformclientv2.Reaction <span class="cov8" title="1">{
        var sdkReaction platformclientv2.Reaction
        if reactionName, ok := reactionMap["name"].(string); ok </span><span class="cov8" title="1">{
                sdkReaction.Name = &amp;reactionName
        }</span>
        <span class="cov8" title="1">if reactionData, ok := reactionMap["data"].(string); ok </span><span class="cov8" title="1">{
                sdkReaction.Data = &amp;reactionData
        }</span>
        <span class="cov8" title="1">if reactionType, ok := reactionMap["reaction_type"].(string); ok </span><span class="cov8" title="1">{
                sdkReaction.ReactionType = &amp;reactionType
        }</span>
        <span class="cov8" title="1">return &amp;sdkReaction</span>
}

func flattenSdkOutboundCallAnalysisResponseSetReaction(responses *map[string]platformclientv2.Reaction) []interface{} <span class="cov8" title="1">{
        if responses == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">responsesMap := make(map[string]interface{})
        for key, val := range *responses </span><span class="cov8" title="1">{
                schemaKey := strings.Replace(key, "disposition.classification.", "", -1)
                schemaKey = strings.Replace(schemaKey, ".", "_", -1)
                responsesMap[schemaKey] = flattenSdkReaction(val)
        }</span>
        <span class="cov8" title="1">return []interface{}{responsesMap}</span>
}

func flattenSdkReaction(sdkReaction platformclientv2.Reaction) *schema.Set <span class="cov8" title="1">{
        var (
                reactionMap = make(map[string]interface{})
                reactionSet = schema.NewSet(schema.HashResource(outboundCallAnalysisResponseSetReaction), []interface{}{})
        )
        if sdkReaction.Name != nil </span><span class="cov8" title="1">{
                reactionMap["name"] = *sdkReaction.Name
        }</span>
        <span class="cov8" title="1">if sdkReaction.Data != nil </span><span class="cov8" title="1">{
                reactionMap["data"] = *sdkReaction.Data
        }</span>
        <span class="cov8" title="1">reactionMap["reaction_type"] = *sdkReaction.ReactionType
        reactionSet.Add(reactionMap)
        return reactionSet</span>
}

func GenerateOutboundCallAnalysisResponseSetResource(resourceId string, name string, beepDetectionEnabled string, responsesBlock string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
resource "genesyscloud_outbound_callanalysisresponseset" "%s" {
        name                   = "%s"
        beep_detection_enabled = %s
        %s
}
`, resourceId, name, beepDetectionEnabled, responsesBlock)
}</span>

func GenerateCarsResponsesBlock(nestedBlocks ...string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
        responses {
                %s
        }
`, strings.Join(nestedBlocks, "\n"))
}</span>

func GenerateCarsResponse(identifier string, reactionType string, name string, data string) string <span class="cov8" title="1">{
        if name != "" </span><span class="cov8" title="1">{
                name = fmt.Sprintf(`name = "%s"`, name)
        }</span>
        <span class="cov8" title="1">if data != "" </span><span class="cov8" title="1">{
                data = fmt.Sprintf(`data = "%s"`, data)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
                %s {
                        reaction_type = "%s"
                        %s
                        %s
                }
`, identifier, reactionType, name, data)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundContactListFilterClauseResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `filter_type`: {
                                Description:  `How to join predicates together.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`AND`, `OR`}, false),
                        },
                        `predicates`: {
                                Description: `Conditions to filter the contacts by.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundContactListFilterPredicateResource,
                        },
                },
        }
        outboundContactListFilterPredicateResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `column`: {
                                Description: `Contact list column from the contact list filter's contact list.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `column_type`: {
                                Description:  `The type of data in the contact column.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`numeric`, `alphabetic`}, false),
                        },
                        `operator`: {
                                Description:  `The operator for this contact list filter predicate.`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`EQUALS`, `LESS_THAN`, `LESS_THAN_EQUALS`, `GREATER_THAN`, `GREATER_THAN_EQUALS`, `CONTAINS`, `BEGINS_WITH`, `ENDS_WITH`, `BEFORE`, `AFTER`, `BETWEEN`, `IN`}, false),
                        },
                        `value`: {
                                Description: `Value with which to compare the contact's data. This could be text, a number, or a relative time. A value for relative time should follow the format PxxDTyyHzzM, where xx, yy, and zz specify the days, hours and minutes. For example, a value of P01DT08H30M corresponds to 1 day, 8 hours, and 30 minutes from now. To specify a time in the past, include a negative sign before each numeric value. For example, a value of P-01DT-08H-30M corresponds to 1 day, 8 hours, and 30 minutes in the past. You can also do things like P01DT00H-30M, which would correspond to 23 hours and 30 minutes from now (1 day - 30 minutes).`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `var_range`: {
                                Description: `A range of values. Required for operators BETWEEN and IN.`,
                                Optional:    true,
                                MaxItems:    1,
                                Type:        schema.TypeSet,
                                Elem:        outboundContactListFilterRangeResource,
                        },
                        `inverted`: {
                                Description: `Inverts the result of the predicate (i.e., if the predicate returns true, inverting it will return false).`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeBool,
                        },
                },
        }
        outboundContactListFilterRangeResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `min`: {
                                Description: `The minimum value of the range. Required for the operator BETWEEN.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `max`: {
                                Description: `The maximum value of the range. Required for the operator BETWEEN.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `min_inclusive`: {
                                Description: `Whether or not to include the minimum in the range.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `max_inclusive`: {
                                Description: `Whether or not to include the maximum in the range.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `in_set`: {
                                Description: `A set of values that the contact data should be in. Required for the IN operator.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }
)

func getAllOutboundContactListFilters(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                contactListFilterConfigs, _, getErr := outboundAPI.GetOutboundContactlistfilters(pageSize, pageNum, true, "", "", "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of contact list filter configs: %v", getErr)
                }</span>

                <span class="cov0" title="0">if contactListFilterConfigs.Entities == nil || len(*contactListFilterConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, contactListFilterConfig := range *contactListFilterConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*contactListFilterConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *contactListFilterConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundContactListFilterExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundContactListFilters),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "contact_list_id": {RefType: "genesyscloud_outbound_contact_list"},
                },
        }
}</span>

func ResourceOutboundContactListFilter() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Outbound Contact List Filter`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundContactListFilter),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundContactListFilter),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundContactListFilter),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundContactListFilter),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the list.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_list_id`: {
                                Description: `The contact list the filter is based on.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `clauses`: {
                                Description: `Groups of conditions to filter the contacts by.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundContactListFilterClauseResource,
                        },
                        `filter_type`: {
                                Description:  `How to join clauses together.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`AND`, `OR`}, false),
                        },
                },
        }
}</span>

func createOutboundContactListFilter(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        filterType := d.Get("filter_type").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkContactListFilter := platformclientv2.Contactlistfilter{
                ContactList: gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                Clauses:     buildSdkOutboundContactListFilterClauseSlice(d.Get("clauses").([]interface{})),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkContactListFilter.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if filterType != "" </span><span class="cov8" title="1">{
                sdkContactListFilter.FilterType = &amp;filterType
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Contact List Filter %s", name)
        outboundContactListFilter, _, err := outboundApi.PostOutboundContactlistfilters(sdkContactListFilter)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Contact List Filter %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundContactListFilter.Id)

        log.Printf("Created Outbound Contact List Filter %s %s", name, *outboundContactListFilter.Id)
        return readOutboundContactListFilter(ctx, d, meta)</span>
}

func updateOutboundContactListFilter(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        filterType := d.Get("filter_type").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkContactListFilter := platformclientv2.Contactlistfilter{
                ContactList: gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                Clauses:     buildSdkOutboundContactListFilterClauseSlice(d.Get("clauses").([]interface{})),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkContactListFilter.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if filterType != "" </span><span class="cov8" title="1">{
                sdkContactListFilter.FilterType = &amp;filterType
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Contact List Filter %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Contact list filter version
                outboundContactListFilter, resp, getErr := outboundApi.GetOutboundContactlistfilter(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Contact List Filter %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkContactListFilter.Version = outboundContactListFilter.Version
                outboundContactListFilter, _, updateErr := outboundApi.PutOutboundContactlistfilter(d.Id(), sdkContactListFilter)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Contact List Filter %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Contact List Filter %s", name)
        return readOutboundContactListFilter(ctx, d, meta)</span>
}

func readOutboundContactListFilter(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Contact List Filter %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkContactListFilter, resp, getErr := outboundApi.GetOutboundContactlistfilter(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound Contact List Filter %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound Contact List Filter %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundContactListFilter())
                if sdkContactListFilter.Name != nil </span><span class="cov8" title="1">{
                        _ = d.Set("name", *sdkContactListFilter.Name)
                }</span>
                <span class="cov8" title="1">if sdkContactListFilter.ContactList != nil &amp;&amp; sdkContactListFilter.ContactList.Id != nil </span><span class="cov8" title="1">{
                        _ = d.Set("contact_list_id", *sdkContactListFilter.ContactList.Id)
                }</span>
                <span class="cov8" title="1">if sdkContactListFilter.Clauses != nil </span><span class="cov8" title="1">{
                        _ = d.Set("clauses", flattenSdkOutboundContactListFilterClauseSlice(*sdkContactListFilter.Clauses))
                }</span>
                <span class="cov8" title="1">if sdkContactListFilter.FilterType != nil </span><span class="cov8" title="1">{
                        _ = d.Set("filter_type", *sdkContactListFilter.FilterType)
                }</span>

                <span class="cov8" title="1">log.Printf("Read Outbound Contact List Filter %s %s", d.Id(), *sdkContactListFilter.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundContactListFilter(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Contact List Filter")
                resp, err := outboundApi.DeleteOutboundContactlistfilter(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Contact List Filter: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundContactlistfilter(d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Contact list filter deleted
                                log.Printf("Deleted Outbound Contact List Filter %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound Contact List Filter %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Contact List Filter %s still exists", d.Id()))</span>
        })
}

func buildSdkOutboundContactListFilterRange(contactListFilterRange *schema.Set) *platformclientv2.Contactlistfilterrange <span class="cov8" title="1">{
        var sdkContactListFilterRange platformclientv2.Contactlistfilterrange
        contactListFilterRangeList := contactListFilterRange.List()
        contactListFilterRangeMap := contactListFilterRangeList[0].(map[string]interface{})
        if min := contactListFilterRangeMap["min"].(string); min != "" </span><span class="cov8" title="1">{
                sdkContactListFilterRange.Min = &amp;min
        }</span>
        <span class="cov8" title="1">if max := contactListFilterRangeMap["max"].(string); max != "" </span><span class="cov8" title="1">{
                sdkContactListFilterRange.Max = &amp;max
        }</span>
        <span class="cov8" title="1">sdkContactListFilterRange.MinInclusive = platformclientv2.Bool(contactListFilterRangeMap["min_inclusive"].(bool))
        sdkContactListFilterRange.MaxInclusive = platformclientv2.Bool(contactListFilterRangeMap["max_inclusive"].(bool))
        inSet := make([]string, 0)
        for _, v := range contactListFilterRangeMap["in_set"].([]interface{}) </span><span class="cov8" title="1">{
                inSet = append(inSet, v.(string))
        }</span>
        <span class="cov8" title="1">sdkContactListFilterRange.InSet = &amp;inSet
        return &amp;sdkContactListFilterRange</span>
}

func buildSdkOutboundContactListFilterPredicateSlice(contactListFilterPredicate []interface{}) *[]platformclientv2.Contactlistfilterpredicate <span class="cov8" title="1">{
        if contactListFilterPredicate == nil || len(contactListFilterPredicate) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactListFilterPredicateSlice := make([]platformclientv2.Contactlistfilterpredicate, 0)
        for _, configContactListFilterPredicate := range contactListFilterPredicate </span><span class="cov8" title="1">{
                if contactListFilterPredicateMap, ok := configContactListFilterPredicate.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        var sdkContactListFilterPredicate platformclientv2.Contactlistfilterpredicate
                        if column := contactListFilterPredicateMap["column"].(string); column != "" </span><span class="cov8" title="1">{
                                sdkContactListFilterPredicate.Column = &amp;column
                        }</span>
                        <span class="cov8" title="1">if columnType := contactListFilterPredicateMap["column_type"].(string); columnType != "" </span><span class="cov8" title="1">{
                                sdkContactListFilterPredicate.ColumnType = &amp;columnType
                        }</span>
                        <span class="cov8" title="1">if operator := contactListFilterPredicateMap["operator"].(string); operator != "" </span><span class="cov8" title="1">{
                                sdkContactListFilterPredicate.Operator = &amp;operator
                        }</span>
                        <span class="cov8" title="1">if value := contactListFilterPredicateMap["value"].(string); value != "" </span><span class="cov8" title="1">{
                                sdkContactListFilterPredicate.Value = &amp;value
                        }</span>
                        <span class="cov8" title="1">if varRangeSet := contactListFilterPredicateMap["var_range"].(*schema.Set); varRangeSet != nil &amp;&amp; len(varRangeSet.List()) &gt; 0 </span><span class="cov8" title="1">{
                                sdkContactListFilterPredicate.VarRange = buildSdkOutboundContactListFilterRange(varRangeSet)
                        }</span>
                        <span class="cov8" title="1">sdkContactListFilterPredicate.Inverted = platformclientv2.Bool(contactListFilterPredicateMap["inverted"].(bool))
                        sdkContactListFilterPredicateSlice = append(sdkContactListFilterPredicateSlice, sdkContactListFilterPredicate)</span>
                }
        }
        <span class="cov8" title="1">return &amp;sdkContactListFilterPredicateSlice</span>
}

func buildSdkOutboundContactListFilterClauseSlice(contactListFilterClause []interface{}) *[]platformclientv2.Contactlistfilterclause <span class="cov8" title="1">{
        if contactListFilterClause == nil || len(contactListFilterClause) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactListFilterClauseSlice := make([]platformclientv2.Contactlistfilterclause, 0)
        for _, configContactListFilterClause := range contactListFilterClause </span><span class="cov8" title="1">{
                var sdkContactListFilterClause platformclientv2.Contactlistfilterclause
                contactListFilterClauseMap := configContactListFilterClause.(map[string]interface{})
                if filterType := contactListFilterClauseMap["filter_type"].(string); filterType != "" </span><span class="cov8" title="1">{
                        sdkContactListFilterClause.FilterType = &amp;filterType
                }</span>
                <span class="cov8" title="1">if predicates := contactListFilterClauseMap["predicates"]; predicates != nil </span><span class="cov8" title="1">{
                        sdkContactListFilterClause.Predicates = buildSdkOutboundContactListFilterPredicateSlice(predicates.([]interface{}))
                }</span>

                <span class="cov8" title="1">sdkContactListFilterClauseSlice = append(sdkContactListFilterClauseSlice, sdkContactListFilterClause)</span>
        }
        <span class="cov8" title="1">return &amp;sdkContactListFilterClauseSlice</span>
}

func flattenSdkOutboundContactListFilterRange(contactListFilterRange *platformclientv2.Contactlistfilterrange) *schema.Set <span class="cov8" title="1">{
        if contactListFilterRange == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactListFilterRangeSet := schema.NewSet(schema.HashResource(outboundContactListFilterRangeResource), []interface{}{})
        contactListFilterRangeMap := make(map[string]interface{})

        if contactListFilterRange.Min != nil </span><span class="cov8" title="1">{
                contactListFilterRangeMap["min"] = *contactListFilterRange.Min
        }</span>
        <span class="cov8" title="1">if contactListFilterRange.Max != nil </span><span class="cov8" title="1">{
                contactListFilterRangeMap["max"] = *contactListFilterRange.Max
        }</span>
        <span class="cov8" title="1">if contactListFilterRange.MinInclusive != nil </span><span class="cov8" title="1">{
                contactListFilterRangeMap["min_inclusive"] = *contactListFilterRange.MinInclusive
        }</span>
        <span class="cov8" title="1">if contactListFilterRange.MaxInclusive != nil </span><span class="cov8" title="1">{
                contactListFilterRangeMap["max_inclusive"] = *contactListFilterRange.MaxInclusive
        }</span>
        <span class="cov8" title="1">if contactListFilterRange.InSet != nil </span><span class="cov8" title="1">{
                // Changed []string to []interface{} to prevent type conversion panic
                inSet := make([]interface{}, 0)
                for _, v := range *contactListFilterRange.InSet </span><span class="cov8" title="1">{
                        inSet = append(inSet, v)
                }</span>
                <span class="cov8" title="1">contactListFilterRangeMap["in_set"] = inSet</span>
        }
        <span class="cov8" title="1">if len(contactListFilterRangeMap) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">contactListFilterRangeSet.Add(contactListFilterRangeMap)

        return contactListFilterRangeSet</span>
}

func flattenSdkOutboundContactListFilterPredicateSlice(contactListFilterPredicates []platformclientv2.Contactlistfilterpredicate) []interface{} <span class="cov8" title="1">{
        if len(contactListFilterPredicates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactListFilterPredicateList := make([]interface{}, 0)
        for _, contactListFilterPredicate := range contactListFilterPredicates </span><span class="cov8" title="1">{
                contactListFilterPredicateMap := make(map[string]interface{})

                if contactListFilterPredicate.Column != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["column"] = *contactListFilterPredicate.Column
                }</span>
                <span class="cov8" title="1">if contactListFilterPredicate.ColumnType != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["column_type"] = *contactListFilterPredicate.ColumnType
                }</span>
                <span class="cov8" title="1">if contactListFilterPredicate.Operator != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["operator"] = *contactListFilterPredicate.Operator
                }</span>
                <span class="cov8" title="1">if contactListFilterPredicate.Value != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["value"] = *contactListFilterPredicate.Value
                }</span>
                <span class="cov8" title="1">if contactListFilterPredicate.VarRange != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["var_range"] = flattenSdkOutboundContactListFilterRange(contactListFilterPredicate.VarRange)
                }</span>
                <span class="cov8" title="1">if contactListFilterPredicate.Inverted != nil </span><span class="cov8" title="1">{
                        contactListFilterPredicateMap["inverted"] = *contactListFilterPredicate.Inverted
                }</span>
                <span class="cov8" title="1">contactListFilterPredicateList = append(contactListFilterPredicateList, contactListFilterPredicateMap)</span>
        }
        <span class="cov8" title="1">return contactListFilterPredicateList</span>
}

func flattenSdkOutboundContactListFilterClauseSlice(contactListFilterClauses []platformclientv2.Contactlistfilterclause) []interface{} <span class="cov8" title="1">{
        if len(contactListFilterClauses) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactListFilterClauseList := make([]interface{}, 0)
        for _, contactListFilterClause := range contactListFilterClauses </span><span class="cov8" title="1">{
                contactListFilterClauseMap := make(map[string]interface{})

                if contactListFilterClause.FilterType != nil </span><span class="cov8" title="1">{
                        contactListFilterClauseMap["filter_type"] = *contactListFilterClause.FilterType
                }</span>
                <span class="cov8" title="1">if contactListFilterClause.Predicates != nil </span><span class="cov8" title="1">{
                        contactListFilterClauseMap["predicates"] = flattenSdkOutboundContactListFilterPredicateSlice(*contactListFilterClause.Predicates)
                }</span>
                <span class="cov8" title="1">contactListFilterClauseList = append(contactListFilterClauseList, contactListFilterClauseMap)</span>
        }
        <span class="cov8" title="1">return contactListFilterClauseList</span>
}

func GenerateOutboundContactListFilter(
        resourceId string,
        name string,
        contactListId string,
        filterType string,
        nestedBlocks ...string,
) string <span class="cov8" title="1">{
        if filterType != "" </span><span class="cov8" title="1">{
                filterType = fmt.Sprintf(`filter_type = "%s"`, filterType)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
resource "genesyscloud_outbound_contactlistfilter" "%s" {
        name            = "%s"
        contact_list_id = %s
        %s
        %s
}
`, resourceId, name, contactListId, filterType, strings.Join(nestedBlocks, "\n"))</span>
}

func GenerateOutboundContactListFilterClause(filterType string, nestedBlocks ...string) string <span class="cov8" title="1">{
        if filterType != "" </span><span class="cov8" title="1">{
                filterType = fmt.Sprintf(`filter_type = "%s"`, filterType)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
        clauses {
                %s
                %s
        }
`, filterType, strings.Join(nestedBlocks, "\n"))</span>
}

func GenerateOutboundContactListFilterPredicates(
        column string,
        columnType string,
        operator string,
        value string,
        inverted string,
        varRangeBlock string,
) string <span class="cov8" title="1">{
        if column != "" </span><span class="cov8" title="1">{
                column = fmt.Sprintf(`column = "%s"`, column)
        }</span>
        <span class="cov8" title="1">if columnType != "" </span><span class="cov8" title="1">{
                columnType = fmt.Sprintf(`column_type = "%s"`, columnType)
        }</span>
        <span class="cov8" title="1">if operator != "" </span><span class="cov8" title="1">{
                operator = fmt.Sprintf(`operator = "%s"`, operator)
        }</span>
        <span class="cov8" title="1">if value != "" </span><span class="cov8" title="1">{
                value = fmt.Sprintf(`value = "%s"`, value)
        }</span>
        <span class="cov8" title="1">if inverted != "" </span><span class="cov8" title="1">{
                inverted = fmt.Sprintf(`inverted = %s`, inverted)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
                predicates {
                        %s
                        %s
                        %s
                        %s
                        %s        
                        %s
                }
`, column, columnType, operator, value, inverted, varRangeBlock)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func getAllOutboundDncLists(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                dncListConfigs, _, getErr := outboundAPI.GetOutboundDnclists(false, false, pageSize, pageNum, true, "", "", "", []string{}, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of dnc list configs: %v", getErr)
                }</span>
                <span class="cov0" title="0">if dncListConfigs.Entities == nil || len(*dncListConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for _, dncListConfig := range *dncListConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*dncListConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *dncListConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundDncListExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundDncLists),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "division_id": {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

func ResourceOutboundDncList() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Outbound DNC List`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundDncList),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundDncList),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundDncList),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundDncList),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the DncList.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_method`: {
                                Description:  `The contact method. Required if dncSourceType is rds.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`Email`, `Phone`}, false),
                        },
                        `login_id`: {
                                Description: `A dnc.com loginId. Required if the dncSourceType is dnc.com.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `campaign_id`: {
                                Description: `A dnc.com campaignId. Optional if the dncSourceType is dnc.com.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `dnc_codes`: {
                                Description: `The list of dnc.com codes to be treated as DNC. Required if the dncSourceType is dnc.com.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem: &amp;schema.Schema{
                                        Type:         schema.TypeString,
                                        ValidateFunc: validation.StringInSlice([]string{`B`, `C`, `D`, `E`, `F`, `G`, `H`, `I`, `L`, `M`, `O`, `P`, `R`, `S`, `T`, `V`, `W`, `X`, `Y`}, false),
                                },
                        },
                        `license_id`: {
                                Description: `A gryphon license number. Required if the dncSourceType is gryphon.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `division_id`: {
                                Description: `The division this DNC List belongs to.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        `dnc_source_type`: {
                                Description:  `The type of the DNC List. Changing the dnc_source_attribute will cause the outbound_dnclist object to be dropped and recreated with new ID.`,
                                Required:     true,
                                ForceNew:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`rds`, `dnc.com`, `gryphon`}, false),
                        },
                        `entries`: {
                                Description: `Rows to add to the DNC list. To emulate removing phone numbers, you can set expiration_date to a date in the past.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                `expiration_date`: {
                                                        Description:      `Expiration date for DNC phone numbers in yyyy-MM-ddTHH:mmZ format.`,
                                                        Optional:         true,
                                                        Type:             schema.TypeString,
                                                        ValidateDiagFunc: gcloud.ValidateDateTime,
                                                },
                                                `phone_numbers`: {
                                                        Description: `Phone numbers to add to a DNC list. Only possible if the dncSourceType is rds.  Phone numbers must be in an E.164 number format.`,
                                                        Optional:    true,
                                                        Type:        schema.TypeList,
                                                        Elem: &amp;schema.Schema{
                                                                Type:             schema.TypeString,
                                                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func createOutboundDncList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        contactMethod := d.Get("contact_method").(string)
        loginId := d.Get("login_id").(string)
        campaignId := d.Get("campaign_id").(string)
        licenseId := d.Get("license_id").(string)
        dncSourceType := d.Get("dnc_source_type").(string)
        dncCodes := lists.InterfaceListToStrings(d.Get("dnc_codes").([]interface{}))
        entries := d.Get("entries").([]interface{})

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkDncListCreate := platformclientv2.Dnclistcreate{
                DncCodes: &amp;dncCodes,
                Division: gcloud.BuildSdkDomainEntityRef(d, "division_id"),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkDncListCreate.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if contactMethod != "" </span><span class="cov8" title="1">{
                sdkDncListCreate.ContactMethod = &amp;contactMethod
        }</span>
        <span class="cov8" title="1">if loginId != "" </span><span class="cov0" title="0">{
                sdkDncListCreate.LoginId = &amp;loginId
        }</span>
        <span class="cov8" title="1">if campaignId != "" </span><span class="cov0" title="0">{
                sdkDncListCreate.CampaignId = &amp;campaignId
        }</span>
        <span class="cov8" title="1">if licenseId != "" </span><span class="cov0" title="0">{
                sdkDncListCreate.LicenseId = &amp;licenseId
        }</span>
        <span class="cov8" title="1">if dncSourceType != "" </span><span class="cov8" title="1">{
                sdkDncListCreate.DncSourceType = &amp;dncSourceType
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound DNC list %s", name)
        outboundDncList, _, err := outboundApi.PostOutboundDnclists(sdkDncListCreate)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound DNC list %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundDncList.Id)

        if len(entries) &gt; 0 </span><span class="cov8" title="1">{
                if *sdkDncListCreate.DncSourceType == "rds" </span><span class="cov8" title="1">{
                        for _, entry := range entries </span><span class="cov8" title="1">{
                                _, err := uploadPhoneEntriesToDncList(outboundApi, outboundDncList, entry)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return diag.Errorf("Phone numbers can only be uploaded to internal DNC lists.")
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Created Outbound DNC list %s %s", name, *outboundDncList.Id)
        return readOutboundDncList(ctx, d, meta)</span>
}

func updateOutboundDncList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        contactMethod := d.Get("contact_method").(string)
        loginId := d.Get("login_id").(string)
        campaignId := d.Get("campaign_id").(string)
        dncCodes := lists.InterfaceListToStrings(d.Get("dnc_codes").([]interface{}))
        licenseId := d.Get("license_id").(string)
        dncSourceType := d.Get("dnc_source_type").(string)
        entries := d.Get("entries").([]interface{})

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkDncList := platformclientv2.Dnclist{
                DncCodes: &amp;dncCodes,
                Division: gcloud.BuildSdkDomainEntityRef(d, "division_id"),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkDncList.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if contactMethod != "" </span><span class="cov8" title="1">{
                sdkDncList.ContactMethod = &amp;contactMethod
        }</span>
        <span class="cov8" title="1">if loginId != "" </span><span class="cov0" title="0">{
                sdkDncList.LoginId = &amp;loginId
        }</span>
        <span class="cov8" title="1">if campaignId != "" </span><span class="cov0" title="0">{
                sdkDncList.CampaignId = &amp;campaignId
        }</span>
        <span class="cov8" title="1">if licenseId != "" </span><span class="cov0" title="0">{
                sdkDncList.LicenseId = &amp;licenseId
        }</span>
        <span class="cov8" title="1">if dncSourceType != "" </span><span class="cov8" title="1">{
                sdkDncList.DncSourceType = &amp;dncSourceType
        }</span>
        <span class="cov8" title="1">log.Printf("Updating Outbound DNC list %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound DNC list version
                outboundDncList, resp, getErr := outboundApi.GetOutboundDnclist(d.Id(), false, false)
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound DNC list %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkDncList.Version = outboundDncList.Version
                outboundDncList, _, updateErr := outboundApi.PutOutboundDnclist(d.Id(), sdkDncList)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound DNC list %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">if len(entries) &gt; 0 </span><span class="cov8" title="1">{
                        if *sdkDncList.DncSourceType == "rds" </span><span class="cov8" title="1">{
                                for _, entry := range entries </span><span class="cov8" title="1">{
                                        response, err := uploadPhoneEntriesToDncList(outboundApi, outboundDncList, entry)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return response, err
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return nil, diag.Errorf("Phone numbers can only be uploaded to internal DNC lists.")
                        }</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound DNC list %s", name)
        return readOutboundDncList(ctx, d, meta)</span>
}

func readOutboundDncList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound DNC list %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkDncList, resp, getErr := outboundApi.GetOutboundDnclist(d.Id(), false, false)
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound DNC list %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound DNC list %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundDncList())

                if sdkDncList.Name != nil </span><span class="cov8" title="1">{
                        _ = d.Set("name", *sdkDncList.Name)
                }</span>
                <span class="cov8" title="1">if sdkDncList.ContactMethod != nil </span><span class="cov8" title="1">{
                        _ = d.Set("contact_method", *sdkDncList.ContactMethod)
                }</span>
                <span class="cov8" title="1">if sdkDncList.LoginId != nil </span><span class="cov0" title="0">{
                        _ = d.Set("login_id", *sdkDncList.LoginId)
                }</span>
                <span class="cov8" title="1">if sdkDncList.CampaignId != nil </span><span class="cov0" title="0">{
                        _ = d.Set("campaign_id", *sdkDncList.CampaignId)
                }</span>
                <span class="cov8" title="1">if sdkDncList.DncCodes != nil </span><span class="cov0" title="0">{
                        schemaCodes := lists.InterfaceListToStrings(d.Get("dnc_codes").([]interface{}))
                        // preserve ordering and avoid a plan not empty error
                        if lists.AreEquivalent(schemaCodes, *sdkDncList.DncCodes) </span><span class="cov0" title="0">{
                                _ = d.Set("dnc_codes", schemaCodes)
                        }</span> else<span class="cov0" title="0"> {
                                _ = d.Set("dnc_codes", lists.StringListToInterfaceList(*sdkDncList.DncCodes))
                        }</span>
                }
                <span class="cov8" title="1">if sdkDncList.DncSourceType != nil </span><span class="cov8" title="1">{
                        _ = d.Set("dnc_source_type", *sdkDncList.DncSourceType)
                }</span>
                <span class="cov8" title="1">if sdkDncList.LicenseId != nil </span><span class="cov0" title="0">{
                        _ = d.Set("license_id", *sdkDncList.LicenseId)
                }</span>
                <span class="cov8" title="1">if sdkDncList.Division != nil &amp;&amp; sdkDncList.Division.Id != nil </span><span class="cov8" title="1">{
                        _ = d.Set("division_id", *sdkDncList.Division.Id)
                }</span>
                <span class="cov8" title="1">log.Printf("Read Outbound DNC list %s %s", d.Id(), *sdkDncList.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundDncList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound DNC list")
                resp, err := outboundApi.DeleteOutboundDnclist(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound DNC list: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundDnclist(d.Id(), false, false)
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound DNC list deleted
                                log.Printf("Deleted Outbound DNC list %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound DNC list %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound DNC list %s still exists", d.Id()))</span>
        })
}

func uploadPhoneEntriesToDncList(api *platformclientv2.OutboundApi, dncList *platformclientv2.Dnclist, entry interface{}) (*platformclientv2.APIResponse, diag.Diagnostics) <span class="cov8" title="1">{
        var phoneNumbers []string
        if entryMap, ok := entry.(map[string]interface{}); ok &amp;&amp; len(entryMap) &gt; 0 </span><span class="cov8" title="1">{
                if phoneNumbersList := entryMap["phone_numbers"].([]interface{}); phoneNumbersList != nil </span><span class="cov8" title="1">{
                        for _, number := range phoneNumbersList </span><span class="cov8" title="1">{
                                phoneNumbers = append(phoneNumbers, number.(string))
                        }</span>
                }
                <span class="cov8" title="1">log.Printf("Uploading phone numbers to DNC list %s", *dncList.Name)
                // POST /api/v2/outbound/dnclists/{dncListId}/phonenumbers
                response, err := api.PostOutboundDnclistPhonenumbers(*dncList.Id, phoneNumbers, entryMap["expiration_date"].(string))
                if err != nil </span><span class="cov0" title="0">{
                        return response, diag.Errorf("Failed to upload phone numbers to Outbound DNC list %s: %s", *dncList.Name, err)
                }</span>
                <span class="cov8" title="1">log.Printf("Uploaded phone numbers to DNC list %s", *dncList.Name)</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func GenerateOutboundDncListBasic(resourceId string, name string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
resource "genesyscloud_outbound_dnclist" "%s" {
        name            = "%s"
        dnc_source_type = "rds"        
        contact_method  = "Phone"
}
`, resourceId, name)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package outbound

import (
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource("genesyscloud_outbound_callabletimeset", dataSourceOutboundCallabletimeset())
        l.RegisterDataSource("genesyscloud_outbound_attempt_limit", DataSourceOutboundAttemptLimit())
        l.RegisterDataSource("genesyscloud_outbound_callanalysisresponseset", dataSourceOutboundCallAnalysisResponseSet())
        l.RegisterDataSource("genesyscloud_outbound_messagingcampaign", dataSourceOutboundMessagingcampaign())
        l.RegisterDataSource("genesyscloud_outbound_contactlistfilter", dataSourceOutboundContactListFilter())
        l.RegisterDataSource("genesyscloud_outbound_dnclist", dataSourceOutboundDncList())

        l.RegisterResource("genesyscloud_outbound_callabletimeset", ResourceOutboundCallabletimeset())
        l.RegisterResource("genesyscloud_outbound_callanalysisresponseset", ResourceOutboundCallAnalysisResponseSet())
        l.RegisterResource("genesyscloud_outbound_contactlistfilter", ResourceOutboundContactListFilter())
        l.RegisterResource("genesyscloud_outbound_messagingcampaign", ResourceOutboundMessagingCampaign())
        l.RegisterResource("genesyscloud_outbound_settings", ResourceOutboundSettings())
        l.RegisterResource("genesyscloud_outbound_dnclist", ResourceOutboundDncList())

        l.RegisterExporter("genesyscloud_outbound_callanalysisresponseset", OutboundCallAnalysisResponseSetExporter())
        l.RegisterExporter("genesyscloud_outbound_callabletimeset", OutboundCallableTimesetExporter())
        l.RegisterExporter("genesyscloud_outbound_contactlistfilter", OutboundContactListFilterExporter())
        l.RegisterExporter("genesyscloud_outbound_messagingcampaign", OutboundMessagingcampaignExporter())
        l.RegisterExporter("genesyscloud_outbound_dnclist", OutboundDncListExporter())
        l.RegisterExporter("genesyscloud_outbound_settings", OutboundSettingsExporter())
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        OutboundmessagingcampaigncontactsortResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `field_name`: {
                                Description: `The field name by which to sort contacts.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `direction`: {
                                Description:  `The direction in which to sort contacts.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`ASC`, `DESC`}, false),
                                Default:      `ASC`,
                        },
                        `numeric`: {
                                Description: `Whether or not the column contains numeric data.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                                Default:     false,
                        },
                },
        }

        outboundmessagingcampaignsmsconfigResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `message_column`: {
                                Description: `The Contact List column specifying the message to send to the contact.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `phone_column`: {
                                Description: `The Contact List column specifying the phone number to send a message to.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `sender_sms_phone_number`: {
                                Description: `A phone number provisioned for SMS communications in E.164 format. E.g. +13175555555 or +34234234234`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `content_template_id`: {
                                Description: `The content template used to formulate the message to send to the contact.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
)

func ResourceOutboundMessagingCampaign() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Outbound Messaging Campaign`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundMessagingcampaign),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundMessagingcampaign),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundMessagingcampaign),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundMessagingcampaign),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The campaign name.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `division_id`: {
                                Description: `The division this entity belongs to.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        `callable_time_set_id`: {
                                Description: `The callable time set for this messaging campaign.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_list_id`: {
                                Description: `The contact list that this messaging campaign will send messages for.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `dnc_list_ids`: {
                                Description: `The dnc lists to check before sending a message for this messaging campaign.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `campaign_status`: {
                                Description:  `The current status of the messaging campaign. A messaging campaign may be turned 'on' or 'off'.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`on`, `off`}, false),
                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov8" title="1">{
                                        if old == `complete` &amp;&amp; new == `on` </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">if old == `invalid` &amp;&amp; new == `on` </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">if old == `stopping` &amp;&amp; new == `off` </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">return false</span>
                                },
                        },
                        `always_running`: {
                                Description: `Whether this messaging campaign is always running`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                        `contact_sorts`: {
                                Description: `The order in which to sort contacts for dialing, based on up to four columns.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        OutboundmessagingcampaigncontactsortResource,
                        },
                        `messages_per_minute`: {
                                Description: `How many messages this messaging campaign will send per minute.`,
                                Required:    true,
                                Type:        schema.TypeInt,
                        },
                        `contact_list_filter_ids`: {
                                Description: `The contact list filter to check before sending a message for this messaging campaign.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `sms_config`: {
                                Description: `Configuration for this messaging campaign to send SMS messages.`,
                                Required:    true,
                                MaxItems:    1,
                                Type:        schema.TypeSet,
                                Elem:        outboundmessagingcampaignsmsconfigResource,
                        },
                },
        }
}

func getAllOutboundMessagingcampaign(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundApi := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                sdkMessagingcampaignEntityListing, _, getErr := outboundApi.GetOutboundMessagingcampaigns(pageSize, pageNum, "", "", "", "", []string{}, "", "", []string{})
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Error requesting page of Outbound Messagingcampaign: %s", getErr)
                }</span>

                <span class="cov0" title="0">if sdkMessagingcampaignEntityListing.Entities == nil || len(*sdkMessagingcampaignEntityListing.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, entity := range *sdkMessagingcampaignEntityListing.Entities </span><span class="cov0" title="0">{
                        resources[*entity.Id] = &amp;resourceExporter.ResourceMeta{Name: *entity.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundMessagingcampaignExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundMessagingcampaign),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        `division_id`:             {RefType: "genesyscloud_auth_division"},
                        `contact_list_id`:         {RefType: "genesyscloud_outbound_contact_list"},
                        `contact_list_filter_ids`: {RefType: "genesyscloud_outbound_contactlistfilter"},
                        `dnc_list_ids`:            {RefType: "genesyscloud_outbound_dnclist"},
                        `callable_time_set_id`:    {RefType: "genesyscloud_outbound_callabletimeset"},
                        // /api/v2/responsemanagement/responses/{responseId}
                        `sms_config.content_template_id`: {},
                },
        }
}</span>

func createOutboundMessagingcampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        alwaysRunning := d.Get("always_running").(bool)
        messagesPerMinute := d.Get("messages_per_minute").(int)
        campaignStatus := d.Get("campaign_status").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkmessagingcampaign := platformclientv2.Messagingcampaign{
                Division:           gcloud.BuildSdkDomainEntityRef(d, "division_id"),
                CallableTimeSet:    gcloud.BuildSdkDomainEntityRef(d, "callable_time_set_id"),
                ContactList:        gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                DncLists:           gcloud.BuildSdkDomainEntityRefArr(d, "dnc_list_ids"),
                AlwaysRunning:      &amp;alwaysRunning,
                ContactSorts:       buildSdkoutboundmessagingcampaignContactsortSlice(d.Get("contact_sorts").([]interface{})),
                MessagesPerMinute:  &amp;messagesPerMinute,
                ContactListFilters: gcloud.BuildSdkDomainEntityRefArr(d, "contact_list_filter_ids"),
                SmsConfig:          buildSdkoutboundmessagingcampaignSmsconfig(d.Get("sms_config").(*schema.Set)),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkmessagingcampaign.Name = &amp;name
        }</span>

        <span class="cov8" title="1">if campaignStatus != "" </span><span class="cov8" title="1">{
                sdkmessagingcampaign.CampaignStatus = &amp;campaignStatus
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Messagingcampaign %s", name)
        outboundMessagingcampaign, _, err := outboundApi.PostOutboundMessagingcampaigns(sdkmessagingcampaign)
        if err != nil </span><span class="cov8" title="1">{
                return diag.Errorf("Failed to create Outbound Messagingcampaign %s: %s", name, err)
        }</span>

        <span class="cov0" title="0">d.SetId(*outboundMessagingcampaign.Id)

        log.Printf("Created Outbound Messagingcampaign %s %s", name, *outboundMessagingcampaign.Id)
        return readOutboundMessagingcampaign(ctx, d, meta)</span>
}

func updateOutboundMessagingcampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        name := d.Get("name").(string)
        alwaysRunning := d.Get("always_running").(bool)
        messagesPerMinute := d.Get("messages_per_minute").(int)
        campaignStatus := d.Get("campaign_status").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkmessagingcampaign := platformclientv2.Messagingcampaign{
                Division:           gcloud.BuildSdkDomainEntityRef(d, "division_id"),
                CallableTimeSet:    gcloud.BuildSdkDomainEntityRef(d, "callable_time_set_id"),
                ContactList:        gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                DncLists:           gcloud.BuildSdkDomainEntityRefArr(d, "dnc_list_ids"),
                AlwaysRunning:      &amp;alwaysRunning,
                ContactSorts:       buildSdkoutboundmessagingcampaignContactsortSlice(d.Get("contact_sorts").([]interface{})),
                MessagesPerMinute:  &amp;messagesPerMinute,
                ContactListFilters: gcloud.BuildSdkDomainEntityRefArr(d, "contact_list_filter_ids"),
                SmsConfig:          buildSdkoutboundmessagingcampaignSmsconfig(d.Get("sms_config").(*schema.Set)),
        }

        if name != "" </span><span class="cov0" title="0">{
                sdkmessagingcampaign.Name = &amp;name
        }</span>

        <span class="cov0" title="0">if campaignStatus != "" </span><span class="cov0" title="0">{
                sdkmessagingcampaign.CampaignStatus = &amp;campaignStatus
        }</span>

        <span class="cov0" title="0">log.Printf("Updating Outbound Messagingcampaign %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov0" title="0">{
                // Get current Outbound Messagingcampaign version
                outboundMessagingcampaign, resp, getErr := outboundApi.GetOutboundMessagingcampaign(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Messagingcampaign %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov0" title="0">sdkmessagingcampaign.Version = outboundMessagingcampaign.Version
                outboundMessagingcampaign, _, updateErr := outboundApi.PutOutboundMessagingcampaign(d.Id(), sdkmessagingcampaign)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Messagingcampaign %s: %s", name, updateErr)
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        })
        <span class="cov0" title="0">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">log.Printf("Updated Outbound Messagingcampaign %s", name)
        return readOutboundMessagingcampaign(ctx, d, meta)</span>
}

func readOutboundMessagingcampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Messagingcampaign %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                sdkmessagingcampaign, resp, getErr := outboundApi.GetOutboundMessagingcampaign(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Messagingcampaign %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Messagingcampaign %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundMessagingCampaign())

                if sdkmessagingcampaign.Name != nil </span><span class="cov0" title="0">{
                        d.Set("name", *sdkmessagingcampaign.Name)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.Division != nil &amp;&amp; sdkmessagingcampaign.Division.Id != nil </span><span class="cov0" title="0">{
                        d.Set("division_id", *sdkmessagingcampaign.Division.Id)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.CallableTimeSet != nil &amp;&amp; sdkmessagingcampaign.CallableTimeSet.Id != nil </span><span class="cov0" title="0">{
                        d.Set("callable_time_set_id", *sdkmessagingcampaign.CallableTimeSet.Id)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.ContactList != nil &amp;&amp; sdkmessagingcampaign.ContactList.Id != nil </span><span class="cov0" title="0">{
                        d.Set("contact_list_id", *sdkmessagingcampaign.ContactList.Id)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.CampaignStatus != nil </span><span class="cov0" title="0">{
                        d.Set("campaign_status", *sdkmessagingcampaign.CampaignStatus)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.DncLists != nil </span><span class="cov0" title="0">{
                        var dncListIds []string
                        for _, dnc := range *sdkmessagingcampaign.DncLists </span><span class="cov0" title="0">{
                                dncListIds = append(dncListIds, *dnc.Id)
                        }</span>
                        <span class="cov0" title="0">d.Set("dnc_list_ids", dncListIds)</span>
                }
                <span class="cov0" title="0">if sdkmessagingcampaign.AlwaysRunning != nil </span><span class="cov0" title="0">{
                        d.Set("always_running", *sdkmessagingcampaign.AlwaysRunning)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.ContactSorts != nil </span><span class="cov0" title="0">{
                        d.Set("contact_sorts", flattenSdkOutboundMessagingCampaignContactsortSlice(*sdkmessagingcampaign.ContactSorts))
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.MessagesPerMinute != nil </span><span class="cov0" title="0">{
                        d.Set("messages_per_minute", *sdkmessagingcampaign.MessagesPerMinute)
                }</span>
                <span class="cov0" title="0">if sdkmessagingcampaign.ContactListFilters != nil </span><span class="cov0" title="0">{
                        var contactListFilterIds []string
                        for _, clf := range *sdkmessagingcampaign.ContactListFilters </span><span class="cov0" title="0">{
                                contactListFilterIds = append(contactListFilterIds, *clf.Id)
                        }</span>
                        <span class="cov0" title="0">d.Set("contact_list_filter_ids", contactListFilterIds)</span>
                }
                <span class="cov0" title="0">if sdkmessagingcampaign.SmsConfig != nil </span><span class="cov0" title="0">{
                        d.Set("sms_config", flattenSdkOutboundMessagingCampaignSmsconfig(sdkmessagingcampaign.SmsConfig))
                }</span>

                <span class="cov0" title="0">log.Printf("Read Outbound Messagingcampaign %s %s", d.Id(), *sdkmessagingcampaign.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundMessagingcampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov0" title="0">{
                log.Printf("Deleting Outbound Messagingcampaign")
                _, resp, err := outboundApi.DeleteOutboundMessagingcampaign(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Messagingcampaign: %s", err)
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        })
        <span class="cov0" title="0">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, resp, err := outboundApi.GetOutboundMessagingcampaign(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                // Outbound Messagingcampaign deleted
                                log.Printf("Deleted Outbound Messagingcampaign %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting Outbound Messagingcampaign %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Messagingcampaign %s still exists", d.Id()))</span>
        })
}

func buildSdkoutboundmessagingcampaignContactsortSlice(contactSort []interface{}) *[]platformclientv2.Contactsort <span class="cov8" title="1">{
        if contactSort == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactSortSlice := make([]platformclientv2.Contactsort, 0)
        for _, configContactSort := range contactSort </span><span class="cov8" title="1">{
                var sdkContactSort platformclientv2.Contactsort
                contactsortMap := configContactSort.(map[string]interface{})
                if fieldName := contactsortMap["field_name"].(string); fieldName != "" </span><span class="cov8" title="1">{
                        sdkContactSort.FieldName = &amp;fieldName
                }</span>
                <span class="cov8" title="1">if direction := contactsortMap["direction"].(string); direction != "" </span><span class="cov8" title="1">{
                        sdkContactSort.Direction = &amp;direction
                }</span>
                <span class="cov8" title="1">if numeric, ok := contactsortMap["numeric"].(bool); ok </span><span class="cov8" title="1">{
                        sdkContactSort.Numeric = platformclientv2.Bool(numeric)
                }</span>

                <span class="cov8" title="1">sdkContactSortSlice = append(sdkContactSortSlice, sdkContactSort)</span>
        }
        <span class="cov8" title="1">return &amp;sdkContactSortSlice</span>
}

func buildSdkoutboundmessagingcampaignSmsconfig(smsconfig *schema.Set) *platformclientv2.Smsconfig <span class="cov8" title="1">{
        if smsconfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var sdkSmsconfig platformclientv2.Smsconfig
        smsconfigList := smsconfig.List()
        if len(smsconfigList) &gt; 0 </span><span class="cov8" title="1">{
                smsconfigMap := smsconfigList[0].(map[string]interface{})
                if messageColumn := smsconfigMap["message_column"].(string); messageColumn != "" </span><span class="cov8" title="1">{
                        sdkSmsconfig.MessageColumn = &amp;messageColumn
                }</span>
                <span class="cov8" title="1">if phoneColumn := smsconfigMap["phone_column"].(string); phoneColumn != "" </span><span class="cov8" title="1">{
                        sdkSmsconfig.PhoneColumn = &amp;phoneColumn
                }</span>
                <span class="cov8" title="1">if senderSmsPhoneNumber := smsconfigMap["sender_sms_phone_number"].(string); senderSmsPhoneNumber != "" </span><span class="cov8" title="1">{
                        sdkSmsconfig.SenderSmsPhoneNumber = &amp;platformclientv2.Smsphonenumberref{
                                PhoneNumber: &amp;senderSmsPhoneNumber,
                        }
                }</span>
                <span class="cov8" title="1">if contentTemplateId := smsconfigMap["content_template_id"].(string); contentTemplateId != "" </span><span class="cov0" title="0">{
                        sdkSmsconfig.ContentTemplate = &amp;platformclientv2.Domainentityref{Id: &amp;contentTemplateId}
                }</span>
        }

        <span class="cov8" title="1">return &amp;sdkSmsconfig</span>
}

func flattenSdkOutboundMessagingCampaignContactsortSlice(contactSorts []platformclientv2.Contactsort) []interface{} <span class="cov0" title="0">{
        if len(contactSorts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">contactSortList := make([]interface{}, 0)
        for _, contactsort := range contactSorts </span><span class="cov0" title="0">{
                contactSortMap := make(map[string]interface{})

                if contactsort.FieldName != nil </span><span class="cov0" title="0">{
                        contactSortMap["field_name"] = *contactsort.FieldName
                }</span>
                <span class="cov0" title="0">if contactsort.Direction != nil </span><span class="cov0" title="0">{
                        contactSortMap["direction"] = *contactsort.Direction
                }</span>
                <span class="cov0" title="0">if contactsort.Numeric != nil </span><span class="cov0" title="0">{
                        contactSortMap["numeric"] = *contactsort.Numeric
                }</span>

                <span class="cov0" title="0">contactSortList = append(contactSortList, contactSortMap)</span>
        }

        <span class="cov0" title="0">return contactSortList</span>
}

func flattenSdkOutboundMessagingCampaignSmsconfig(smsconfig *platformclientv2.Smsconfig) *schema.Set <span class="cov0" title="0">{
        if smsconfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">smsconfigSet := schema.NewSet(schema.HashResource(outboundmessagingcampaignsmsconfigResource), []interface{}{})
        smsconfigMap := make(map[string]interface{})

        if smsconfig.MessageColumn != nil </span><span class="cov0" title="0">{
                smsconfigMap["message_column"] = *smsconfig.MessageColumn
        }</span>
        <span class="cov0" title="0">if smsconfig.PhoneColumn != nil </span><span class="cov0" title="0">{
                smsconfigMap["phone_column"] = *smsconfig.PhoneColumn
        }</span>
        <span class="cov0" title="0">if smsconfig.SenderSmsPhoneNumber != nil </span><span class="cov0" title="0">{
                if smsconfig.SenderSmsPhoneNumber.PhoneNumber != nil </span><span class="cov0" title="0">{
                        smsconfigMap["sender_sms_phone_number"] = *smsconfig.SenderSmsPhoneNumber.PhoneNumber
                }</span>
        }
        <span class="cov0" title="0">if smsconfig.ContentTemplate != nil </span><span class="cov0" title="0">{
                smsconfigMap["content_template_id"] = *smsconfig.ContentTemplate.Id
        }</span>

        <span class="cov0" title="0">smsconfigSet.Add(smsconfigMap)

        return smsconfigSet</span>
}

func GenerateOutboundMessagingCampaignContactSort(fieldName string, direction string, numeric string) string <span class="cov8" title="1">{
        if direction != "" </span><span class="cov8" title="1">{
                direction = fmt.Sprintf(`direction = "%s"`, direction)
        }</span>
        <span class="cov8" title="1">if numeric != "" </span><span class="cov8" title="1">{
                numeric = fmt.Sprintf(`numeric = %s`, numeric)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
        contact_sorts {
                field_name = "%s"
                %s
        %s
        }
`, fieldName, direction, numeric)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package outbound

import (
        "context"
        "fmt"
        "log"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundSettingsAutomaticTimeZoneMappingResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `callable_windows`: {
                                Description: "The time intervals to use for automatic time zone mapping.",
                                Optional:    true,
                                Type:        schema.TypeSet,
                                MaxItems:    1,
                                Elem:        outboundSettingsCallableWindowsResource,
                        },
                        `supported_countries`: {
                                Description: "The countries that are supported for automatic time zone mapping.",
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }

        outboundSettingsCallableWindowsResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `mapped`: {
                                Description: "The time interval to place outbound calls, for contacts that can be mapped to a time zone.",
                                Optional:    true,
                                Type:        schema.TypeSet,
                                MaxItems:    1,
                                Elem:        outboundSettingsMappedResource,
                        },
                        `unmapped`: {
                                Description: "The time interval and time zone to place outbound calls, for contacts that cannot be mapped to a time zone.",
                                Optional:    true,
                                Type:        schema.TypeSet,
                                MaxItems:    1,
                                Elem:        outboundSettingsUnmappedResource,
                        },
                },
        }
        outboundSettingsMappedResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `earliest_callable_time`: {
                                Description:      "The earliest time to dial a contact. Valid format is HH:mm",
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidateTimeHHMM,
                                Type:             schema.TypeString,
                        },
                        `latest_callable_time`: {
                                Description:      "The latest time to dial a contact. Valid format is HH:mm.",
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidateTimeHHMM,
                                Type:             schema.TypeString,
                        },
                },
        }
        outboundSettingsUnmappedResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `earliest_callable_time`: {
                                Description:      "The earliest time to dial a contact. Valid format is HH:mm.",
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidateTimeHHMM,
                                Type:             schema.TypeString,
                        },
                        `latest_callable_time`: {
                                Description:      "The latest time to dial a contact. Valid format is HH:mm.",
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidateTimeHHMM,
                                Type:             schema.TypeString,
                        },
                        `time_zone_id`: {
                                Description: "The time zone to use for contacts that cannot be mapped.",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
)

func ResourceOutboundSettings() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "An organization's outbound settings",

                CreateContext: gcloud.CreateWithPooledClient(createOutboundSettings),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundSettings),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundSettings),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundSettings),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `max_calls_per_agent`: {
                                Description: "The maximum number of calls that can be placed per agent on any campaign.",
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `max_line_utilization`: {
                                Description:  "The maximum percentage of lines that should be used for Outbound, expressed as a decimal in the range [0.0, 1.0].",
                                Optional:     true,
                                ValidateFunc: validation.FloatBetween(0.0, 1.0),
                                Type:         schema.TypeFloat,
                        },
                        `abandon_seconds`: {
                                Description: "The number of seconds used to determine if a call is abandoned.",
                                Optional:    true,
                                Type:        schema.TypeFloat,
                        },
                        `compliance_abandon_rate_denominator`: {
                                Description:  "The denominator to be used in determining the compliance abandon rate.Valid values: ALL_CALLS, CALLS_THAT_REACHED_QUEUE.",
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"ALL_CALLS", "CALLS_THAT_REACHED_QUEUE", ""}, false),
                                Type:         schema.TypeString,
                        },
                        `automatic_time_zone_mapping`: {
                                Description: "The settings for automatic time zone mapping. Note that changing these settings will change them for both voice and messaging campaigns.",
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundSettingsAutomaticTimeZoneMappingResource,
                        },
                },
        }
}</span>

func getAllOutboundSettings(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        resources["0"] = &amp;resourceExporter.ResourceMeta{Name: "outbound_settings"}
        return resources, nil
}</span>

func OutboundSettingsExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundSettings),
                RefAttrs:         map[string]*resourceExporter.RefAttrSettings{}, // No references
        }
}</span>

func createOutboundSettings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        log.Printf("Creating Outbound Setting")
        d.SetId("settings")
        return updateOutboundSettings(ctx, d, meta)
}</span>

func updateOutboundSettings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        maxCallsPerAgent := d.Get("max_calls_per_agent").(int)
        maxLineUtilization := d.Get("max_line_utilization").(float64)
        abandonSeconds := d.Get("abandon_seconds").(float64)
        complianceAbandonRateDenominator := d.Get("compliance_abandon_rate_denominator").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Updating Outbound Settings %s", d.Id())

        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound settings version
                setting, resp, getErr := outboundApi.GetOutboundSettings()
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Setting %s: %s", d.Id(), getErr)
                }</span>

                <span class="cov8" title="1">update := platformclientv2.Outboundsettings{
                        Name:                     setting.Name,
                        Version:                  setting.Version,
                        AutomaticTimeZoneMapping: buildOutboundSettingsAutomaticTimeZoneMapping(d),
                }

                if maxCallsPerAgent != 0 </span><span class="cov8" title="1">{
                        update.MaxCallsPerAgent = &amp;maxCallsPerAgent
                }</span>
                <span class="cov8" title="1">if maxLineUtilization != 0 </span><span class="cov8" title="1">{
                        update.MaxLineUtilization = &amp;maxLineUtilization
                }</span>
                <span class="cov8" title="1">if abandonSeconds != 0 </span><span class="cov8" title="1">{
                        update.AbandonSeconds = &amp;abandonSeconds
                }</span>
                <span class="cov8" title="1">if complianceAbandonRateDenominator != "" </span><span class="cov8" title="1">{
                        update.ComplianceAbandonRateDenominator = &amp;complianceAbandonRateDenominator
                }</span>

                <span class="cov8" title="1">_, err := outboundApi.PatchOutboundSettings(update)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound settings %s: %s", *setting.Name, err)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound settings %s", d.Id())
        return readOutboundSettings(ctx, d, meta)</span>
}

func buildOutboundSettingsAutomaticTimeZoneMapping(d *schema.ResourceData) *platformclientv2.Automatictimezonemappingsettings <span class="cov8" title="1">{
        if mappingRequest := d.Get("automatic_time_zone_mapping"); mappingRequest != nil </span><span class="cov8" title="1">{
                if mappingList := mappingRequest.([]interface{}); len(mappingList) &gt; 0 </span><span class="cov8" title="1">{
                        mappingMap := mappingList[0].(map[string]interface{})

                        return &amp;platformclientv2.Automatictimezonemappingsettings{
                                CallableWindows:    buildCallableWindows(mappingMap["callable_windows"].(*schema.Set)),
                                SupportedCountries: buildSupportedCountries(d),
                        }
                }</span>
        }
        <span class="cov8" title="1">return &amp;platformclientv2.Automatictimezonemappingsettings{}</span>
}

func buildSupportedCountries(d *schema.ResourceData) *[]string <span class="cov8" title="1">{
        supportedCountries := []string{}
        if countries, ok := d.GetOk("automatic_time_zone_mapping.0.supported_countries"); ok </span><span class="cov8" title="1">{
                supportedCountries = lists.InterfaceListToStrings(countries.([]interface{}))
        }</span>
        <span class="cov8" title="1">return &amp;supportedCountries</span>
}

func buildCallableWindows(windows *schema.Set) *[]platformclientv2.Callablewindow <span class="cov8" title="1">{
        if windows == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">windowsSlice := make([]platformclientv2.Callablewindow, 0)
        windowsList := windows.List()
        for _, callableWindow := range windowsList </span><span class="cov8" title="1">{
                var sdkCallableWindow platformclientv2.Callablewindow

                callableWindowsMap := callableWindow.(map[string]interface{})

                sdkCallableWindow.Mapped = buildCallableWindowsMapped(callableWindowsMap["mapped"].(*schema.Set))
                sdkCallableWindow.Unmapped = buildCallableWindowsUnmapped(callableWindowsMap["unmapped"].(*schema.Set))

                windowsSlice = append(windowsSlice, sdkCallableWindow)
        }</span>
        <span class="cov8" title="1">return &amp;windowsSlice</span>
}

func buildCallableWindowsMapped(mappedWindows *schema.Set) *platformclientv2.Atzmtimeslot <span class="cov8" title="1">{
        if mappedWindows != nil </span><span class="cov8" title="1">{
                if mappedWindowsList := mappedWindows.List(); len(mappedWindowsList) &gt; 0 </span><span class="cov8" title="1">{
                        mappedWindowsMap := mappedWindowsList[0].(map[string]interface{})

                        earliestCallableTime := mappedWindowsMap["earliest_callable_time"].(string)
                        latestCallableTime := mappedWindowsMap["latest_callable_time"].(string)

                        update := &amp;platformclientv2.Atzmtimeslot{}

                        if earliestCallableTime != "" </span><span class="cov8" title="1">{
                                update.EarliestCallableTime = &amp;earliestCallableTime
                        }</span>
                        <span class="cov8" title="1">if latestCallableTime != "" </span><span class="cov8" title="1">{
                                update.LatestCallableTime = &amp;latestCallableTime
                        }</span>

                        <span class="cov8" title="1">return update</span>
                }
        }
        <span class="cov0" title="0">return &amp;platformclientv2.Atzmtimeslot{}</span>
}

func buildCallableWindowsUnmapped(unmappedWindows *schema.Set) *platformclientv2.Atzmtimeslotwithtimezone <span class="cov8" title="1">{
        if unmappedWindows != nil </span><span class="cov8" title="1">{
                if unmappedWindowsList := unmappedWindows.List(); len(unmappedWindowsList) &gt; 0 </span><span class="cov8" title="1">{
                        unmappedWindowsMap := unmappedWindowsList[0].(map[string]interface{})

                        earliestCallableTime := unmappedWindowsMap["earliest_callable_time"].(string)
                        latestCallableTime := unmappedWindowsMap["latest_callable_time"].(string)
                        timeZoneId := unmappedWindowsMap["time_zone_id"].(string)

                        update := &amp;platformclientv2.Atzmtimeslotwithtimezone{}

                        if earliestCallableTime != "" </span><span class="cov8" title="1">{
                                update.EarliestCallableTime = &amp;earliestCallableTime
                        }</span>
                        <span class="cov8" title="1">if latestCallableTime != "" </span><span class="cov8" title="1">{
                                update.LatestCallableTime = &amp;latestCallableTime
                        }</span>
                        <span class="cov8" title="1">if timeZoneId != "" </span><span class="cov8" title="1">{
                                update.TimeZoneId = &amp;timeZoneId
                        }</span>

                        <span class="cov8" title="1">return update</span>
                }
        }
        <span class="cov0" title="0">return &amp;platformclientv2.Atzmtimeslotwithtimezone{}</span>
}

func readOutboundSettings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        maxCallsPerAgent := d.Get("max_calls_per_agent").(int)
        maxLineUtilization := d.Get("max_line_utilization").(float64)
        abandonSeconds := d.Get("abandon_seconds").(float64)
        complianceAbandonRateDenominator := d.Get("compliance_abandon_rate_denominator").(string)
        automaticTimeZoneMapping := d.Get("automatic_time_zone_mapping").([]interface{})

        log.Printf("Reading Outbound setting %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                settings, resp, getErr := outboundApi.GetOutboundSettings()

                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Setting: %s", getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Setting: %s", getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundSettings())

                // Only read values if they are part of the terraform plan
                if maxCallsPerAgent != 0 </span><span class="cov8" title="1">{
                        if settings.MaxCallsPerAgent != nil </span><span class="cov8" title="1">{
                                d.Set("max_calls_per_agent", *settings.MaxCallsPerAgent)
                        }</span> else<span class="cov0" title="0"> {
                                d.Set("max_calls_per_agent", nil)
                        }</span>
                }

                <span class="cov8" title="1">if maxLineUtilization != 0 </span><span class="cov8" title="1">{
                        if settings.MaxLineUtilization != nil </span><span class="cov8" title="1">{
                                d.Set("max_line_utilization", *settings.MaxLineUtilization)
                        }</span> else<span class="cov0" title="0"> {
                                d.Set("max_line_utilization", nil)
                        }</span>
                }

                <span class="cov8" title="1">if abandonSeconds != 0 </span><span class="cov8" title="1">{
                        if settings.AbandonSeconds != nil </span><span class="cov8" title="1">{
                                d.Set("abandon_seconds", *settings.AbandonSeconds)
                        }</span> else<span class="cov0" title="0"> {
                                d.Set("abandon_seconds", nil)
                        }</span>
                }

                <span class="cov8" title="1">if complianceAbandonRateDenominator != "" </span><span class="cov8" title="1">{
                        if settings.ComplianceAbandonRateDenominator != nil </span><span class="cov8" title="1">{
                                d.Set("compliance_abandon_rate_denominator", *settings.ComplianceAbandonRateDenominator)
                        }</span> else<span class="cov0" title="0"> {
                                d.Set("compliance_abandon_rate_denominator", nil)
                        }</span>
                }

                <span class="cov8" title="1">if len(automaticTimeZoneMapping) &gt; 0 </span><span class="cov8" title="1">{
                        d.Set("automatic_time_zone_mapping", flattenOutboundSettingsAutomaticTimeZoneMapping(*settings.AutomaticTimeZoneMapping, automaticTimeZoneMapping))
                }</span>
                <span class="cov8" title="1">log.Printf("Read Outbound Setting")

                return cc.CheckState()</span>
        })
}

func flattenOutboundSettingsAutomaticTimeZoneMapping(timeZoneMappings platformclientv2.Automatictimezonemappingsettings, automaticTimeZoneMapping []interface{}) []interface{} <span class="cov8" title="1">{
        callableWindows := automaticTimeZoneMapping[0].(map[string]interface{})["callable_windows"].(*schema.Set)
        requestMap := make(map[string]interface{})
        if timeZoneMappings.CallableWindows != nil </span><span class="cov8" title="1">{
                requestMap["callable_windows"] = flattenCallableWindows(*timeZoneMappings.CallableWindows, callableWindows)
        }</span>
        <span class="cov8" title="1">if timeZoneMappings.SupportedCountries != nil </span><span class="cov8" title="1">{
                requestMap["supported_countries"] = *timeZoneMappings.SupportedCountries
        }</span>
        <span class="cov8" title="1">return []interface{}{requestMap}</span>
}

func flattenCallableWindows(windows []platformclientv2.Callablewindow, windowsSchema *schema.Set) *schema.Set <span class="cov8" title="1">{
        if len(windows) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var mappedSchema *schema.Set
        var unmappedSchema *schema.Set
        for _, callableWindowsSchema := range windowsSchema.List() </span><span class="cov8" title="1">{
                mappedSchema = callableWindowsSchema.(map[string]interface{})["mapped"].(*schema.Set)
                unmappedSchema = callableWindowsSchema.(map[string]interface{})["unmapped"].(*schema.Set)
        }</span>

        <span class="cov8" title="1">callableWindowsSet := schema.NewSet(schema.HashResource(outboundSettingsCallableWindowsResource), []interface{}{})
        for _, callableWindow := range windows </span><span class="cov8" title="1">{
                callableWindowMap := make(map[string]interface{})

                if callableWindow.Mapped != nil </span><span class="cov8" title="1">{
                        callableWindowMap["mapped"] = flattenOutboundSettingsMapped(callableWindow.Mapped, mappedSchema)
                }</span>
                <span class="cov8" title="1">if callableWindow.Unmapped != nil </span><span class="cov8" title="1">{
                        callableWindowMap["unmapped"] = flattenOutboundSettingsUnmapped(callableWindow.Unmapped, unmappedSchema)
                }</span>

                <span class="cov8" title="1">callableWindowsSet.Add(callableWindowMap)</span>
        }
        <span class="cov8" title="1">return callableWindowsSet</span>
}

func flattenOutboundSettingsMapped(mapped *platformclientv2.Atzmtimeslot, mappedSchema *schema.Set) *schema.Set <span class="cov8" title="1">{
        requestSet := schema.NewSet(schema.HashResource(outboundSettingsMappedResource), []interface{}{})
        requestMap := make(map[string]interface{})

        mappedSchemaMap := mappedSchema.List()[0].(map[string]interface{})
        earliestTimeSchema := mappedSchemaMap["earliest_callable_time"].(string)
        latestTimeSchema := mappedSchemaMap["latest_callable_time"].(string)

        if earliestTimeSchema != "" </span><span class="cov8" title="1">{
                if mapped.EarliestCallableTime != nil </span><span class="cov8" title="1">{
                        requestMap["earliest_callable_time"] = *mapped.EarliestCallableTime
                }</span>
        }
        <span class="cov8" title="1">if latestTimeSchema != "" </span><span class="cov8" title="1">{
                if mapped.LatestCallableTime != nil </span><span class="cov8" title="1">{
                        requestMap["latest_callable_time"] = *mapped.LatestCallableTime
                }</span>
        }
        <span class="cov8" title="1">requestSet.Add(requestMap)

        return requestSet</span>
}

func flattenOutboundSettingsUnmapped(unmapped *platformclientv2.Atzmtimeslotwithtimezone, unmappedSchema *schema.Set) *schema.Set <span class="cov8" title="1">{
        requestSet := schema.NewSet(schema.HashResource(outboundSettingsMappedResource), []interface{}{})
        requestMap := make(map[string]interface{})

        mappedSchemaMap := unmappedSchema.List()[0].(map[string]interface{})
        earliestTimeSchema := mappedSchemaMap["earliest_callable_time"].(string)
        latestTimeSchema := mappedSchemaMap["latest_callable_time"].(string)
        timeZone := mappedSchemaMap["time_zone_id"].(string)

        if earliestTimeSchema != "" </span><span class="cov8" title="1">{
                if unmapped.EarliestCallableTime != nil </span><span class="cov8" title="1">{
                        requestMap["earliest_callable_time"] = *unmapped.EarliestCallableTime
                }</span>
        }
        <span class="cov8" title="1">if latestTimeSchema != "" </span><span class="cov8" title="1">{
                if unmapped.LatestCallableTime != nil </span><span class="cov8" title="1">{
                        requestMap["latest_callable_time"] = *unmapped.LatestCallableTime
                }</span>
        }
        <span class="cov8" title="1">if timeZone != "" </span><span class="cov8" title="1">{
                if unmapped.TimeZoneId != nil </span><span class="cov8" title="1">{
                        requestMap["time_zone_id"] = *unmapped.TimeZoneId
                }</span>
        }
        <span class="cov8" title="1">requestSet.Add(requestMap)

        return requestSet</span>
}

func deleteOutboundSettings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package outbound_attempt_limit

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func DataSourceOutboundAttemptLimit() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Outbound Attempt Limits. Select an attempt limit by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundAttemptLimitRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Attempt Limit name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundAttemptLimitRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                attemptLimits, _, getErr := outboundAPI.GetOutboundAttemptlimits(pageSize, pageNum, true, "", name, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting attempt limit %s: %s", name, getErr))
                }</span>
                <span class="cov8" title="1">if attemptLimits.Entities == nil || len(*attemptLimits.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no attempt limits found with name %s", name))
                }</span>
                <span class="cov8" title="1">attemptLimit := (*attemptLimits.Entities)[0]
                d.SetId(*attemptLimit.Id)
                return nil</span>
        })
}

func GenerateOutboundAttemptLimitDataSource(id string, attemptLimitName string, dependsOn string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
data "genesyscloud_outbound_attempt_limit" "%s" {
        name = "%s"
        depends_on = [%s]
}
`, id, attemptLimitName, dependsOn)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package outbound_attempt_limit

import (
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterDataSource("genesyscloud_outbound_attempt_limit", DataSourceOutboundAttemptLimit())
        regInstance.RegisterResource("genesyscloud_outbound_attempt_limit", ResourceOutboundAttemptLimit())
        regInstance.RegisterExporter("genesyscloud_outbound_attempt_limit", OutboundAttemptLimitExporter())
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package outbound_attempt_limit

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        recallSettings = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `nbr_attempts`: {
                                Description: `Number of recall attempts. Must be less than max_attempts_per_contact.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeInt,
                        },
                        `minutes_between_attempts`: {
                                Description:  `Number of minutes between attempts. Must be greater than or equal to 5.`,
                                Required:     true,
                                Type:         schema.TypeInt,
                                ValidateFunc: validation.IntAtLeast(5),
                        },
                },
        }

        attemptLimitRecallSettingsResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `answering_machine`: {
                                Optional: true,
                                MaxItems: 1,
                                Type:     schema.TypeSet,
                                Elem:     recallSettings,
                        },
                        `busy`: {
                                Optional: true,
                                MaxItems: 1,
                                Type:     schema.TypeSet,
                                Elem:     recallSettings,
                        },
                        `fax`: {
                                Optional: true,
                                MaxItems: 1,
                                Type:     schema.TypeSet,
                                Elem:     recallSettings,
                        },
                        `no_answer`: {
                                Optional: true,
                                MaxItems: 1,
                                Type:     schema.TypeSet,
                                Elem:     recallSettings,
                        },
                },
        }
)

func getAllAttemptLimits(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                attemptLimitConfigs, _, getErr := outboundAPI.GetOutboundAttemptlimits(pageSize, pageNum, true, "", "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of attempt limit configs: %v", getErr)
                }</span>

                <span class="cov0" title="0">if attemptLimitConfigs.Entities == nil || len(*attemptLimitConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, attemptLimitConfig := range *attemptLimitConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*attemptLimitConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *attemptLimitConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundAttemptLimitExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAttemptLimits),
        }
}</span>

func ResourceOutboundAttemptLimit() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Outbound Attempt Limit`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundAttemptLimit),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundAttemptLimit),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundAttemptLimit),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundAttemptLimit),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name for the attempt limit.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `max_attempts_per_contact`: {
                                Description: `The maximum number of times a contact can be called within the resetPeriod. Required if maxAttemptsPerNumber is not defined.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `max_attempts_per_number`: {
                                Description: `The maximum number of times a phone number can be called within the resetPeriod. Required if maxAttemptsPerContact is not defined.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `time_zone_id`: {
                                Description: `If the resetPeriod is TODAY, this specifies the timezone in which TODAY occurs. Required if the resetPeriod is TODAY.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `reset_period`: {
                                Description:  `After how long the number of attempts will be set back to 0.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                Default:      `NEVER`,
                                ValidateFunc: validation.StringInSlice([]string{`NEVER`, `TODAY`}, true),
                        },
                        `recall_entries`: {
                                Description: `Configuration for recall attempts.`,
                                Optional:    true,
                                MaxItems:    1,
                                Type:        schema.TypeList,
                                Elem:        attemptLimitRecallSettingsResource,
                        },
                },
        }
}</span>

func createOutboundAttemptLimit(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        maxAttemptsPerContact := d.Get("max_attempts_per_contact").(int)
        maxAttemptsPerNumber := d.Get("max_attempts_per_number").(int)
        timeZoneId := d.Get("time_zone_id").(string)
        resetPeriod := d.Get("reset_period").(string)
        recallEntries := d.Get("recall_entries").([]interface{})

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkAttemptLimits := platformclientv2.Attemptlimits{}

        if name != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if maxAttemptsPerContact != 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.MaxAttemptsPerContact = &amp;maxAttemptsPerContact
        }</span>
        <span class="cov8" title="1">if maxAttemptsPerNumber != 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.MaxAttemptsPerNumber = &amp;maxAttemptsPerNumber
        }</span>
        <span class="cov8" title="1">if timeZoneId != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.TimeZoneId = &amp;timeZoneId
        }</span>
        <span class="cov8" title="1">if resetPeriod != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.ResetPeriod = &amp;resetPeriod
        }</span>
        <span class="cov8" title="1">if recallEntries != nil &amp;&amp; len(recallEntries) &gt; 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.RecallEntries = buildSdkOutboundAttemptLimitRecallEntryMap(recallEntries)
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Attempt Limit %s", name)
        outboundAttemptLimit, _, err := outboundApi.PostOutboundAttemptlimits(sdkAttemptLimits)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Attempt Limit %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundAttemptLimit.Id)

        log.Printf("Created Outbound Attempt Limit %s %s", name, *outboundAttemptLimit.Id)
        return readOutboundAttemptLimit(ctx, d, meta)</span>
}

func updateOutboundAttemptLimit(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        maxAttemptsPerContact := d.Get("max_attempts_per_contact").(int)
        maxAttemptsPerNumber := d.Get("max_attempts_per_number").(int)
        timeZoneId := d.Get("time_zone_id").(string)
        resetPeriod := d.Get("reset_period").(string)
        recallEntries := d.Get("recall_entries").([]interface{})

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkAttemptLimits := platformclientv2.Attemptlimits{}

        if name != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if maxAttemptsPerContact != 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.MaxAttemptsPerContact = &amp;maxAttemptsPerContact
        }</span>
        <span class="cov8" title="1">if maxAttemptsPerNumber != 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.MaxAttemptsPerNumber = &amp;maxAttemptsPerNumber
        }</span>
        <span class="cov8" title="1">if timeZoneId != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.TimeZoneId = &amp;timeZoneId
        }</span>
        <span class="cov8" title="1">if resetPeriod != "" </span><span class="cov8" title="1">{
                sdkAttemptLimits.ResetPeriod = &amp;resetPeriod
        }</span>
        <span class="cov8" title="1">if recallEntries != nil &amp;&amp; len(recallEntries) &gt; 0 </span><span class="cov8" title="1">{
                sdkAttemptLimits.RecallEntries = buildSdkOutboundAttemptLimitRecallEntryMap(recallEntries)
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Attempt Limit %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Attempt Limit version
                outboundAttemptLimit, resp, getErr := outboundApi.GetOutboundAttemptlimit(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Attempt Limit %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkAttemptLimits.Version = outboundAttemptLimit.Version
                outboundAttemptLimit, _, updateErr := outboundApi.PutOutboundAttemptlimit(d.Id(), sdkAttemptLimits)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Attempt Limit %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Attempt Limit %s", name)
        return readOutboundAttemptLimit(ctx, d, meta)</span>
}

func readOutboundAttemptLimit(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Attempt Limit %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkAttemptLimits, resp, getErr := outboundApi.GetOutboundAttemptlimit(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound Attempt Limit %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound Attempt Limit %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundAttemptLimit())

                if sdkAttemptLimits.Name != nil </span><span class="cov8" title="1">{
                        _ = d.Set("name", *sdkAttemptLimits.Name)
                }</span>
                <span class="cov8" title="1">if sdkAttemptLimits.MaxAttemptsPerContact != nil </span><span class="cov8" title="1">{
                        _ = d.Set("max_attempts_per_contact", *sdkAttemptLimits.MaxAttemptsPerContact)
                }</span>
                <span class="cov8" title="1">if sdkAttemptLimits.MaxAttemptsPerNumber != nil </span><span class="cov8" title="1">{
                        _ = d.Set("max_attempts_per_number", *sdkAttemptLimits.MaxAttemptsPerNumber)
                }</span>
                <span class="cov8" title="1">if sdkAttemptLimits.TimeZoneId != nil </span><span class="cov8" title="1">{
                        _ = d.Set("time_zone_id", *sdkAttemptLimits.TimeZoneId)
                }</span>
                <span class="cov8" title="1">if sdkAttemptLimits.ResetPeriod != nil </span><span class="cov8" title="1">{
                        _ = d.Set("reset_period", *sdkAttemptLimits.ResetPeriod)
                }</span>

                <span class="cov8" title="1">if sdkAttemptLimits.RecallEntries != nil &amp;&amp; len(*sdkAttemptLimits.RecallEntries) &gt; 0 </span><span class="cov8" title="1">{
                        _ = d.Set("recall_entries", flattenSdkOutboundAttemptLimitRecallEntry(sdkAttemptLimits.RecallEntries))
                }</span>

                <span class="cov8" title="1">log.Printf("Read Outbound Attempt Limit %s %s", d.Id(), *sdkAttemptLimits.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundAttemptLimit(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Attempt Limit")
                resp, err := outboundApi.DeleteOutboundAttemptlimit(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Attempt Limit: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundAttemptlimit(d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Attempt Limit deleted
                                log.Printf("Deleted Outbound Attempt Limit %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound Attempt Limit %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Attempt Limit %s still exists", d.Id()))</span>
        })
}

func buildSdkOutboundAttemptLimitRecallEntryMap(recallEntries []interface{}) *map[string]platformclientv2.Recallentry <span class="cov8" title="1">{
        if len(recallEntries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">recallEntriesMap := map[string]platformclientv2.Recallentry{}
        if entriesMap, ok := recallEntries[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                types := []string{"busy", "no_answer", "answering_machine", "fax"}
                for _, t := range types </span><span class="cov8" title="1">{
                        entrySet := entriesMap[t].(*schema.Set).List()
                        if len(entrySet) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if entryMap, ok := entrySet[0].(map[string]interface{}); ok &amp;&amp; len(entryMap) &gt; 0 </span><span class="cov8" title="1">{
                                recallEntriesMap[gcloud.ToCamelCase(t)] = *buildSdkRecallEntry(entryMap)
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;recallEntriesMap</span>
}

func buildSdkRecallEntry(entry map[string]interface{}) *platformclientv2.Recallentry <span class="cov8" title="1">{
        sdkRecallEntry := platformclientv2.Recallentry{}
        if nbrAttempts, ok := entry["nbr_attempts"].(int); ok </span><span class="cov8" title="1">{
                sdkRecallEntry.NbrAttempts = &amp;nbrAttempts
        }</span>
        <span class="cov8" title="1">if minsBetweenAttempts, ok := entry["minutes_between_attempts"].(int); ok </span><span class="cov8" title="1">{
                sdkRecallEntry.MinutesBetweenAttempts = &amp;minsBetweenAttempts
        }</span>
        <span class="cov8" title="1">return &amp;sdkRecallEntry</span>
}

func flattenSdkOutboundAttemptLimitRecallEntry(sdkRecallEntries *map[string]platformclientv2.Recallentry) []interface{} <span class="cov8" title="1">{
        recallEntries := make(map[string]interface{})
        for key, val := range *sdkRecallEntries </span><span class="cov8" title="1">{
                recallEntries[gcloud.ToSnakeCase(key)] = flattenSdkRecallEntry(val)
        }</span>
        <span class="cov8" title="1">return []interface{}{recallEntries}</span>
}

func flattenSdkRecallEntry(sdkEntry platformclientv2.Recallentry) *schema.Set <span class="cov8" title="1">{
        var (
                entryMap = make(map[string]interface{})
                entrySet = schema.NewSet(schema.HashResource(recallSettings), []interface{}{})
        )
        entryMap["nbr_attempts"] = *sdkEntry.NbrAttempts
        entryMap["minutes_between_attempts"] = *sdkEntry.MinutesBetweenAttempts
        entrySet.Add(entryMap)
        return entrySet
}</span>

func GenerateAttemptLimitResource(
        resourceId string,
        name string,
        maxAttemptsPerContact string,
        maxAttemptsPerNumber string,
        timeZoneId string,
        resetPeriod string,
        nestedBlocks ...string,
) string <span class="cov8" title="1">{
        if maxAttemptsPerContact != "" </span><span class="cov8" title="1">{
                maxAttemptsPerContact = fmt.Sprintf(`max_attempts_per_contact = %s`, maxAttemptsPerContact)
        }</span>
        <span class="cov8" title="1">if maxAttemptsPerNumber != "" </span><span class="cov8" title="1">{
                maxAttemptsPerNumber = fmt.Sprintf(`max_attempts_per_number = %s`, maxAttemptsPerNumber)
        }</span>
        <span class="cov8" title="1">if timeZoneId != "" </span><span class="cov8" title="1">{
                timeZoneId = fmt.Sprintf(`time_zone_id = "%s"`, timeZoneId)
        }</span>
        <span class="cov8" title="1">if resetPeriod != "" </span><span class="cov8" title="1">{
                resetPeriod = fmt.Sprintf(`reset_period = "%s"`, resetPeriod)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
resource "genesyscloud_outbound_attempt_limit" "%s" {
        name = "%s"
        %s
        %s
        %s
        %s
        %s
}
        `, resourceId, name, maxAttemptsPerContact, maxAttemptsPerNumber, timeZoneId, resetPeriod, strings.Join(nestedBlocks, "\n"))</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package outbound_campaign

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"
)

/*
   The data_source_genesyscloud_outbound_campaign.go contains the data source implementation
   for the resource.
*/

// dataSourceOutboundCampaignRead retrieves by name the id in question
func dataSourceOutboundCampaignRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundCampaignProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                campaignId, retryable, err := proxy.getOutboundCampaignIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error campaign %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No campaign found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(campaignId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package outbound_campaign

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
)

/*
The genesyscloud_outbound_campaign_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *outboundCampaignProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createOutboundCampaignFunc func(ctx context.Context, p *outboundCampaignProxy, campaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error)
type getAllOutboundCampaignFunc func(ctx context.Context, p *outboundCampaignProxy) (*[]platformclientv2.Campaign, error)
type getOutboundCampaignIdByNameFunc func(ctx context.Context, p *outboundCampaignProxy, name string) (id string, retryable bool, err error)
type getOutboundCampaignByIdFunc func(ctx context.Context, p *outboundCampaignProxy, id string) (campaign *platformclientv2.Campaign, response *platformclientv2.APIResponse, err error)
type updateOutboundCampaignFunc func(ctx context.Context, p *outboundCampaignProxy, id string, campaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error)
type deleteOutboundCampaignFunc func(ctx context.Context, p *outboundCampaignProxy, id string) (response *platformclientv2.APIResponse, err error)

// outboundCampaignProxy contains all of the methods that call genesys cloud APIs.
type outboundCampaignProxy struct {
        clientConfig                    *platformclientv2.Configuration
        outboundApi                     *platformclientv2.OutboundApi
        createOutboundCampaignAttr      createOutboundCampaignFunc
        getAllOutboundCampaignAttr      getAllOutboundCampaignFunc
        getOutboundCampaignIdByNameAttr getOutboundCampaignIdByNameFunc
        getOutboundCampaignByIdAttr     getOutboundCampaignByIdFunc
        updateOutboundCampaignAttr      updateOutboundCampaignFunc
        deleteOutboundCampaignAttr      deleteOutboundCampaignFunc
}

// newOutboundCampaignProxy initializes the outbound campaign proxy with all of the data needed to communicate with Genesys Cloud
func newOutboundCampaignProxy(clientConfig *platformclientv2.Configuration) *outboundCampaignProxy <span class="cov8" title="1">{
        api := platformclientv2.NewOutboundApiWithConfig(clientConfig)
        return &amp;outboundCampaignProxy{
                clientConfig:                    clientConfig,
                outboundApi:                     api,
                createOutboundCampaignAttr:      createOutboundCampaignFn,
                getAllOutboundCampaignAttr:      getAllOutboundCampaignFn,
                getOutboundCampaignIdByNameAttr: getOutboundCampaignIdByNameFn,
                getOutboundCampaignByIdAttr:     getOutboundCampaignByIdFn,
                updateOutboundCampaignAttr:      updateOutboundCampaignFn,
                deleteOutboundCampaignAttr:      deleteOutboundCampaignFn,
        }
}</span>

// getOutboundCampaignProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getOutboundCampaignProxy(clientConfig *platformclientv2.Configuration) *outboundCampaignProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newOutboundCampaignProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// createOutboundCampaign creates a Genesys Cloud outbound campaign
func (p *outboundCampaignProxy) createOutboundCampaign(ctx context.Context, outboundCampaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error) <span class="cov8" title="1">{
        return p.createOutboundCampaignAttr(ctx, p, outboundCampaign)
}</span>

// getOutboundCampaign retrieves all Genesys Cloud outbound campaign
func (p *outboundCampaignProxy) getAllOutboundCampaign(ctx context.Context) (*[]platformclientv2.Campaign, error) <span class="cov0" title="0">{
        return p.getAllOutboundCampaignAttr(ctx, p)
}</span>

// getOutboundCampaignIdByName returns a single Genesys Cloud outbound campaign by a name
func (p *outboundCampaignProxy) getOutboundCampaignIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getOutboundCampaignIdByNameAttr(ctx, p, name)
}</span>

// getOutboundCampaignById returns a single Genesys Cloud outbound campaign by Id
func (p *outboundCampaignProxy) getOutboundCampaignById(ctx context.Context, id string) (outboundCampaign *platformclientv2.Campaign, response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.getOutboundCampaignByIdAttr(ctx, p, id)
}</span>

// updateOutboundCampaign updates a Genesys Cloud outbound campaign
func (p *outboundCampaignProxy) updateOutboundCampaign(ctx context.Context, id string, outboundCampaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error) <span class="cov8" title="1">{
        return p.updateOutboundCampaignAttr(ctx, p, id, outboundCampaign)
}</span>

// deleteOutboundCampaign deletes a Genesys Cloud outbound campaign by Id
func (p *outboundCampaignProxy) deleteOutboundCampaign(ctx context.Context, id string) (response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.deleteOutboundCampaignAttr(ctx, p, id)
}</span>

// createOutboundCampaignFn is an implementation function for creating a Genesys Cloud outbound campaign
func createOutboundCampaignFn(ctx context.Context, p *outboundCampaignProxy, outboundCampaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error) <span class="cov8" title="1">{
        campaign, _, err := p.outboundApi.PostOutboundCampaigns(*outboundCampaign)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create campaign %s", err)
        }</span>

        <span class="cov8" title="1">return campaign, nil</span>
}

// getAllOutboundCampaignFn is the implementation for retrieving all outbound campaign in Genesys Cloud
func getAllOutboundCampaignFn(ctx context.Context, p *outboundCampaignProxy) (*[]platformclientv2.Campaign, error) <span class="cov8" title="1">{
        var allCampaigns []platformclientv2.Campaign
        const pageSize = 100

        campaigns, _, err := p.outboundApi.GetOutboundCampaigns(pageSize, 1, "", "", nil, "", "", "", "", "", nil, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get campaign: %s", err)
        }</span>

        <span class="cov8" title="1">if campaigns.Entities == nil || len(*campaigns.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allCampaigns, nil
        }</span>

        <span class="cov8" title="1">for _, campaign := range *campaigns.Entities </span><span class="cov8" title="1">{
                allCampaigns = append(allCampaigns, campaign)
        }</span>

        <span class="cov8" title="1">for pageNum := 2; pageNum &lt;= *campaigns.PageCount; pageNum++ </span><span class="cov0" title="0">{
                campaigns, _, err := p.outboundApi.GetOutboundCampaigns(pageSize, pageNum, "", "", nil, "", "", "", "", "", nil, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get campaign: %s", err)
                }</span>

                <span class="cov0" title="0">if campaigns.Entities == nil || len(*campaigns.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, campaign := range *campaigns.Entities </span><span class="cov0" title="0">{
                        allCampaigns = append(allCampaigns, campaign)
                }</span>
        }

        <span class="cov8" title="1">return &amp;allCampaigns, nil</span>
}

// getOutboundCampaignIdByNameFn is an implementation of the function to get a Genesys Cloud outbound campaign by name
func getOutboundCampaignIdByNameFn(ctx context.Context, p *outboundCampaignProxy, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        campaigns, err := getAllOutboundCampaignFn(ctx, p)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov8" title="1">if campaigns == nil || len(*campaigns) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("No campaigns found with name %s", name)
        }</span>

        <span class="cov8" title="1">for _, campaign := range *campaigns </span><span class="cov8" title="1">{
                if *campaign.Name == name </span><span class="cov8" title="1">{
                        log.Printf("Retrieved the campaign id %s by name %s", *campaign.Id, name)
                        return *campaign.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("Unable to find campaign with name %s", name)</span>
}

// getOutboundCampaignByIdFn is an implementation of the function to get a Genesys Cloud outbound campaign by Id
func getOutboundCampaignByIdFn(ctx context.Context, p *outboundCampaignProxy, id string) (outboundCampaign *platformclientv2.Campaign, response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        campaign, resp, err := p.outboundApi.GetOutboundCampaign(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp, fmt.Errorf("Failed to retrieve campaign by id %s: %s", id, err)
        }</span>
        <span class="cov8" title="1">return campaign, resp, nil</span>
}

// updateOutboundCampaignFn is an implementation of the function to update a Genesys Cloud outbound campaign
func updateOutboundCampaignFn(ctx context.Context, p *outboundCampaignProxy, id string, outboundCampaign *platformclientv2.Campaign) (*platformclientv2.Campaign, error) <span class="cov8" title="1">{
        campaign, _, err := getOutboundCampaignByIdFn(ctx, p, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to ruleset by id %s: %s", id, err)
        }</span>

        <span class="cov8" title="1">outboundCampaign.Version = campaign.Version
        outboundCampaign, _, err = p.outboundApi.PutOutboundCampaign(id, *outboundCampaign)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update campaign: %s", err)
        }</span>
        <span class="cov8" title="1">return outboundCampaign, nil</span>
}

// deleteOutboundCampaignFn is an implementation function for deleting a Genesys Cloud outbound campaign
func deleteOutboundCampaignFn(ctx context.Context, p *outboundCampaignProxy, id string) (response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        _, resp, err := p.outboundApi.DeleteOutboundCampaign(id)
        if err != nil </span><span class="cov0" title="0">{
                return resp, fmt.Errorf("Failed to delete campaign: %s", err)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package outbound_campaign

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"
)

/*
The resource_genesyscloud_outbound_campaign.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthOutboundCampaign retrieves all of the outbound campaign via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthOutboundCampaign(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        proxy := getOutboundCampaignProxy(clientConfig)

        campaigns, err := proxy.getAllOutboundCampaign(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get campaigns: %s", err)
        }</span>

        <span class="cov0" title="0">for _, campaign := range *campaigns </span><span class="cov0" title="0">{
                // If a campaign is "stopping" during the export process we may encounter an error when we read the campaign later, and it will stop the export.
                // We will give the campaign time to stop here and skip any that won't stop in time
                if *campaign.CampaignStatus == "stopping" </span><span class="cov0" title="0">{
                        log.Println("Campaign is stopping")
                        // Retry to give the campaign time to turn off
                        err := gcloud.WithRetries(ctx, 5*time.Minute, func() *retry.RetryError </span><span class="cov0" title="0">{
                                campaign, resp, getErr := proxy.getOutboundCampaignById(ctx, *campaign.Id)
                                if getErr != nil </span><span class="cov0" title="0">{
                                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                                return retry.RetryableError(fmt.Errorf("Failed to read Campaign %s during export: %s", *campaign.Id, getErr))
                                        }</span>
                                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Campaign %s: during export %s", *campaign.Id, getErr))</span>
                                }

                                <span class="cov0" title="0">if *campaign.CampaignStatus == "stopping" </span><span class="cov0" title="0">{
                                        return retry.RetryableError(fmt.Errorf("Campaign %s didn't stop in time, unable to export", *campaign.Id))
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        })
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Printf("%v", err)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">resources[*campaign.Id] = &amp;resourceExporter.ResourceMeta{Name: *campaign.Name}</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createOutboundCampaign is used by the outbound_campaign resource to create Genesys cloud outbound campaign
func createOutboundCampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundCampaignProxy(sdkConfig)
        campaignStatus := d.Get("campaign_status").(string)

        campaign := getOutboundCampaignFromResourceData(d)

        // Create campaign
        log.Printf("Creating Outbound Campaign %s", *campaign.Name)
        outboundCampaign, err := proxy.createOutboundCampaign(ctx, &amp;campaign)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Campaign %s: %s", *campaign.Name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundCampaign.Id)

        // Campaigns can be enabled after creation
        if campaignStatus == "on" </span><span class="cov8" title="1">{
                d.Set("campaign_status", campaignStatus)
                diag := updateOutboundCampaignStatus(ctx, d.Id(), proxy, *outboundCampaign, campaignStatus)
                if diag != nil </span><span class="cov0" title="0">{
                        return diag
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Created Outbound Campaign %s %s", *outboundCampaign.Name, *outboundCampaign.Id)

        return readOutboundCampaign(ctx, d, meta)</span>
}

// readOutboundCampaign is used by the outbound_campaign resource to read an outbound campaign from genesys cloud
func readOutboundCampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundCampaignProxy(sdkConfig)

        log.Printf("Reading Outbound Campaign %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                campaign, resp, getErr := proxy.getOutboundCampaignById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Campaign %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Campaign %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">if *campaign.CampaignStatus == "stopping" </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("Outbound Campaign still stopping %s", d.Id()))
                }</span>

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundCampaign())

                resourcedata.SetNillableValue(d, "name", campaign.Name)
                resourcedata.SetNillableReference(d, "contact_list_id", campaign.ContactList)
                resourcedata.SetNillableReference(d, "queue_id", campaign.Queue)
                resourcedata.SetNillableValue(d, "dialing_mode", campaign.DialingMode)
                resourcedata.SetNillableReference(d, "script_id", campaign.Script)
                resourcedata.SetNillableReference(d, "edge_group_id", campaign.EdgeGroup)
                resourcedata.SetNillableReference(d, "site_id", campaign.Site)
                resourcedata.SetNillableValue(d, "campaign_status", campaign.CampaignStatus)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "phone_columns", campaign.PhoneColumns, flattenPhoneColumn)
                resourcedata.SetNillableValue(d, "abandon_rate", campaign.AbandonRate)
                if campaign.DncLists != nil </span><span class="cov8" title="1">{
                        d.Set("dnc_list_ids", gcloud.SdkDomainEntityRefArrToList(*campaign.DncLists))
                }</span>
                <span class="cov8" title="1">resourcedata.SetNillableReference(d, "callable_time_set_id", campaign.CallableTimeSet)
                resourcedata.SetNillableReference(d, "call_analysis_response_set_id", campaign.CallAnalysisResponseSet)
                resourcedata.SetNillableValue(d, "caller_name", campaign.CallerName)
                resourcedata.SetNillableValue(d, "caller_address", campaign.CallerAddress)
                resourcedata.SetNillableValue(d, "outbound_line_count", campaign.OutboundLineCount)
                if campaign.RuleSets != nil </span><span class="cov8" title="1">{
                        d.Set("rule_set_ids", gcloud.SdkDomainEntityRefArrToList(*campaign.RuleSets))
                }</span>
                <span class="cov8" title="1">resourcedata.SetNillableValue(d, "skip_preview_disabled", campaign.SkipPreviewDisabled)
                resourcedata.SetNillableValue(d, "preview_time_out_seconds", campaign.PreviewTimeOutSeconds)
                resourcedata.SetNillableValue(d, "always_running", campaign.AlwaysRunning)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "contact_sorts", campaign.ContactSorts, flattenContactSorts)
                resourcedata.SetNillableValue(d, "no_answer_timeout", campaign.NoAnswerTimeout)
                resourcedata.SetNillableValue(d, "call_analysis_language", campaign.CallAnalysisLanguage)
                resourcedata.SetNillableValue(d, "priority", campaign.Priority)
                if campaign.ContactListFilters != nil </span><span class="cov8" title="1">{
                        d.Set("contact_list_filter_ids", gcloud.SdkDomainEntityRefArrToList(*campaign.ContactListFilters))
                }</span>
                <span class="cov8" title="1">resourcedata.SetNillableReference(d, "division_id", campaign.Division)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "dynamic_contact_queueing_settings", campaign.DynamicContactQueueingSettings, flattenSettings)

                log.Printf("Read Outbound Campaign %s %s", d.Id(), *campaign.Name)
                return cc.CheckState()</span>
        })
}

// updateOutboundCampaign is used by the outbound_campaign resource to update an outbound campaign in Genesys Cloud
func updateOutboundCampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundCampaignProxy(sdkConfig)
        campaignStatus := d.Get("campaign_status").(string)

        campaign := getOutboundCampaignFromResourceData(d)

        log.Printf("Updating Outbound Campaign %s", *campaign.Name)
        campaignSdk, err := proxy.updateOutboundCampaign(ctx, d.Id(), &amp;campaign)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update campaign %s", err)
        }</span>

        // Check if Campaign Status needs updated
        <span class="cov8" title="1">diagErr := updateOutboundCampaignStatus(ctx, d.Id(), proxy, *campaignSdk, campaignStatus)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Campaign %s", *campaign.Name)
        return readOutboundCampaign(ctx, d, meta)</span>
}

// deleteOutboundCampaign is used by the outbound_campaign resource to delete an outbound campaign from Genesys cloud
func deleteOutboundCampaign(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundCampaignProxy(sdkConfig)

        campaignStatus := d.Get("campaign_status").(string)

        // Campaigns have to be turned off before they can be deleted
        if campaignStatus != "off" </span><span class="cov8" title="1">{
                diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                        log.Printf("Turning off Outbound Campaign before deletion")
                        outboundCampaign, resp, getErr := proxy.getOutboundCampaignById(ctx, d.Id())
                        if getErr != nil </span><span class="cov0" title="0">{
                                return resp, diag.Errorf("Failed to read Outbound Campaign %s: %s", d.Id(), getErr)
                        }</span>
                        // Handles updating the campaign based on what is set in ResourceData.campaign_status
                        <span class="cov8" title="1">diagErr := updateOutboundCampaignStatus(ctx, d.Id(), proxy, *outboundCampaign, "off")
                        if diagErr != nil </span><span class="cov0" title="0">{
                                return resp, diagErr
                        }</span>
                        <span class="cov8" title="1">return resp, nil</span>
                })
                <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                        return diagErr
                }</span>
                // Give the campaign some time to turn off
                <span class="cov8" title="1">time.Sleep(20 * time.Second)</span>
        }
        <span class="cov8" title="1">_, err := proxy.deleteOutboundCampaign(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete campaign %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := proxy.getOutboundCampaignById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Campaign deleted
                                log.Printf("Deleted Outbound Campaign %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting Outbound Campaign %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Campaign %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package outbound_campaign

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "terraform-provider-genesyscloud/genesyscloud/outbound"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_outbound_campaign_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the outbound_campaign resource.
3.  The datasource schema definitions for the outbound_campaign datasource.
4.  The resource exporter configuration for the outbound_campaign exporter.
*/
const resourceName = "genesyscloud_outbound_campaign"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceOutboundCampaign())
        regInstance.RegisterDataSource(resourceName, DataSourceOutboundCampaign())
        regInstance.RegisterExporter(resourceName, OutboundCampaignExporter())
}</span>

// ResourceOutboundCampaign registers the genesyscloud_outbound_campaign resource with Terraform
func ResourceOutboundCampaign() *schema.Resource <span class="cov8" title="1">{
        outboundcampaignphonecolumnResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `column_name`: {
                                Description: `The name of the phone column.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound campaign`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundCampaign),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundCampaign),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundCampaign),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundCampaign),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the Campaign.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_list_id`: {
                                Description: `The ContactList for this Campaign to dial.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `queue_id`: {
                                Description: `The Queue for this Campaign to route calls to. Required for all dialing modes except agentless.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `dialing_mode`: {
                                Description:  `The strategy this Campaign will use for dialing.`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`agentless`, `preview`, `power`, `predictive`, `progressive`, `external`}, false),
                        },
                        `script_id`: {
                                Description: `The Script to be displayed to agents that are handling outbound calls. Required for all dialing modes except agentless.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `edge_group_id`: {
                                Description: `The EdgeGroup that will place the calls. Required for all dialing modes except preview.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `site_id`: {
                                Description: `The identifier of the site to be used for dialing; can be set in place of an edge group.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `campaign_status`: {
                                Description:  `The current status of the Campaign. A Campaign may be turned 'on' or 'off' (default). If this value is changed alongside other changes to the resource, a subsequent update will occur immediately afterwards to set the campaign status. This is due to behavioral requirements in the Genesys Cloud API.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                Computed:     true,
                                ValidateFunc: validation.StringInSlice([]string{`on`, `off`}, false),
                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov8" title="1">{
                                        return (old == `complete` &amp;&amp; new == `off`) || (old == `invalid` &amp;&amp; new == `off`) || (old == `stopping` &amp;&amp; new == `off` || old == `complete` &amp;&amp; new == `on`)
                                }</span>,
                        },
                        `phone_columns`: {
                                Description: `The ContactPhoneNumberColumns on the ContactList that this Campaign should dial.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundcampaignphonecolumnResource,
                        },
                        `abandon_rate`: {
                                Description: `The targeted abandon rate percentage. Required for progressive, power, and predictive campaigns.`,
                                Optional:    true,
                                Type:        schema.TypeFloat,
                        },
                        `dnc_list_ids`: {
                                Description: `DncLists for this Campaign to check before placing a call.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `callable_time_set_id`: {
                                Description: `The callable time set for this campaign to check before placing a call.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `call_analysis_response_set_id`: {
                                Description: `The call analysis response set to handle call analysis results from the edge. Required for all dialing modes except preview.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `caller_name`: {
                                Description: `The caller id name to be displayed on the outbound call.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `caller_address`: {
                                Description: `The caller id phone number to be displayed on the outbound call.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `outbound_line_count`: {
                                Description: `The number of outbound lines to be concurrently dialed. Only applicable to non-preview campaigns; only required for agentless.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `rule_set_ids`: {
                                Description: `Rule sets to be applied while this campaign is dialing.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `skip_preview_disabled`: {
                                Description: `Whether or not agents can skip previews without placing a call. Only applicable for preview campaigns.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `preview_time_out_seconds`: {
                                Description: `The number of seconds before a call will be automatically placed on a preview. A value of 0 indicates no automatic placement of calls. Only applicable to preview campaigns.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `always_running`: {
                                Description: `Indicates (when true) that the campaign will remain on after contacts are depleted, allowing additional contacts to be appended/added to the contact list and processed by the still-running campaign. The campaign can still be turned off manually.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `contact_sorts`: {
                                Description: `The order in which to sort contacts for dialing, based on up to four columns.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outbound.OutboundmessagingcampaigncontactsortResource,
                        },
                        `no_answer_timeout`: {
                                Description: `How long to wait before dispositioning a call as 'no-answer'. Default 30 seconds. Only applicable to non-preview campaigns.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeInt,
                        },
                        `call_analysis_language`: {
                                Description: `The language the edge will use to analyze the call.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `priority`: {
                                Description: `The priority of this campaign relative to other campaigns that are running on the same queue. 5 is the highest priority, 1 the lowest.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeInt,
                        },
                        `contact_list_filter_ids`: {
                                Description: `Filter to apply to the contact list before dialing. Currently a campaign can only have one filter applied.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `division_id`: {
                                Description: `The division this campaign belongs to.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        `dynamic_contact_queueing_settings`: {
                                Description: `Settings for dynamic queueing of contacts.`,
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Computed:    true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "sort": {
                                                        Description: "Whether to sort contacts dynamically.",
                                                        Type:        schema.TypeBool,
                                                        Required:    true,
                                                        ForceNew:    true,
                                                },
                                        },
                                },
                        },
                },
        }
}

// OutboundCampaignExporter returns the resourceExporter object used to hold the genesyscloud_outbound_campaign exporter's config
func OutboundCampaignExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthOutboundCampaign),
                AllowZeroValues:  []string{`preview_time_out_seconds`},
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        `contact_list_id`: {
                                RefType: "genesyscloud_outbound_contact_list",
                        },
                        `queue_id`: {
                                RefType: "genesyscloud_routing_queue",
                        },
                        `edge_group_id`: {
                                RefType: "genesyscloud_telephony_providers_edges_edge_group",
                        },
                        `site_id`: {
                                RefType: "genesyscloud_telephony_providers_edges_site",
                        },
                        `dnc_list_ids`: {
                                RefType: "genesyscloud_outbound_dnclist",
                        },
                        `call_analysis_response_set_id`: {
                                RefType: "genesyscloud_outbound_callanalysisresponseset",
                        },
                        `contact_list_filter_ids`: {
                                RefType: "genesyscloud_outbound_contactlistfilter",
                        },
                        `division_id`: {
                                RefType: "genesyscloud_auth_division",
                        },
                        `rule_set_ids`: {
                                RefType: "genesyscloud_outbound_ruleset",
                        },
                        `callable_time_set_id`: {
                                RefType: "genesyscloud_outbound_callabletimeset",
                        },
                        `script_id`: {
                                RefType: "genesyscloud_script",
                        },
                },
        }
}</span>

// DataSourceOutboundCampaign registers the genesyscloud_outbound_campaign data source
func DataSourceOutboundCampaign() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound campaign data source. Select an outbound campaign by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundCampaignRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `outbound campaign name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package outbound_campaign

import (
        "context"
        "fmt"
        "github.com/google/uuid"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        "strconv"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/outbound"
        obContactList "terraform-provider-genesyscloud/genesyscloud/outbound_contact_list"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
)

/*
The resource_genesyscloud_outbound_campaign_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.
*/

func getOutboundCampaignFromResourceData(d *schema.ResourceData) platformclientv2.Campaign <span class="cov8" title="1">{
        abandonRate := d.Get("abandon_rate").(float64)
        outboundLineCount := d.Get("outbound_line_count").(int)
        skipPreviewDisabled := d.Get("skip_preview_disabled").(bool)
        previewTimeOutSeconds := d.Get("preview_time_out_seconds").(int)
        alwaysRunning := d.Get("always_running").(bool)
        noAnswerTimeout := d.Get("no_answer_timeout").(int)
        callAnalysisLanguage := d.Get("call_analysis_language").(string)
        priority := d.Get("priority").(int)

        campaign := platformclientv2.Campaign{
                Name:                           platformclientv2.String(d.Get("name").(string)),
                DialingMode:                    platformclientv2.String(d.Get("dialing_mode").(string)),
                CallerAddress:                  platformclientv2.String(d.Get("caller_address").(string)),
                CallerName:                     platformclientv2.String(d.Get("caller_name").(string)),
                CampaignStatus:                 platformclientv2.String("off"),
                ContactList:                    gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                Queue:                          gcloud.BuildSdkDomainEntityRef(d, "queue_id"),
                Script:                         gcloud.BuildSdkDomainEntityRef(d, "script_id"),
                EdgeGroup:                      gcloud.BuildSdkDomainEntityRef(d, "edge_group_id"),
                Site:                           gcloud.BuildSdkDomainEntityRef(d, "site_id"),
                PhoneColumns:                   buildPhoneColumns(d.Get("phone_columns").([]interface{})),
                DncLists:                       gcloud.BuildSdkDomainEntityRefArr(d, "dnc_list_ids"),
                CallableTimeSet:                gcloud.BuildSdkDomainEntityRef(d, "callable_time_set_id"),
                CallAnalysisResponseSet:        gcloud.BuildSdkDomainEntityRef(d, "call_analysis_response_set_id"),
                RuleSets:                       gcloud.BuildSdkDomainEntityRefArr(d, "rule_set_ids"),
                SkipPreviewDisabled:            &amp;skipPreviewDisabled,
                AlwaysRunning:                  &amp;alwaysRunning,
                ContactSorts:                   buildContactSorts(d.Get("contact_sorts").([]interface{})),
                ContactListFilters:             gcloud.BuildSdkDomainEntityRefArr(d, "contact_list_filter_ids"),
                Division:                       gcloud.BuildSdkDomainEntityRef(d, "division_id"),
                DynamicContactQueueingSettings: buildSettings(d.Get("dynamic_contact_queueing_settings").([]interface{})),
        }

        if abandonRate != 0 </span><span class="cov8" title="1">{
                campaign.AbandonRate = &amp;abandonRate
        }</span>
        <span class="cov8" title="1">if outboundLineCount != 0 </span><span class="cov8" title="1">{
                campaign.OutboundLineCount = &amp;outboundLineCount
        }</span>
        <span class="cov8" title="1">if previewTimeOutSeconds != 0 </span><span class="cov8" title="1">{
                campaign.PreviewTimeOutSeconds = &amp;previewTimeOutSeconds
        }</span>
        <span class="cov8" title="1">if noAnswerTimeout != 0 </span><span class="cov8" title="1">{
                campaign.NoAnswerTimeout = &amp;noAnswerTimeout
        }</span>
        <span class="cov8" title="1">if callAnalysisLanguage != "" </span><span class="cov0" title="0">{
                campaign.CallAnalysisLanguage = &amp;callAnalysisLanguage
        }</span>
        <span class="cov8" title="1">if priority != 0 </span><span class="cov8" title="1">{
                campaign.Priority = &amp;priority
        }</span>

        <span class="cov8" title="1">return campaign</span>
}

func updateOutboundCampaignStatus(ctx context.Context, campaignId string, proxy *outboundCampaignProxy, campaign platformclientv2.Campaign, newCampaignStatus string) diag.Diagnostics <span class="cov8" title="1">{
        if newCampaignStatus != "" &amp;&amp;
                // Campaign status can only go from ON -&gt; OFF or OFF, COMPLETE, INVALID, ETC -&gt; ON
                ((*campaign.CampaignStatus == "on" &amp;&amp; newCampaignStatus == "off") ||
                        (*campaign.CampaignStatus != "on" &amp;&amp; newCampaignStatus == "on")) </span><span class="cov8" title="1">{
                campaign.CampaignStatus = &amp;newCampaignStatus
                log.Printf("Updating Outbound Campaign %s status to %s", *campaign.Name, newCampaignStatus)
                _, err := proxy.updateOutboundCampaign(ctx, campaignId, &amp;campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to update Outbound Campaign %s: %s", *campaign.Name, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func buildPhoneColumns(phonecolumns []interface{}) *[]platformclientv2.Phonecolumn <span class="cov8" title="1">{
        if phonecolumns == nil || len(phonecolumns) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">phonecolumnSlice := make([]platformclientv2.Phonecolumn, 0)
        for _, phonecolumn := range phonecolumns </span><span class="cov8" title="1">{
                var sdkPhonecolumn platformclientv2.Phonecolumn
                phonecolumnMap, ok := phonecolumn.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkPhonecolumn.ColumnName, phonecolumnMap, "column_name")
                phonecolumnSlice = append(phonecolumnSlice, sdkPhonecolumn)</span>
        }
        <span class="cov8" title="1">return &amp;phonecolumnSlice</span>
}

func buildSettings(settings []interface{}) *platformclientv2.Dynamiccontactqueueingsettings <span class="cov8" title="1">{
        if settings == nil || len(settings) &lt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var sdkDcqSettings platformclientv2.Dynamiccontactqueueingsettings
        dcqSetting, ok := settings[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if sort, ok := dcqSetting["sort"].(bool); ok </span><span class="cov8" title="1">{
                sdkDcqSettings.Sort = &amp;sort
        }</span>
        <span class="cov8" title="1">return &amp;sdkDcqSettings</span>
}

func buildContactSorts(contactSortList []interface{}) *[]platformclientv2.Contactsort <span class="cov8" title="1">{
        if contactSortList == nil || len(contactSortList) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactsortSlice := make([]platformclientv2.Contactsort, 0)
        for _, configcontactsort := range contactSortList </span><span class="cov8" title="1">{
                var sdkContactsort platformclientv2.Contactsort
                contactsortMap := configcontactsort.(map[string]interface{})

                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkContactsort.FieldName, contactsortMap, "field_name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkContactsort.Direction, contactsortMap, "direction")

                sdkContactsort.Numeric = platformclientv2.Bool(contactsortMap["numeric"].(bool))
                sdkContactsortSlice = append(sdkContactsortSlice, sdkContactsort)
        }</span>
        <span class="cov8" title="1">return &amp;sdkContactsortSlice</span>
}

func flattenSettings(settings *platformclientv2.Dynamiccontactqueueingsettings) []interface{} <span class="cov8" title="1">{
        settingsMap := make(map[string]interface{}, 0)
        settingsMap["sort"] = *settings.Sort
        return []interface{}{settingsMap}
}</span>

func flattenPhoneColumn(phonecolumns *[]platformclientv2.Phonecolumn) []interface{} <span class="cov8" title="1">{
        if len(*phonecolumns) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">phonecolumnList := make([]interface{}, 0)
        for _, phonecolumn := range *phonecolumns </span><span class="cov8" title="1">{
                phonecolumnMap := make(map[string]interface{})
                resourcedata.SetMapValueIfNotNil(phonecolumnMap, "column_name", phonecolumn.ColumnName)
                phonecolumnList = append(phonecolumnList, phonecolumnMap)
        }</span>

        <span class="cov8" title="1">return phonecolumnList</span>
}

func flattenContactSorts(contactSorts *[]platformclientv2.Contactsort) []interface{} <span class="cov8" title="1">{
        if len(*contactSorts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactSortList := make([]interface{}, 0)
        for _, contactSort := range *contactSorts </span><span class="cov8" title="1">{
                contactSortMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(contactSortMap, "field_name", contactSort.FieldName)
                resourcedata.SetMapValueIfNotNil(contactSortMap, "direction", contactSort.Direction)
                resourcedata.SetMapValueIfNotNil(contactSortMap, "numeric", contactSort.Numeric)

                contactSortList = append(contactSortList, contactSortMap)
        }</span>

        <span class="cov8" title="1">return contactSortList</span>
}

func GenerateOutboundCampaignBasic(resourceId string,
        name string,
        contactListResourceId string,
        siteResourceId string,
        emergencyNumber string,
        carResourceId string,
        campaignStatus string,
        outboundFlowFilePath string,
        flowResourceId string,
        flowName string,
        divisionName,
        locationResourceId string,
        wrapupcodeResourceId string) string <span class="cov8" title="1">{
        referencedResources := GenerateReferencedResourcesForOutboundCampaignTests(
                contactListResourceId,
                "",
                "",
                carResourceId,
                outboundFlowFilePath,
                flowResourceId,
                flowName,
                "",
                siteResourceId,
                emergencyNumber,
                "",
                "",
                divisionName,
                locationResourceId,
                wrapupcodeResourceId,
        )
        return fmt.Sprintf(`
resource "genesyscloud_outbound_campaign" "%s" {
        name                          = "%s"
        dialing_mode                  = "agentless"
        caller_name                   = "Test Name"
        caller_address                = "+353371111111"
        outbound_line_count           = 2
        campaign_status               = %s
        contact_list_id                           = genesyscloud_outbound_contact_list.%s.id
        site_id                                       = genesyscloud_telephony_providers_edges_site.%s.id
        call_analysis_response_set_id = genesyscloud_outbound_callanalysisresponseset.%s.id
        phone_columns {
                column_name = "Cell"
        }
}
%s
`, resourceId, name, campaignStatus, contactListResourceId, siteResourceId, carResourceId, referencedResources)
}</span>

func GenerateReferencedResourcesForOutboundCampaignTests(
        contactListResourceId string,
        dncListResourceId string,
        queueResourceId string,
        carResourceId string,
        outboundFlowFilePath string,
        flowResourceId string,
        flowName string,
        clfResourceId string,
        siteId string,
        emergencyNumber string,
        ruleSetId string,
        callableTimeSetResourceId string,
        divisionName string,
        locationResourceId string,
        wrapUpCodeResourceId string,
) string <span class="cov8" title="1">{
        var (
                contactList             string
                dncList                 string
                queue                   string
                callAnalysisResponseSet string
                contactListFilter       string
                site                    string
                ruleSet                 string
                callableTimeSet         string
        )
        if contactListResourceId != "" </span><span class="cov8" title="1">{
                contactList = obContactList.GenerateOutboundContactList(
                        contactListResourceId,
                        "terraform contact list "+uuid.NewString(),
                        gcloud.NullValue,
                        strconv.Quote("Cell"),
                        []string{strconv.Quote("Cell")},
                        []string{strconv.Quote("Cell"), strconv.Quote("Home"), strconv.Quote("zipcode")},
                        gcloud.FalseValue,
                        gcloud.NullValue,
                        gcloud.NullValue,
                        obContactList.GeneratePhoneColumnsBlock("Cell", "cell", strconv.Quote("Cell")),
                        obContactList.GeneratePhoneColumnsBlock("Home", "home", strconv.Quote("Home")))
        }</span>
        <span class="cov8" title="1">if dncListResourceId != "" </span><span class="cov8" title="1">{
                dncList = outbound.GenerateOutboundDncListBasic(dncListResourceId, "tf dnc list "+uuid.NewString())
        }</span>
        <span class="cov8" title="1">if queueResourceId != "" </span><span class="cov8" title="1">{
                queue = gcloud.GenerateRoutingQueueResourceBasic(queueResourceId, "tf test queue "+uuid.NewString())
        }</span>
        <span class="cov8" title="1">if carResourceId != "" </span><span class="cov8" title="1">{
                if outboundFlowFilePath != "" </span><span class="cov8" title="1">{
                        callAnalysisResponseSet = gcloud.GenerateRoutingWrapupcodeResource(
                                wrapUpCodeResourceId,
                                "wrapupcode "+uuid.NewString(),
                        ) + gcloud.GenerateFlowResource(
                                flowResourceId,
                                outboundFlowFilePath,
                                "",
                                false,
                                gcloud.GenerateSubstitutionsMap(map[string]string{
                                        "flow_name":          flowName,
                                        "home_division_name": divisionName,
                                        "contact_list_name":  "${genesyscloud_outbound_contact_list." + contactListResourceId + ".name}",
                                        "wrapup_code_name":   "${genesyscloud_routing_wrapupcode." + wrapUpCodeResourceId + ".name}",
                                }),
                        ) + outbound.GenerateOutboundCallAnalysisResponseSetResource(
                                carResourceId,
                                "tf test car "+uuid.NewString(),
                                gcloud.FalseValue,
                                outbound.GenerateCarsResponsesBlock(
                                        outbound.GenerateCarsResponse(
                                                "callable_person",
                                                "transfer_flow",
                                                flowName,
                                                "${genesyscloud_flow."+flowResourceId+".id}",
                                        ),
                                ))
                }</span> else<span class="cov8" title="1"> {
                        callAnalysisResponseSet = outbound.GenerateOutboundCallAnalysisResponseSetResource(
                                carResourceId,
                                "tf test car "+uuid.NewString(),
                                gcloud.TrueValue,
                                outbound.GenerateCarsResponsesBlock(
                                        outbound.GenerateCarsResponse(
                                                "callable_machine",
                                                "transfer",
                                                "",
                                                "",
                                        ),
                                ),
                        )
                }</span>
        }
        <span class="cov8" title="1">if clfResourceId != "" </span><span class="cov8" title="1">{
                contactListFilter = outbound.GenerateOutboundContactListFilter(
                        clfResourceId,
                        "tf test clf "+uuid.NewString(),
                        "genesyscloud_outbound_contact_list."+contactListResourceId+".id",
                        "",
                        outbound.GenerateOutboundContactListFilterClause(
                                "",
                                outbound.GenerateOutboundContactListFilterPredicates(
                                        "Cell",
                                        "alphabetic",
                                        "EQUALS",
                                        "+12345123456",
                                        "",
                                        "",
                                ),
                        ),
                )
        }</span>
        <span class="cov8" title="1">if siteId != "" </span><span class="cov8" title="1">{
                siteName := "site " + uuid.NewString()
                locationName := "location " + uuid.NewString()
                site = fmt.Sprintf(`
resource "genesyscloud_location" "%s" {
        name  = "%s"
        notes = "HQ1"
        path  = []
        emergency_number {
                number = "%s"
                type   = null
        }
        address {
                street1  = "7601 Interactive Way"
                city     = "Indianapolis"
                state    = "IN"
                country  = "US"
                zip_code = "46278"
        }
}

resource "genesyscloud_telephony_providers_edges_site" "%s" {
        name                            = "%s"
        description                     = "TestAccResourceSite description 1"
        location_id                     = genesyscloud_location.%s.id
        media_model                     = "Cloud"
        media_regions_use_latency_based = false
}
`, locationResourceId, locationName, emergencyNumber, siteId, siteName, locationResourceId)
        }</span>
        <span class="cov8" title="1">if ruleSetId != "" </span><span class="cov8" title="1">{
                ruleSetName := "ruleset " + uuid.NewString()
                ruleSet = fmt.Sprintf(`
resource "genesyscloud_outbound_ruleset" "%s" {
  name            = "%s"
  contact_list_id = genesyscloud_outbound_contact_list.%s.id
}
`, ruleSetId, ruleSetName, contactListResourceId)
        }</span>
        <span class="cov8" title="1">if callableTimeSetResourceId != "" </span><span class="cov8" title="1">{
                callableTimeSetName := "test time set " + uuid.NewString()
                callableTimeSet = fmt.Sprintf(`
resource "genesyscloud_outbound_callabletimeset" "%s"{
        name = "%s"
        callable_times {
                time_zone_id = "Africa/Abidjan"
                time_slots {
                        start_time = "07:00:00"
                        stop_time = "18:00:00"
                        day = 3
                }
        }
}
`, callableTimeSetResourceId, callableTimeSetName)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(`
%s
%s
%s
%s
%s
%s
%s
%s
`, contactList, dncList, queue, callAnalysisResponseSet, contactListFilter, site, ruleSet, callableTimeSet)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package outbound_campaignrule

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func dataSourceOutboundCampaignruleRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        name := d.Get("name").(string)

        // Query campaign rule by name. Retry in case search has not yet indexed the campaign rule.
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                campaignRules, _, getErr := outboundAPI.GetOutboundCampaignrules(pageSize, pageNum, true, "", name, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting campaign rule %s: %s", name, getErr))
                }</span>

                <span class="cov8" title="1">if campaignRules.Entities == nil || len(*campaignRules.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no campaign rules found with name %s", name))
                }</span>

                <span class="cov8" title="1">campaignRule := (*campaignRules.Entities)[0]
                d.SetId(*campaignRule.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package outbound_campaignrule

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundCampaignRuleEntityCampaignRuleId = &amp;schema.Schema{
                Description: `The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. Changing the outboundCampaignRuleEntityCampaignRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.`,
                Optional:    true,
                ForceNew:    true,
                Type:        schema.TypeList,
                Elem:        &amp;schema.Schema{Type: schema.TypeString},
        }

        outboundCampaignRuleEntitySequenceRuleId = &amp;schema.Schema{
                Description: `The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. Changing the outboundCampaignRuleEntitySequenceRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.`,
                Optional:    true,
                ForceNew:    true,
                Type:        schema.TypeList,
                Elem:        &amp;schema.Schema{Type: schema.TypeString},
        }

        outboundCampaignRuleEntities = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `campaign_ids`: outboundCampaignRuleEntityCampaignRuleId,
                        `sequence_ids`: outboundCampaignRuleEntitySequenceRuleId,
                },
        }

        outboundCampaignRuleActionEntities = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `campaign_ids`: outboundCampaignRuleEntityCampaignRuleId,
                        `sequence_ids`: outboundCampaignRuleEntitySequenceRuleId,
                        `use_triggering_entity`: {
                                Description: `If true, the CampaignRuleAction will apply to the same entity that triggered the CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                                Default:     false,
                        },
                },
        }

        campaignRuleParameters = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `operator`: {
                                Description:  `The operator for comparison. Required for a CampaignRuleCondition.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"equals", "greaterThan", "greaterThanEqualTo", "lessThan", "lessThanEqualTo"}, true),
                        },
                        `value`: {
                                Description: `The value for comparison. Required for a CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `priority`: {
                                Description:  `The priority to set a campaign to (1 | 2 | 3 | 4 | 5). Required for the 'setCampaignPriority' action.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"1", "2", "3", "4", "5"}, true),
                        },
                        `dialing_mode`: {
                                Description:  `The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action (agentless | preview | power | predictive | progressive | external).`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"agentless", "preview", "power", "predictive", "progressive", "external"}, true),
                        },
                },
        }

        outboundCampaignRuleCondition = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `id`: {
                                Description: `The ID of the CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `parameters`: {
                                Description: `The parameters for the CampaignRuleCondition.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        campaignRuleParameters,
                        },
                        `condition_type`: {
                                Description:  `The type of condition to evaluate (campaignProgress | campaignAgents).`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"campaignProgress", "campaignAgents"}, true),
                        },
                },
        }

        outboundCampaignRuleAction = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `id`: {
                                Description: `The ID of the CampaignRuleAction.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `parameters`: {
                                Description: `The parameters for the CampaignRuleAction. Required for certain actionTypes.`,
                                Optional:    true,
                                Type:        schema.TypeSet,
                                Elem:        campaignRuleParameters,
                        },
                        `action_type`: {
                                Description: `The action to take on the campaignRuleActionEntities
(turnOnCampaign | turnOffCampaign | turnOnSequence | turnOffSequence | setCampaignPriority | recycleCampaign | setCampaignDialingMode).`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"turnOnCampaign", "turnOffCampaign", "turnOnSequence", "turnOffSequence", "setCampaignPriority", "recycleCampaign", "setCampaignDialingMode"}, true),
                        },
                        `campaign_rule_action_entities`: {
                                Description: `The list of entities that this action will apply to.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundCampaignRuleActionEntities,
                        },
                },
        }
)

func getAllAuthCampaignRules(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                campaignRuleConfigs, _, getErr := outboundAPI.GetOutboundCampaignrules(pageSize, pageNum, true, "", "", "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of campaign rule configs: %v", getErr)
                }</span>

                <span class="cov0" title="0">if campaignRuleConfigs.Entities == nil || len(*campaignRuleConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, campaignRuleConfig := range *campaignRuleConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*campaignRuleConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *campaignRuleConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func ResourceOutboundCampaignRule() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound campaign rule`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundCampaignRule),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundCampaignRule),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundCampaignRule),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundCampaignRule),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the campaign rule.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `campaign_rule_entities`: {
                                Description: `The list of entities that this campaign rule monitors.`,
                                Required:    true,
                                MaxItems:    1,
                                Type:        schema.TypeSet,
                                Elem:        outboundCampaignRuleEntities,
                        },
                        `campaign_rule_conditions`: {
                                Description: `The list of conditions that are evaluated on the entities.`,
                                Required:    true,
                                MinItems:    1,
                                Type:        schema.TypeList,
                                Elem:        outboundCampaignRuleCondition,
                        },
                        `campaign_rule_actions`: {
                                Description: `The list of actions that are executed if the conditions are satisfied.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundCampaignRuleAction,
                        },
                        `match_any_conditions`: {
                                Description: `Whether actions are executed if any condition is met, or only when all conditions are met.`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                        `enabled`: {
                                Description: `Whether or not this campaign rule is currently enabled.`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                },
        }
}</span>

func createOutboundCampaignRule(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        matchAnyConditions := d.Get("match_any_conditions").(bool)
        enabled := d.Get("enabled").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        campaignRuleEntities := d.Get("campaign_rule_entities").(*schema.Set)
        campaignRuleConditions := d.Get("campaign_rule_conditions").([]interface{})
        campaignRuleActions := d.Get("campaign_rule_actions").([]interface{})

        sdkCampaignRule := platformclientv2.Campaignrule{
                CampaignRuleEntities:   buildOutboundCampaignRuleEntities(campaignRuleEntities),
                CampaignRuleConditions: buildOutboundCampaignRuleConditionSlice(campaignRuleConditions),
                CampaignRuleActions:    buildOutboundCampaignRuleActionSlice(campaignRuleActions),
                MatchAnyConditions:     &amp;matchAnyConditions,
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkCampaignRule.Name = &amp;name
        }</span>

        // All campaign rules have to be created in an "off" state to start out with
        <span class="cov8" title="1">defaultStatus := false
        sdkCampaignRule.Enabled = &amp;defaultStatus

        log.Printf("Creating Outbound Campaign Rule %s", name)
        outboundCampaignRule, _, err := outboundApi.PostOutboundCampaignrules(sdkCampaignRule)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Campaign Rule %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundCampaignRule.Id)
        log.Printf("Created Outbound Campaign Rule %s %s", name, *outboundCampaignRule.Id)

        // Campaign rules can be enabled after creation
        if enabled </span><span class="cov8" title="1">{
                d.Set("enabled", enabled)
                diag := updateOutboundCampaignRule(ctx, d, meta)
                if diag != nil </span><span class="cov0" title="0">{
                        return diag
                }</span>
        }

        <span class="cov8" title="1">return readOutboundCampaignRule(ctx, d, meta)</span>
}

func updateOutboundCampaignRule(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        matchAnyConditions := d.Get("match_any_conditions").(bool)

        // Required on updates
        enabled := d.Get("enabled").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkCampaignRule := platformclientv2.Campaignrule{
                CampaignRuleEntities:   buildOutboundCampaignRuleEntities(d.Get("campaign_rule_entities").(*schema.Set)),
                CampaignRuleConditions: buildOutboundCampaignRuleConditionSlice(d.Get("campaign_rule_conditions").([]interface{})),
                CampaignRuleActions:    buildOutboundCampaignRuleActionSlice(d.Get("campaign_rule_actions").([]interface{})),
                MatchAnyConditions:     &amp;matchAnyConditions,
                Enabled:                &amp;enabled,
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkCampaignRule.Name = &amp;name
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Campaign Rule %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Campaign Rule version
                outboundCampaignRule, resp, getErr := outboundApi.GetOutboundCampaignrule(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Campaign Rule %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkCampaignRule.Version = outboundCampaignRule.Version
                outboundCampaignRule, _, updateErr := outboundApi.PutOutboundCampaignrule(d.Id(), sdkCampaignRule)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Campaign Rule %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Campaign Rule %s", name)
        return readOutboundCampaignRule(ctx, d, meta)</span>
}

func readOutboundCampaignRule(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Campaign Rule %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkCampaignRule, resp, getErr := outboundApi.GetOutboundCampaignrule(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound Campaign Rule %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound Campaign Rule %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundCampaignRule())

                if sdkCampaignRule.Name != nil </span><span class="cov8" title="1">{
                        d.Set("name", *sdkCampaignRule.Name)
                }</span>
                <span class="cov8" title="1">if sdkCampaignRule.CampaignRuleEntities != nil </span><span class="cov8" title="1">{
                        d.Set("campaign_rule_entities", flattenOutboundCampaignRuleEntities(sdkCampaignRule.CampaignRuleEntities))
                }</span>
                <span class="cov8" title="1">if sdkCampaignRule.CampaignRuleConditions != nil </span><span class="cov8" title="1">{
                        d.Set("campaign_rule_conditions", flattenOutboundCampaignRuleConditionSlice(*sdkCampaignRule.CampaignRuleConditions))
                }</span>
                <span class="cov8" title="1">if sdkCampaignRule.CampaignRuleActions != nil </span><span class="cov8" title="1">{
                        d.Set("campaign_rule_actions", flattenOutboundCampaignRuleActionSlice(sdkCampaignRule.CampaignRuleActions))
                }</span>
                <span class="cov8" title="1">if sdkCampaignRule.MatchAnyConditions != nil </span><span class="cov8" title="1">{
                        d.Set("match_any_conditions", *sdkCampaignRule.MatchAnyConditions)
                }</span>
                <span class="cov8" title="1">if sdkCampaignRule.Enabled != nil </span><span class="cov8" title="1">{
                        d.Set("enabled", *sdkCampaignRule.Enabled)
                }</span>

                <span class="cov8" title="1">log.Printf("Read Outbound Campaign Rule %s %s", d.Id(), *sdkCampaignRule.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundCampaignRule(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        ruleEnabled := d.Get("enabled").(bool)
        if ruleEnabled </span><span class="cov0" title="0">{
                // Have to disable rule before we can delete
                log.Printf("Disabling Outbound Campaign Rule")
                d.Set("enabled", false)
                diagErr := updateOutboundCampaignRule(ctx, d, meta)
                if diagErr != nil </span><span class="cov0" title="0">{
                        return diagErr
                }</span>
        }

        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Campaign Rule")
                resp, err := outboundApi.DeleteOutboundCampaignrule(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Campaign Rule: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundCampaignrule(d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Campaign Rule deleted
                                log.Printf("Deleted Outbound Campaign Rule %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound Campaign Rule %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Campaign Rule %s still exists", d.Id()))</span>
        })
}

func buildOutboundCampaignRuleEntities(entities *schema.Set) *platformclientv2.Campaignruleentities <span class="cov8" title="1">{
        if entities == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var campaignRuleEntities platformclientv2.Campaignruleentities

        campaignRuleEntitiesList := entities.List()

        if len(campaignRuleEntitiesList) &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;campaignRuleEntities
        }</span>

        <span class="cov8" title="1">campaignRuleEntitiesMap := campaignRuleEntitiesList[0].(map[string]interface{})
        if campaigns := campaignRuleEntitiesMap["campaign_ids"].([]interface{}); campaigns != nil </span><span class="cov8" title="1">{
                campaignRuleEntities.Campaigns = gcloud.BuildSdkDomainEntityRefArrFromArr(campaigns)
        }</span>
        <span class="cov8" title="1">if sequences := campaignRuleEntitiesMap["sequence_ids"].([]interface{}); sequences != nil </span><span class="cov8" title="1">{
                campaignRuleEntities.Sequences = gcloud.BuildSdkDomainEntityRefArrFromArr(sequences)
        }</span>

        <span class="cov8" title="1">return &amp;campaignRuleEntities</span>
}

func buildOutboundCampaignRuleConditionSlice(campaignRuleConditions []interface{}) *[]platformclientv2.Campaignrulecondition <span class="cov8" title="1">{
        var campaignRuleConditionRefs []platformclientv2.Campaignrulecondition

        for _, c := range campaignRuleConditions </span><span class="cov8" title="1">{
                sdkCondition := platformclientv2.Campaignrulecondition{}
                currentCondition := c.(map[string]interface{})
                id := currentCondition["id"].(string)
                conditionType := currentCondition["condition_type"].(string)

                sdkCondition.Parameters = buildOutboundCampaignRuleParameters(currentCondition["parameters"].(*schema.Set))

                if id != "" </span><span class="cov0" title="0">{
                        sdkCondition.Id = &amp;id
                }</span>

                <span class="cov8" title="1">if conditionType != "" </span><span class="cov8" title="1">{
                        sdkCondition.ConditionType = &amp;conditionType
                }</span>

                <span class="cov8" title="1">campaignRuleConditionRefs = append(campaignRuleConditionRefs, sdkCondition)</span>
        }

        <span class="cov8" title="1">return &amp;campaignRuleConditionRefs</span>
}

func buildOutboundCampaignRuleActionSlice(campaignRuleActions []interface{}) *[]platformclientv2.Campaignruleaction <span class="cov8" title="1">{
        var sdkCampaignRuleActions []platformclientv2.Campaignruleaction

        for _, c := range campaignRuleActions </span><span class="cov8" title="1">{
                var sdkCampaignRuleAction platformclientv2.Campaignruleaction
                currentAction := c.(map[string]interface{})

                id := currentAction["id"].(string)
                actionType := currentAction["action_type"].(string)

                sdkCampaignRuleAction.Id = &amp;id
                sdkCampaignRuleAction.ActionType = &amp;actionType

                sdkCampaignRuleAction.Parameters = buildOutboundCampaignRuleParameters(currentAction["parameters"].(*schema.Set))

                sdkCampaignRuleAction.CampaignRuleActionEntities = buildOutboundCampaignRuleActionEntities(currentAction["campaign_rule_action_entities"].(*schema.Set))

                sdkCampaignRuleActions = append(sdkCampaignRuleActions, sdkCampaignRuleAction)
        }</span>

        <span class="cov8" title="1">return &amp;sdkCampaignRuleActions</span>
}

func buildOutboundCampaignRuleParameters(set *schema.Set) *platformclientv2.Campaignruleparameters <span class="cov8" title="1">{
        var sdkCampaignRuleParameters platformclientv2.Campaignruleparameters

        paramsList := set.List()

        if len(paramsList) &lt;= 0 </span><span class="cov8" title="1">{
                return &amp;sdkCampaignRuleParameters
        }</span>

        <span class="cov8" title="1">paramsMap := paramsList[0].(map[string]interface{})

        operator := paramsMap["operator"].(string)
        paramValue := paramsMap["value"].(string)
        priority := paramsMap["priority"].(string)
        dialingMode := paramsMap["dialing_mode"].(string)

        if paramValue != "" </span><span class="cov8" title="1">{
                sdkCampaignRuleParameters.Value = &amp;paramValue
        }</span>

        <span class="cov8" title="1">if priority != "" </span><span class="cov8" title="1">{
                sdkCampaignRuleParameters.Priority = &amp;priority
        }</span>

        <span class="cov8" title="1">if dialingMode != "" </span><span class="cov8" title="1">{
                sdkCampaignRuleParameters.DialingMode = &amp;dialingMode
        }</span>

        <span class="cov8" title="1">if operator != "" </span><span class="cov8" title="1">{
                sdkCampaignRuleParameters.Operator = &amp;operator
        }</span>

        <span class="cov8" title="1">return &amp;sdkCampaignRuleParameters</span>
}

func buildOutboundCampaignRuleActionEntities(set *schema.Set) *platformclientv2.Campaignruleactionentities <span class="cov8" title="1">{
        var (
                sdkCampaignRuleActionEntities platformclientv2.Campaignruleactionentities
                entities                      = set.List()
        )

        if len(entities) &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;sdkCampaignRuleActionEntities
        }</span>

        <span class="cov8" title="1">entitiesMap := entities[0].(map[string]interface{})
        useTriggeringEntity := entitiesMap["use_triggering_entity"].(bool)

        sdkCampaignRuleActionEntities.UseTriggeringEntity = &amp;useTriggeringEntity

        if campaignIds := entitiesMap["campaign_ids"].([]interface{}); campaignIds != nil </span><span class="cov8" title="1">{
                sdkCampaignRuleActionEntities.Campaigns = gcloud.BuildSdkDomainEntityRefArrFromArr(campaignIds)
        }</span>

        <span class="cov8" title="1">if sequenceIds := entitiesMap["sequence_ids"].([]interface{}); sequenceIds != nil </span><span class="cov8" title="1">{
                sdkCampaignRuleActionEntities.Sequences = gcloud.BuildSdkDomainEntityRefArrFromArr(sequenceIds)
        }</span>

        <span class="cov8" title="1">return &amp;sdkCampaignRuleActionEntities</span>
}

func flattenOutboundCampaignRuleEntities(campaignRuleEntities *platformclientv2.Campaignruleentities) *schema.Set <span class="cov8" title="1">{
        var (
                campaignRuleEntitiesSet = schema.NewSet(schema.HashResource(outboundCampaignRuleEntities), []interface{}{})
                campaignRuleEntitiesMap = make(map[string]interface{})

                // had to change from []string to []interface{}
                campaigns []interface{}
                sequences []interface{}
        )

        if campaignRuleEntities == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if campaignRuleEntities.Campaigns != nil </span><span class="cov8" title="1">{
                for _, v := range *campaignRuleEntities.Campaigns </span><span class="cov8" title="1">{
                        campaigns = append(campaigns, *v.Id)
                }</span>
        }

        <span class="cov8" title="1">if campaignRuleEntities.Sequences != nil </span><span class="cov8" title="1">{
                for _, v := range *campaignRuleEntities.Sequences </span><span class="cov8" title="1">{
                        sequences = append(sequences, *v.Id)
                }</span>
        }

        <span class="cov8" title="1">campaignRuleEntitiesMap["campaign_ids"] = campaigns
        campaignRuleEntitiesMap["sequence_ids"] = sequences

        campaignRuleEntitiesSet.Add(campaignRuleEntitiesMap)
        return campaignRuleEntitiesSet</span>
}

func flattenOutboundCampaignRuleConditionSlice(campaignRuleConditions []platformclientv2.Campaignrulecondition) []interface{} <span class="cov8" title="1">{
        if campaignRuleConditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var ruleConditionList []interface{}

        for _, currentSdkCondition := range campaignRuleConditions </span><span class="cov8" title="1">{
                campaignRuleConditionsMap := make(map[string]interface{})

                if currentSdkCondition.ConditionType != nil </span><span class="cov8" title="1">{
                        campaignRuleConditionsMap["condition_type"] = *currentSdkCondition.ConditionType
                }</span>

                <span class="cov8" title="1">if currentSdkCondition.Parameters != nil </span><span class="cov8" title="1">{
                        campaignRuleConditionsMap["parameters"] = flattenRuleParameters(*currentSdkCondition.Parameters)
                }</span>

                <span class="cov8" title="1">ruleConditionList = append(ruleConditionList, campaignRuleConditionsMap)</span>
        }
        <span class="cov8" title="1">return ruleConditionList</span>
}

func flattenOutboundCampaignRuleActionSlice(campaignRuleActions *[]platformclientv2.Campaignruleaction) []interface{} <span class="cov8" title="1">{
        if campaignRuleActions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var ruleActionsList []interface{}

        for _, currentAction := range *campaignRuleActions </span><span class="cov8" title="1">{
                actionMap := make(map[string]interface{})

                if currentAction.Id != nil </span><span class="cov8" title="1">{
                        actionMap["id"] = *currentAction.Id
                }</span>

                <span class="cov8" title="1">if currentAction.ActionType != nil </span><span class="cov8" title="1">{
                        actionMap["action_type"] = *currentAction.ActionType
                }</span>

                <span class="cov8" title="1">if currentAction.Parameters != nil </span><span class="cov8" title="1">{
                        actionMap["parameters"] = flattenRuleParameters(*currentAction.Parameters)
                }</span>

                <span class="cov8" title="1">if currentAction.CampaignRuleActionEntities != nil </span><span class="cov8" title="1">{
                        actionMap["campaign_rule_action_entities"] = flattenCampaignRuleActionEntities(currentAction.CampaignRuleActionEntities)
                }</span>

                <span class="cov8" title="1">ruleActionsList = append(ruleActionsList, actionMap)</span>
        }

        <span class="cov8" title="1">return ruleActionsList</span>
}

func flattenCampaignRuleActionEntities(sdkActionEntity *platformclientv2.Campaignruleactionentities) *schema.Set <span class="cov8" title="1">{
        var (
                campaigns   []interface{}
                sequences   []interface{}
                entitiesSet = schema.NewSet(schema.HashResource(outboundCampaignRuleActionEntities), []interface{}{})
                entitiesMap = make(map[string]interface{})
        )

        if sdkActionEntity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if sdkActionEntity.Campaigns != nil </span><span class="cov8" title="1">{
                for _, campaign := range *sdkActionEntity.Campaigns </span><span class="cov8" title="1">{
                        campaigns = append(campaigns, *campaign.Id)
                }</span>
        }

        <span class="cov8" title="1">if sdkActionEntity.Sequences != nil </span><span class="cov8" title="1">{
                for _, sequence := range *sdkActionEntity.Sequences </span><span class="cov8" title="1">{
                        sequences = append(sequences, *sequence.Id)
                }</span>
        }

        <span class="cov8" title="1">entitiesMap["campaign_ids"] = campaigns
        entitiesMap["sequence_ids"] = sequences
        entitiesMap["use_triggering_entity"] = *sdkActionEntity.UseTriggeringEntity

        entitiesSet.Add(entitiesMap)
        return entitiesSet</span>
}

func flattenRuleParameters(sdkParams platformclientv2.Campaignruleparameters) []interface{} <span class="cov8" title="1">{
        paramsMap := make(map[string]interface{})

        if sdkParams.Operator != nil </span><span class="cov8" title="1">{
                paramsMap["operator"] = *sdkParams.Operator
        }</span>

        <span class="cov8" title="1">if sdkParams.Value != nil </span><span class="cov8" title="1">{
                paramsMap["value"] = *sdkParams.Value
        }</span>

        <span class="cov8" title="1">if sdkParams.Priority != nil </span><span class="cov8" title="1">{
                paramsMap["priority"] = *sdkParams.Priority
        }</span>

        <span class="cov8" title="1">if sdkParams.DialingMode != nil </span><span class="cov8" title="1">{
                paramsMap["dialing_mode"] = *sdkParams.DialingMode
        }</span>

        <span class="cov8" title="1">return []interface{}{paramsMap}</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package outbound_campaignrule

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_outbound_campaignrule_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the outbound_campaignrule resource.
3.  The datasource schema definitions for the outbound_campaignrule datasource.
4.  The resource exporter configuration for the outbound_campaignrule exporter.
*/
const resourceName = "genesyscloud_outbound_campaignrule"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceOutboundCampaignrule())
        regInstance.RegisterDataSource(resourceName, DataSourceOutboundCampaignrule())
        regInstance.RegisterExporter(resourceName, OutboundCampaignruleExporter())
}</span>

// ResourceOutboundCampaignrule registers the genesyscloud_outbound_campaignrule resource with Terraform
func ResourceOutboundCampaignrule() *schema.Resource <span class="cov8" title="1">{
        outboundCampaignRuleEntityCampaignRuleId = &amp;schema.Schema{
                Description: `The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. Changing the outboundCampaignRuleEntityCampaignRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.`,
                Optional:    true,
                ForceNew:    true,
                Type:        schema.TypeList,
                Elem:        &amp;schema.Schema{Type: schema.TypeString},
        }

        outboundCampaignRuleEntitySequenceRuleId = &amp;schema.Schema{
                Description: `The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. Changing the outboundCampaignRuleEntitySequenceRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.`,
                Optional:    true,
                ForceNew:    true,
                Type:        schema.TypeList,
                Elem:        &amp;schema.Schema{Type: schema.TypeString},
        }

        outboundCampaignRuleEntities = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `campaign_ids`: outboundCampaignRuleEntityCampaignRuleId,
                        `sequence_ids`: outboundCampaignRuleEntitySequenceRuleId,
                },
        }

        outboundCampaignRuleActionEntities = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `campaign_ids`: outboundCampaignRuleEntityCampaignRuleId,
                        `sequence_ids`: outboundCampaignRuleEntitySequenceRuleId,
                        `use_triggering_entity`: {
                                Description: `If true, the CampaignRuleAction will apply to the same entity that triggered the CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                                Default:     false,
                        },
                },
        }

        campaignRuleParameters = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `operator`: {
                                Description:  `The operator for comparison. Required for a CampaignRuleCondition.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"equals", "greaterThan", "greaterThanEqualTo", "lessThan", "lessThanEqualTo"}, true),
                        },
                        `value`: {
                                Description: `The value for comparison. Required for a CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `priority`: {
                                Description:  `The priority to set a campaign to (1 | 2 | 3 | 4 | 5). Required for the 'setCampaignPriority' action.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"1", "2", "3", "4", "5"}, true),
                        },
                        `dialing_mode`: {
                                Description:  `The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action (agentless | preview | power | predictive | progressive | external).`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"agentless", "preview", "power", "predictive", "progressive", "external"}, true),
                        },
                },
        }

        outboundCampaignRuleCondition = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `id`: {
                                Description: `The ID of the CampaignRuleCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `parameters`: {
                                Description: `The parameters for the CampaignRuleCondition.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        campaignRuleParameters,
                        },
                        `condition_type`: {
                                Description:  `The type of condition to evaluate (campaignProgress | campaignAgents).`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"campaignProgress", "campaignAgents"}, true),
                        },
                },
        }

        outboundCampaignRuleAction = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `id`: {
                                Description: `The ID of the CampaignRuleAction.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `parameters`: {
                                Description: `The parameters for the CampaignRuleAction. Required for certain actionTypes.`,
                                Optional:    true,
                                Type:        schema.TypeSet,
                                Elem:        campaignRuleParameters,
                        },
                        `action_type`: {
                                Description: `The action to take on the campaignRuleActionEntities
(turnOnCampaign | turnOffCampaign | turnOnSequence | turnOffSequence | setCampaignPriority | recycleCampaign | setCampaignDialingMode).`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"turnOnCampaign", "turnOffCampaign", "turnOnSequence", "turnOffSequence", "setCampaignPriority", "recycleCampaign", "setCampaignDialingMode"}, true),
                        },
                        `campaign_rule_action_entities`: {
                                Description: `The list of entities that this action will apply to.`,
                                Required:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundCampaignRuleActionEntities,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound campaign rule`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundCampaignRule),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundCampaignRule),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundCampaignRule),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundCampaignRule),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the campaign rule.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `campaign_rule_entities`: {
                                Description: `The list of entities that this campaign rule monitors.`,
                                Required:    true,
                                MaxItems:    1,
                                Type:        schema.TypeSet,
                                Elem:        outboundCampaignRuleEntities,
                        },
                        `campaign_rule_conditions`: {
                                Description: `The list of conditions that are evaluated on the entities.`,
                                Required:    true,
                                MinItems:    1,
                                Type:        schema.TypeList,
                                Elem:        outboundCampaignRuleCondition,
                        },
                        `campaign_rule_actions`: {
                                Description: `The list of actions that are executed if the conditions are satisfied.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundCampaignRuleAction,
                        },
                        `match_any_conditions`: {
                                Description: `Whether actions are executed if any condition is met, or only when all conditions are met.`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                        `enabled`: {
                                Description: `Whether or not this campaign rule is currently enabled.`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                },
        }
}</span>

// OutboundCampaignruleExporter returns the resourceExporter object used to hold the genesyscloud_outbound_campaignrule exporter's config
func OutboundCampaignruleExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthCampaignRules),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        `campaign_rule_actions.campaign_rule_action_entities.campaign_ids`: {
                                RefType: "genesyscloud_outbound_campaign",
                        },
                        `campaign_rule_actions.campaign_rule_action_entities.sequence_ids`: {
                                RefType: "genesyscloud_outbound_sequence",
                        },
                        `campaign_rule_entities.campaign_ids`: {
                                RefType: "genesyscloud_outbound_campaign",
                        },
                        `campaign_rule_entities.sequence_ids`: {
                                RefType: "genesyscloud_outbound_sequence",
                        },
                },
        }
}</span>

// DataSourceOutboundCampaignrule registers the genesyscloud_outbound_campaignrule data source
func DataSourceOutboundCampaignrule() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound campaign rule data source. Select a campaign rule by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundCampaignruleRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Campaign Rule name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package outbound_contact_list

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func DataSourceOutboundContactList() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Outbound Contact Lists. Select a contact list by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundContactListRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Contact List name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceOutboundContactListRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(sdkConfig)
        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                const pageNum = 1
                const pageSize = 100
                contactLists, _, getErr := outboundAPI.GetOutboundContactlists(false, false, pageSize, pageNum, true, "", name, []string{""}, []string{""}, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting contact list %s: %s", name, getErr))
                }</span>
                <span class="cov8" title="1">if contactLists.Entities == nil || len(*contactLists.Entities) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no contact lists found with name %s", name))
                }</span>
                <span class="cov8" title="1">contactList := (*contactLists.Entities)[0]
                d.SetId(*contactList.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package outbound_contact_list

import (
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterDataSource("genesyscloud_outbound_contact_list", DataSourceOutboundContactList())
        regInstance.RegisterResource("genesyscloud_outbound_contact_list", ResourceOutboundContactList())
        regInstance.RegisterExporter("genesyscloud_outbound_contact_list", OutboundContactListExporter())
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package outbound_contact_list

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        outboundContactListContactPhoneNumberColumnResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `column_name`: {
                                Description: `The name of the phone column.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `type`: {
                                Description: `Indicates the type of the phone column. For example, 'cell' or 'home'.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `callable_time_column`: {
                                Description: `A column that indicates the timezone to use for a given contact when checking callable times. Not allowed if 'automaticTimeZoneMapping' is set to true.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }

        outboundContactListEmailColumnResource = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `column_name`: {
                                Description: `The name of the email column.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `type`: {
                                Description: `Indicates the type of the email column. For example, 'work' or 'personal'.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `contactable_time_column`: {
                                Description: `A column that indicates the timezone to use for a given contact when checking contactable times.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }

        outboundContactListColumnDataTypeSpecification = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `column_name`: {
                                Description: `The column name of a column selected for dynamic queueing.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `column_data_type`: {
                                Description:  `The data type of the column selected for dynamic queueing (TEXT, NUMERIC or TIMESTAMP)`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{"TEXT", "NUMERIC", "TIMESTAMP"}, false),
                        },
                        `min`: {
                                Description: `The minimum length of the numeric column selected for dynamic queueing.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `max`: {
                                Description: `The maximum length of the numeric column selected for dynamic queueing.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `max_length`: {
                                Description: `The maximum length of the text column selected for dynamic queueing.`,
                                Required:    true,
                                Type:        schema.TypeInt,
                        },
                },
        }
)

func getAllOutboundContactLists(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        outboundAPI := platformclientv2.NewOutboundApiWithConfig(clientConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                contactListConfigs, _, getErr := outboundAPI.GetOutboundContactlists(false, false, pageSize, pageNum, true, "", "", []string{}, []string{}, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("Failed to get page of contact list configs: %v", getErr)
                }</span>

                <span class="cov0" title="0">if contactListConfigs.Entities == nil || len(*contactListConfigs.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, contactListConfig := range *contactListConfigs.Entities </span><span class="cov0" title="0">{
                        resources[*contactListConfig.Id] = &amp;resourceExporter.ResourceMeta{Name: *contactListConfig.Name}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func OutboundContactListExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllOutboundContactLists),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "attempt_limit_id": {RefType: "genesyscloud_outbound_attempt_limit"},
                        "division_id":      {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

func ResourceOutboundContactList() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Outbound Contact List`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundContactList),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundContactList),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundContactList),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundContactList),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name for the contact list.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `division_id`: {
                                Description: `The division this entity belongs to.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                        },
                        `column_names`: {
                                Description: `The names of the contact data columns. Changing the column_names attribute will cause the outboundcontact_list object to be dropped and recreated with a new ID`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `phone_columns`: {
                                Description: `Indicates which columns are phone numbers. Changing the phone_columns attribute will cause the outboundcontact_list object to be dropped and recreated with a new ID. Required if email_columns is empty`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundContactListContactPhoneNumberColumnResource,
                        },
                        `email_columns`: {
                                Description: `Indicates which columns are email addresses. Changing the email_columns attribute will cause the outboundcontact_list object to be dropped and recreated with a new ID. Required if phone_columns is empty`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeSet,
                                Elem:        outboundContactListEmailColumnResource,
                        },
                        `preview_mode_column_name`: {
                                Description: `A column to check if a contact should always be dialed in preview mode.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `preview_mode_accepted_values`: {
                                Description: `The values in the previewModeColumnName column that indicate a contact should always be dialed in preview mode.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `attempt_limit_id`: {
                                Description: `Attempt Limit for this ContactList.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `automatic_time_zone_mapping`: {
                                Description: `Indicates if automatic time zone mapping is to be used for this ContactList. Changing the automatic_time_zone_mappings attribute will cause the outboundcontact_list object to be dropped and recreated with a new ID`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeBool,
                        },
                        `zip_code_column_name`: {
                                Description: `The name of contact list column containing the zip code for use with automatic time zone mapping. Only allowed if 'automaticTimeZoneMapping' is set to true. Changing the zip_code_column_name attribute will cause the outboundcontact_list object to be dropped and recreated with a new ID`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `column_data_type_specifications`: {
                                Description: `The settings of the columns selected for dynamic queueing. If updated, the contact list is dropped and recreated with a new ID`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundContactListColumnDataTypeSpecification,
                        },
                },
        }
}</span>

func createOutboundContactList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        columnNames := lists.InterfaceListToStrings(d.Get("column_names").([]interface{}))
        previewModeColumnName := d.Get("preview_mode_column_name").(string)
        previewModeAcceptedValues := lists.InterfaceListToStrings(d.Get("preview_mode_accepted_values").([]interface{}))
        automaticTimeZoneMapping := d.Get("automatic_time_zone_mapping").(bool)
        zipCodeColumnName := d.Get("zip_code_column_name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkContactList := platformclientv2.Contactlist{
                Division:                     gcloud.BuildSdkDomainEntityRef(d, "division_id"),
                ColumnNames:                  &amp;columnNames,
                PhoneColumns:                 buildSdkOutboundContactListContactPhoneNumberColumnSlice(d.Get("phone_columns").(*schema.Set)),
                EmailColumns:                 buildSdkOutboundContactListContactEmailAddressColumnSlice(d.Get("email_columns").(*schema.Set)),
                PreviewModeAcceptedValues:    &amp;previewModeAcceptedValues,
                AttemptLimits:                gcloud.BuildSdkDomainEntityRef(d, "attempt_limit_id"),
                AutomaticTimeZoneMapping:     &amp;automaticTimeZoneMapping,
                ColumnDataTypeSpecifications: buildSdkOutboundContactListColumnDataTypeSpecifications(d.Get("column_data_type_specifications").([]interface{})),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkContactList.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if previewModeColumnName != "" </span><span class="cov8" title="1">{
                sdkContactList.PreviewModeColumnName = &amp;previewModeColumnName
        }</span>
        <span class="cov8" title="1">if zipCodeColumnName != "" </span><span class="cov8" title="1">{
                sdkContactList.ZipCodeColumnName = &amp;zipCodeColumnName
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Outbound Contact List %s", name)
        outboundContactList, _, err := outboundApi.PostOutboundContactlists(sdkContactList)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create Outbound Contact List %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*outboundContactList.Id)

        log.Printf("Created Outbound Contact List %s %s", name, *outboundContactList.Id)
        return readOutboundContactList(ctx, d, meta)</span>
}

func updateOutboundContactList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        columnNames := lists.InterfaceListToStrings(d.Get("column_names").([]interface{}))
        previewModeColumnName := d.Get("preview_mode_column_name").(string)
        previewModeAcceptedValues := lists.InterfaceListToStrings(d.Get("preview_mode_accepted_values").([]interface{}))
        automaticTimeZoneMapping := d.Get("automatic_time_zone_mapping").(bool)
        zipCodeColumnName := d.Get("zip_code_column_name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        sdkContactList := platformclientv2.Contactlist{
                Division:                     gcloud.BuildSdkDomainEntityRef(d, "division_id"),
                ColumnNames:                  &amp;columnNames,
                PhoneColumns:                 buildSdkOutboundContactListContactPhoneNumberColumnSlice(d.Get("phone_columns").(*schema.Set)),
                EmailColumns:                 buildSdkOutboundContactListContactEmailAddressColumnSlice(d.Get("email_columns").(*schema.Set)),
                PreviewModeAcceptedValues:    &amp;previewModeAcceptedValues,
                AttemptLimits:                gcloud.BuildSdkDomainEntityRef(d, "attempt_limit_id"),
                AutomaticTimeZoneMapping:     &amp;automaticTimeZoneMapping,
                ColumnDataTypeSpecifications: buildSdkOutboundContactListColumnDataTypeSpecifications(d.Get("column_data_type_specifications").([]interface{})),
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkContactList.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if previewModeColumnName != "" </span><span class="cov8" title="1">{
                sdkContactList.PreviewModeColumnName = &amp;previewModeColumnName
        }</span>
        <span class="cov8" title="1">if zipCodeColumnName != "" </span><span class="cov0" title="0">{
                sdkContactList.ZipCodeColumnName = &amp;zipCodeColumnName
        }</span>

        <span class="cov8" title="1">log.Printf("Updating Outbound Contact List %s", name)
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current Outbound Contact list version
                outboundContactList, resp, getErr := outboundApi.GetOutboundContactlist(d.Id(), false, false)
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read Outbound Contact List %s: %s", d.Id(), getErr)
                }</span>
                <span class="cov8" title="1">sdkContactList.Version = outboundContactList.Version
                outboundContactList, _, updateErr := outboundApi.PutOutboundContactlist(d.Id(), sdkContactList)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update Outbound Contact List %s: %s", name, updateErr)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Contact List %s", name)
        return readOutboundContactList(ctx, d, meta)</span>
}

func readOutboundContactList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        log.Printf("Reading Outbound Contact List %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkContactList, resp, getErr := outboundApi.GetOutboundContactlist(d.Id(), false, false)
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read Outbound Contact List %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read Outbound Contact List %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundContactList())

                if sdkContactList.Name != nil </span><span class="cov8" title="1">{
                        _ = d.Set("name", *sdkContactList.Name)
                }</span>
                <span class="cov8" title="1">if sdkContactList.Division != nil &amp;&amp; sdkContactList.Division.Id != nil </span><span class="cov8" title="1">{
                        _ = d.Set("division_id", *sdkContactList.Division.Id)
                }</span>
                <span class="cov8" title="1">if sdkContactList.ColumnNames != nil </span><span class="cov8" title="1">{
                        var columnNames []string
                        for _, name := range *sdkContactList.ColumnNames </span><span class="cov8" title="1">{
                                columnNames = append(columnNames, name)
                        }</span>
                        <span class="cov8" title="1">_ = d.Set("column_names", columnNames)</span>
                }
                <span class="cov8" title="1">if sdkContactList.PhoneColumns != nil </span><span class="cov8" title="1">{
                        _ = d.Set("phone_columns", flattenSdkOutboundContactListContactPhoneNumberColumnSlice(*sdkContactList.PhoneColumns))
                }</span>
                <span class="cov8" title="1">if sdkContactList.EmailColumns != nil </span><span class="cov8" title="1">{
                        _ = d.Set("email_columns", flattenSdkOutboundContactListContactEmailAddressColumnSlice(*sdkContactList.EmailColumns))
                }</span>
                <span class="cov8" title="1">if sdkContactList.PreviewModeColumnName != nil </span><span class="cov8" title="1">{
                        _ = d.Set("preview_mode_column_name", *sdkContactList.PreviewModeColumnName)
                }</span>
                <span class="cov8" title="1">if sdkContactList.PreviewModeAcceptedValues != nil </span><span class="cov8" title="1">{
                        var acceptedValues []string
                        for _, val := range *sdkContactList.PreviewModeAcceptedValues </span><span class="cov8" title="1">{
                                acceptedValues = append(acceptedValues, val)
                        }</span>
                        <span class="cov8" title="1">_ = d.Set("preview_mode_accepted_values", acceptedValues)</span>
                }
                <span class="cov8" title="1">if sdkContactList.AttemptLimits != nil &amp;&amp; sdkContactList.AttemptLimits.Id != nil </span><span class="cov8" title="1">{
                        _ = d.Set("attempt_limit_id", *sdkContactList.AttemptLimits.Id)
                }</span>
                <span class="cov8" title="1">if sdkContactList.AutomaticTimeZoneMapping != nil </span><span class="cov8" title="1">{
                        _ = d.Set("automatic_time_zone_mapping", *sdkContactList.AutomaticTimeZoneMapping)
                }</span>
                <span class="cov8" title="1">if sdkContactList.ZipCodeColumnName != nil </span><span class="cov8" title="1">{
                        _ = d.Set("zip_code_column_name", *sdkContactList.ZipCodeColumnName)
                }</span>
                <span class="cov8" title="1">if sdkContactList.ColumnDataTypeSpecifications != nil </span><span class="cov8" title="1">{
                        _ = d.Set("column_data_type_specifications", flattenSdkOutboundContactListColumnDataTypeSpecifications(*sdkContactList.ColumnDataTypeSpecifications))
                }</span>

                <span class="cov8" title="1">log.Printf("Read Outbound Contact List %s %s", d.Id(), *sdkContactList.Name)
                return cc.CheckState()</span>
        })
}

func deleteOutboundContactList(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        outboundApi := platformclientv2.NewOutboundApiWithConfig(sdkConfig)

        diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Deleting Outbound Contact List")
                resp, err := outboundApi.DeleteOutboundContactlist(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Outbound Contact List: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, resp, err := outboundApi.GetOutboundContactlist(d.Id(), false, false)
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Outbound Contact List deleted
                                log.Printf("Deleted Outbound Contact List %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Outbound Contact List %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Contact List %s still exists", d.Id()))</span>
        })
}

func buildSdkOutboundContactListContactPhoneNumberColumnSlice(contactPhoneNumberColumn *schema.Set) *[]platformclientv2.Contactphonenumbercolumn <span class="cov8" title="1">{
        if contactPhoneNumberColumn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactPhoneNumberColumnSlice := make([]platformclientv2.Contactphonenumbercolumn, 0)
        contactPhoneNumberColumnList := contactPhoneNumberColumn.List()
        for _, configPhoneColumn := range contactPhoneNumberColumnList </span><span class="cov8" title="1">{
                var sdkContactPhoneNumberColumn platformclientv2.Contactphonenumbercolumn
                contactPhoneNumberColumnMap := configPhoneColumn.(map[string]interface{})
                if columnName := contactPhoneNumberColumnMap["column_name"].(string); columnName != "" </span><span class="cov8" title="1">{
                        sdkContactPhoneNumberColumn.ColumnName = &amp;columnName
                }</span>
                <span class="cov8" title="1">if varType := contactPhoneNumberColumnMap["type"].(string); varType != "" </span><span class="cov8" title="1">{
                        sdkContactPhoneNumberColumn.VarType = &amp;varType
                }</span>
                <span class="cov8" title="1">if callableTimeColumn := contactPhoneNumberColumnMap["callable_time_column"].(string); callableTimeColumn != "" </span><span class="cov8" title="1">{
                        sdkContactPhoneNumberColumn.CallableTimeColumn = &amp;callableTimeColumn
                }</span>

                <span class="cov8" title="1">sdkContactPhoneNumberColumnSlice = append(sdkContactPhoneNumberColumnSlice, sdkContactPhoneNumberColumn)</span>
        }
        <span class="cov8" title="1">return &amp;sdkContactPhoneNumberColumnSlice</span>
}

func flattenSdkOutboundContactListContactPhoneNumberColumnSlice(contactPhoneNumberColumns []platformclientv2.Contactphonenumbercolumn) *schema.Set <span class="cov8" title="1">{
        if len(contactPhoneNumberColumns) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactPhoneNumberColumnSet := schema.NewSet(schema.HashResource(outboundContactListContactPhoneNumberColumnResource), []interface{}{})
        for _, contactPhoneNumberColumn := range contactPhoneNumberColumns </span><span class="cov8" title="1">{
                contactPhoneNumberColumnMap := make(map[string]interface{})

                if contactPhoneNumberColumn.ColumnName != nil </span><span class="cov8" title="1">{
                        contactPhoneNumberColumnMap["column_name"] = *contactPhoneNumberColumn.ColumnName
                }</span>
                <span class="cov8" title="1">if contactPhoneNumberColumn.VarType != nil </span><span class="cov8" title="1">{
                        contactPhoneNumberColumnMap["type"] = *contactPhoneNumberColumn.VarType
                }</span>
                <span class="cov8" title="1">if contactPhoneNumberColumn.CallableTimeColumn != nil </span><span class="cov8" title="1">{
                        contactPhoneNumberColumnMap["callable_time_column"] = *contactPhoneNumberColumn.CallableTimeColumn
                }</span>

                <span class="cov8" title="1">contactPhoneNumberColumnSet.Add(contactPhoneNumberColumnMap)</span>
        }

        <span class="cov8" title="1">return contactPhoneNumberColumnSet</span>
}

func buildSdkOutboundContactListContactEmailAddressColumnSlice(contactEmailAddressColumn *schema.Set) *[]platformclientv2.Emailcolumn <span class="cov8" title="1">{
        if contactEmailAddressColumn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sdkContactEmailAddressColumnSlice := make([]platformclientv2.Emailcolumn, 0)
        contactEmailAddressColumnList := contactEmailAddressColumn.List()
        for _, configEmailColumn := range contactEmailAddressColumnList </span><span class="cov8" title="1">{
                var sdkContactEmailAddressColumn platformclientv2.Emailcolumn
                contactEmailAddressColumnMap := configEmailColumn.(map[string]interface{})
                if columnName := contactEmailAddressColumnMap["column_name"].(string); columnName != "" </span><span class="cov8" title="1">{
                        sdkContactEmailAddressColumn.ColumnName = &amp;columnName
                }</span>
                <span class="cov8" title="1">if varType := contactEmailAddressColumnMap["type"].(string); varType != "" </span><span class="cov8" title="1">{
                        sdkContactEmailAddressColumn.VarType = &amp;varType
                }</span>
                <span class="cov8" title="1">if contactableTimeColumn := contactEmailAddressColumnMap["contactable_time_column"].(string); contactableTimeColumn != "" </span><span class="cov8" title="1">{
                        sdkContactEmailAddressColumn.ContactableTimeColumn = &amp;contactableTimeColumn
                }</span>

                <span class="cov8" title="1">sdkContactEmailAddressColumnSlice = append(sdkContactEmailAddressColumnSlice, sdkContactEmailAddressColumn)</span>
        }
        <span class="cov8" title="1">return &amp;sdkContactEmailAddressColumnSlice</span>
}

func flattenSdkOutboundContactListContactEmailAddressColumnSlice(contactEmailAddressColumns []platformclientv2.Emailcolumn) *schema.Set <span class="cov8" title="1">{
        if len(contactEmailAddressColumns) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">contactEmailAddressColumnSet := schema.NewSet(schema.HashResource(outboundContactListEmailColumnResource), []interface{}{})
        for _, contactEmailAddressColumn := range contactEmailAddressColumns </span><span class="cov8" title="1">{
                contactEmailAddressColumnMap := make(map[string]interface{})

                if contactEmailAddressColumn.ColumnName != nil </span><span class="cov8" title="1">{
                        contactEmailAddressColumnMap["column_name"] = *contactEmailAddressColumn.ColumnName
                }</span>
                <span class="cov8" title="1">if contactEmailAddressColumn.VarType != nil </span><span class="cov8" title="1">{
                        contactEmailAddressColumnMap["type"] = *contactEmailAddressColumn.VarType
                }</span>
                <span class="cov8" title="1">if contactEmailAddressColumn.ContactableTimeColumn != nil </span><span class="cov8" title="1">{
                        contactEmailAddressColumnMap["contactable_time_column"] = *contactEmailAddressColumn.ContactableTimeColumn
                }</span>

                <span class="cov8" title="1">contactEmailAddressColumnSet.Add(contactEmailAddressColumnMap)</span>
        }

        <span class="cov8" title="1">return contactEmailAddressColumnSet</span>
}

func buildSdkOutboundContactListColumnDataTypeSpecifications(columnDataTypeSpecifications []interface{}) *[]platformclientv2.Columndatatypespecification <span class="cov8" title="1">{
        if columnDataTypeSpecifications == nil || len(columnDataTypeSpecifications) &lt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">sdkColumnDataTypeSpecificationsSlice := make([]platformclientv2.Columndatatypespecification, 0)

        for _, spec := range columnDataTypeSpecifications </span><span class="cov8" title="1">{
                if specMap, ok := spec.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        var sdkColumnDataTypeSpecification platformclientv2.Columndatatypespecification
                        if columnNameStr, ok := specMap["column_name"].(string); ok </span><span class="cov8" title="1">{
                                sdkColumnDataTypeSpecification.ColumnName = &amp;columnNameStr
                        }</span>
                        <span class="cov8" title="1">if columnDataTypeStr, ok := specMap["column_data_type"].(string); ok &amp;&amp; columnDataTypeStr != "" </span><span class="cov8" title="1">{
                                sdkColumnDataTypeSpecification.ColumnDataType = &amp;columnDataTypeStr
                        }</span>
                        <span class="cov8" title="1">if minInt, ok := specMap["min"].(int); ok </span><span class="cov8" title="1">{
                                sdkColumnDataTypeSpecification.Min = &amp;minInt
                        }</span>
                        <span class="cov8" title="1">if maxInt, ok := specMap["max"].(int); ok </span><span class="cov8" title="1">{
                                sdkColumnDataTypeSpecification.Max = &amp;maxInt
                        }</span>
                        <span class="cov8" title="1">if maxLengthInt, ok := specMap["max_length"].(int); ok </span><span class="cov8" title="1">{
                                sdkColumnDataTypeSpecification.MaxLength = &amp;maxLengthInt
                        }</span>
                        <span class="cov8" title="1">sdkColumnDataTypeSpecificationsSlice = append(sdkColumnDataTypeSpecificationsSlice, sdkColumnDataTypeSpecification)</span>
                }
        }

        <span class="cov8" title="1">return &amp;sdkColumnDataTypeSpecificationsSlice</span>
}

func flattenSdkOutboundContactListColumnDataTypeSpecifications(columnDataTypeSpecifications []platformclientv2.Columndatatypespecification) []interface{} <span class="cov8" title="1">{
        if columnDataTypeSpecifications == nil || len(columnDataTypeSpecifications) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">columnDataTypeSpecificationsSlice := make([]interface{}, 0)

        for _, s := range columnDataTypeSpecifications </span><span class="cov8" title="1">{
                columnDataTypeSpecification := make(map[string]interface{})
                columnDataTypeSpecification["column_name"] = *s.ColumnName

                if s.ColumnDataType != nil </span><span class="cov8" title="1">{
                        columnDataTypeSpecification["column_data_type"] = *s.ColumnDataType
                }</span>
                <span class="cov8" title="1">if s.Min != nil </span><span class="cov8" title="1">{
                        columnDataTypeSpecification["min"] = *s.Min
                }</span>
                <span class="cov8" title="1">if s.Max != nil </span><span class="cov8" title="1">{
                        columnDataTypeSpecification["max"] = *s.Max
                }</span>
                <span class="cov8" title="1">if s.MaxLength != nil </span><span class="cov8" title="1">{
                        columnDataTypeSpecification["max_length"] = *s.MaxLength
                }</span>

                <span class="cov8" title="1">columnDataTypeSpecificationsSlice = append(columnDataTypeSpecificationsSlice, columnDataTypeSpecification)</span>
        }

        <span class="cov8" title="1">return columnDataTypeSpecificationsSlice</span>
}

// type OutboundContactListInstance struct{
// }

// func (*OutboundContactListInstance) ResourceOutboundContactList() *schema.Resource {
//         ResourceOutboundContactList() *schema.Resource
// }

func GeneratePhoneColumnsBlock(columnName, columnType, callableTimeColumn string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
        phone_columns {
                column_name          = "%s"
                type                 = "%s"
                callable_time_column = %s
        }
`, columnName, columnType, callableTimeColumn)
}</span>

func GenerateOutboundContactList(
        resourceId string,
        name string,
        divisionId string,
        previewModeColumnName string,
        previewModeAcceptedValues []string,
        columnNames []string,
        automaticTimeZoneMapping string,
        zipCodeColumnName string,
        attemptLimitId string,
        nestedBlocks ...string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
resource "genesyscloud_outbound_contact_list" "%s" {
        name                         = "%s"
        division_id                  = %s
        preview_mode_column_name     = %s
        preview_mode_accepted_values = [%s]
        column_names                 = [%s] 
        automatic_time_zone_mapping  = %s
        zip_code_column_name         = %s
        attempt_limit_id             = %s
        %s
}
`, resourceId, name, divisionId, previewModeColumnName, strings.Join(previewModeAcceptedValues, ", "),
                strings.Join(columnNames, ", "), automaticTimeZoneMapping, zipCodeColumnName, attemptLimitId, strings.Join(nestedBlocks, "\n"))
}</span>

func GeneratePhoneColumnsDataTypeSpecBlock(columnName, columnDataType, min, max, maxLength string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
        column_data_type_specifications {
                column_name      = %s
                column_data_type = %s
                min              = %s
                max              = %s
                max_length       = %s
        }
        `, columnName, columnDataType, min, max, maxLength)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package outbound_ruleset

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_outbound_ruleset.go contains the data source implementation
   for the resource.
*/

// dataSourceOutboundRulesetRead retrieves by name the id in question
func dataSourceOutboundRulesetRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundRulesetProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                rulesetId, retryable, err := proxy.getOutboundRulesetIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error ruleset %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No ruleset found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(rulesetId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package outbound_ruleset

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "strings"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_outbound_ruleset_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *outboundRulesetProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createOutboundRulesetFunc func(ctx context.Context, p *outboundRulesetProxy, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error)
type getAllOutboundRulesetFunc func(ctx context.Context, p *outboundRulesetProxy) (*[]platformclientv2.Ruleset, error)
type getOutboundRulesetByIdFunc func(ctx context.Context, p *outboundRulesetProxy, rulesetId string) (ruleset *platformclientv2.Ruleset, responseCode int, err error)
type getOutboundRulesetIdByNameFunc func(ctx context.Context, p *outboundRulesetProxy, search string) (rulesetId string, retryable bool, err error)
type updateOutboundRulesetFunc func(ctx context.Context, p *outboundRulesetProxy, rulesetId string, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error)
type deleteOutboundRulesetFunc func(ctx context.Context, p *outboundRulesetProxy, rulesetId string) (responseCode int, err error)

// outboundRulesetProxy contains all of the methods that call genesys cloud APIs.
type outboundRulesetProxy struct {
        clientConfig                   *platformclientv2.Configuration
        outboundApi                    *platformclientv2.OutboundApi
        createOutboundRulesetAttr      createOutboundRulesetFunc
        getAllOutboundRulesetAttr      getAllOutboundRulesetFunc
        getOutboundRulesetByIdAttr     getOutboundRulesetByIdFunc
        getOutboundRulesetIdByNameAttr getOutboundRulesetIdByNameFunc
        updateOutboundRulesetAttr      updateOutboundRulesetFunc
        deleteOutboundRulesetAttr      deleteOutboundRulesetFunc
}

// newOutboundRulesetProxy initializes the ruleset proxy with all of the data needed to communicate with Genesys Cloud
func newOutboundRulesetProxy(clientConfig *platformclientv2.Configuration) *outboundRulesetProxy <span class="cov8" title="1">{
        api := platformclientv2.NewOutboundApiWithConfig(clientConfig)
        return &amp;outboundRulesetProxy{
                clientConfig:                   clientConfig,
                outboundApi:                    api,
                createOutboundRulesetAttr:      createOutboundRulesetFn,
                getAllOutboundRulesetAttr:      getAllOutboundRulesetFn,
                getOutboundRulesetByIdAttr:     getOutboundRulesetByIdFn,
                getOutboundRulesetIdByNameAttr: getOutboundRulesetIdByNameFn,
                updateOutboundRulesetAttr:      updateOutboundRulesetFn,
                deleteOutboundRulesetAttr:      deleteOutboundRulesetFn,
        }
}</span>

// getOutboundRulesetProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getOutboundRulesetProxy(clientConfig *platformclientv2.Configuration) *outboundRulesetProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newOutboundRulesetProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// createOutboundRuleset creates a Genesys Cloud Outbound Ruleset
func (p *outboundRulesetProxy) createOutboundRuleset(ctx context.Context, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error) <span class="cov8" title="1">{
        return p.createOutboundRulesetAttr(ctx, p, ruleset)
}</span>

// getOutboundRuleset retrieves all Genesys Cloud Outbound Ruleset
func (p *outboundRulesetProxy) getAllOutboundRuleset(ctx context.Context) (*[]platformclientv2.Ruleset, error) <span class="cov0" title="0">{
        return p.getAllOutboundRulesetAttr(ctx, p)
}</span>

// getOutboundRulesetById returns a single Genesys Cloud Outbound Ruleset by Id
func (p *outboundRulesetProxy) getOutboundRulesetById(ctx context.Context, rulesetId string) (ruleset *platformclientv2.Ruleset, statusCode int, err error) <span class="cov8" title="1">{
        return p.getOutboundRulesetByIdAttr(ctx, p, rulesetId)
}</span>

// getOutboundRulesetIdByName returns a single Genesys Cloud Outbound Ruleset by a name
func (p *outboundRulesetProxy) getOutboundRulesetIdByName(ctx context.Context, name string) (rulesetId string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getOutboundRulesetIdByNameAttr(ctx, p, name)
}</span>

// updateOutboundRuleset updates a Genesys Cloud Outbound Ruleset
func (p *outboundRulesetProxy) updateOutboundRuleset(ctx context.Context, rulesetId string, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error) <span class="cov8" title="1">{
        return p.updateOutboundRulesetAttr(ctx, p, rulesetId, ruleset)
}</span>

// deleteOutboundRuleset deletes a Genesys Cloud Outbound Ruleset by Id
func (p *outboundRulesetProxy) deleteOutboundRuleset(ctx context.Context, rulesetId string) (statusCode int, err error) <span class="cov8" title="1">{
        return p.deleteOutboundRulesetAttr(ctx, p, rulesetId)
}</span>

// createOutboundRulesetFn is an implementation function for creating a Genesys Cloud Outbound Ruleset
func createOutboundRulesetFn(ctx context.Context, p *outboundRulesetProxy, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error) <span class="cov8" title="1">{
        ruleset, _, err := p.outboundApi.PostOutboundRulesets(*ruleset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create ruleset: %s", err)
        }</span>

        <span class="cov8" title="1">return ruleset, nil</span>
}

// getAllOutboundRulesetFn is the implementation for retrieving all outbound ruleset in Genesys Cloud
func getAllOutboundRulesetFn(ctx context.Context, p *outboundRulesetProxy) (*[]platformclientv2.Ruleset, error) <span class="cov0" title="0">{
        var allRulesets []platformclientv2.Ruleset

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100

                rulesets, _, err := p.outboundApi.GetOutboundRulesets(pageSize, pageNum, true, "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get outbound rulesets: %v", err)
                }</span>

                <span class="cov0" title="0">if rulesets.Entities == nil || len(*rulesets.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, ruleset := range *rulesets.Entities </span><span class="cov0" title="0">{
                        log.Printf("Dealing with ruleset id : %s", *ruleset.Id)
                        allRulesets = append(allRulesets, ruleset)
                }</span>
        }

        <span class="cov0" title="0">return &amp;allRulesets, nil</span>
}

// getOutboundRulesetByIdFn is an implementation of the function to get a Genesys Cloud Outbound Ruleset by Id
func getOutboundRulesetByIdFn(ctx context.Context, p *outboundRulesetProxy, rulesetId string) (ruleset *platformclientv2.Ruleset, statusCode int, err error) <span class="cov8" title="1">{
        ruleset, resp, err := p.outboundApi.GetOutboundRuleset(rulesetId)
        if err != nil </span><span class="cov8" title="1">{
                //This is an API that throws an error on a 404 instead of just returning a 404.
                if strings.Contains(fmt.Sprintf("%s", err), "API Error: 404") </span><span class="cov8" title="1">{
                        return nil, http.StatusNotFound, nil

                }</span>
                <span class="cov0" title="0">return nil, 0, fmt.Errorf("Failed to retrieve ruleset by id %s: %s", rulesetId, err)</span>
        }

        <span class="cov8" title="1">return ruleset, resp.StatusCode, nil</span>
}

// getOutboundRulesetIdBySearchFn is an implementation of the function to get a Genesys Cloud Outbound Ruleset by name
func getOutboundRulesetIdByNameFn(ctx context.Context, p *outboundRulesetProxy, name string) (rulesetId string, retryable bool, err error) <span class="cov8" title="1">{
        const pageNum = 1
        const pageSize = 100
        rulesets, _, err := p.outboundApi.GetOutboundRulesets(pageSize, pageNum, true, "", name, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("Error searching outbound ruleset %s: %s", name, err)
        }</span>

        <span class="cov8" title="1">if rulesets.Entities == nil || len(*rulesets.Entities) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("No outbound ruleset found with name %s", name)
        }</span>

        <span class="cov8" title="1">var ruleset platformclientv2.Ruleset
        entities := *rulesets.Entities

        for _, rulesetSdk := range entities </span><span class="cov8" title="1">{
                if *rulesetSdk.Name == name </span><span class="cov8" title="1">{
                        log.Printf("Retrieved the ruleset id %s by name %s", *rulesetSdk.Id, name)
                        ruleset = rulesetSdk
                        return *ruleset.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", false, fmt.Errorf("Unable to find ruleset with name %s", name)</span>
}

// updateOutboundRulesetFn is an implementation of the function to update a Genesys Cloud Outbound Rulesets
func updateOutboundRulesetFn(ctx context.Context, p *outboundRulesetProxy, rulesetId string, ruleset *platformclientv2.Ruleset) (*platformclientv2.Ruleset, error) <span class="cov8" title="1">{
        outboundRuleset, _, err := getOutboundRulesetByIdFn(ctx, p, rulesetId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to ruleset by id %s: %s", rulesetId, err)
        }</span>

        <span class="cov8" title="1">ruleset.Version = outboundRuleset.Version
        ruleset, _, err = p.outboundApi.PutOutboundRuleset(rulesetId, *ruleset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update ruleset: %s", err)
        }</span>
        <span class="cov8" title="1">return ruleset, nil</span>
}

// deleteOutboundRulesetFn is an implementation function for deleting a Genesys Cloud Outbound Rulesets
func deleteOutboundRulesetFn(ctx context.Context, p *outboundRulesetProxy, rulesetId string) (statusCode int, err error) <span class="cov8" title="1">{
        resp, err := p.outboundApi.DeleteOutboundRuleset(rulesetId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete ruleset: %s", err)
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package outbound_ruleset

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_outbound_ruleset.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthOutboundRulesets retrieves all of the outbound rulesets via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthOutboundRuleset(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := getOutboundRulesetProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        rulesets, err := proxy.getAllOutboundRuleset(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get ruleset: %v", err)
        }</span>

        <span class="cov0" title="0">for _, ruleset := range *rulesets </span><span class="cov0" title="0">{
                log.Printf("Dealing with ruleset id : %s", *ruleset.Id)
                resources[*ruleset.Id] = &amp;resourceExporter.ResourceMeta{Name: *ruleset.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createOutboundRuleset is used by the outbound_ruleset resource to create Genesys cloud outbound_ruleset
func createOutboundRuleset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundRulesetProxy(sdkConfig)

        outboundRuleset := getOutboundRulesetFromResourceData(d)

        ruleset, err := proxy.createOutboundRuleset(ctx, &amp;outboundRuleset)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create ruleset: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*ruleset.Id)
        log.Printf("Created Outbound Ruleset %s", *ruleset.Id)
        return readOutboundRuleset(ctx, d, meta)</span>
}

// readOutboundRuleset is used by the outbound_ruleset resource to read an outbound ruleset from genesys cloud.
func readOutboundRuleset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundRulesetProxy(sdkConfig)

        log.Printf("Reading Outbound Ruleset %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                ruleset, respCode, getErr := proxy.getOutboundRulesetById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Ruleset %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Ruleset %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundRuleset())

                resourcedata.SetNillableValue(d, "name", ruleset.Name)
                resourcedata.SetNillableReference(d, "contact_list_id", ruleset.ContactList)
                resourcedata.SetNillableReference(d, "queue_id", ruleset.Queue)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "rules", ruleset.Rules, flattenDialerrules)

                log.Printf("Read Outbound Ruleset %s %s", d.Id(), *ruleset.Name)
                return cc.CheckState()</span>
        })
}

// updateOutboundRuleset is used by the outbound_ruleset resource to update an outbound ruleset in Genesys Cloud
func updateOutboundRuleset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundRulesetProxy(sdkConfig)

        outboundRuleset := getOutboundRulesetFromResourceData(d)

        ruleset, err := proxy.updateOutboundRuleset(ctx, d.Id(), &amp;outboundRuleset)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update ruleset: %s", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated Outbound Ruleset %s", *ruleset.Id)
        return readOutboundRuleset(ctx, d, meta)</span>
}

// deleteOutboundRuleset is used by the outbound_ruleset resource to delete an outbound ruleset from Genesys cloud.
func deleteOutboundRuleset(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundRulesetProxy(sdkConfig)

        _, err := proxy.deleteOutboundRuleset(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete ruleset %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 1800*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, respCode, err := proxy.getOutboundRulesetById(ctx, d.Id())

                //Now that I am checking for th error string of API 404 and there is no error, I need to move the isStatus404
                //moved out of the code
                if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                        // Outbound Ruleset deleted
                        log.Printf("Deleted Outbound Ruleset %s", d.Id())
                        return nil
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error deleting Outbound Ruleset %s: %s", d.Id(), err))
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Outbound Ruleset %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package outbound_ruleset

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_outbound_ruleset_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the outbound_ruleset resource.
3.  The datasource schema definitions for the outbound_ruleset datasource.
4.  The resource exporter configuration for the outbound_ruleset exporter.
*/
const resourceName = "genesyscloud_outbound_ruleset"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceOutboundRuleset())
        regInstance.RegisterDataSource(resourceName, DataSourceOutboundRuleset())
        regInstance.RegisterExporter(resourceName, OutboundRulesetExporter())
}</span>

// ResourceOutboundRuleset registers the genesyscloud_outbound_ruleset resource with Terraform
func ResourceOutboundRuleset() *schema.Resource <span class="cov8" title="1">{

        outboundrulesetcontactcolumntodataactionfieldmappingResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `contact_column_name`: {
                                Description: `The name of a contact column whose data will be passed to the data action`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `data_action_field`: {
                                Description: `The name of an input field from the data action that the contact column data will be passed to`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                },
        }

        outboundrulesetdataactionconditionpredicateResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `output_field`: {
                                Description: `The name of an output field from the data action's output to use for this condition`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `output_operator`: {
                                Description:  `The operation with which to evaluate this condition`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`EQUALS`, `LESS_THAN`, `LESS_THAN_EQUALS`, `GREATER_THAN`, `GREATER_THAN_EQUALS`, `CONTAINS`, `BEGINS_WITH`, `ENDS_WITH`, `BEFORE`, `AFTER`}, false),
                        },
                        `comparison_value`: {
                                Description: `The value to compare against for this condition`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `inverted`: {
                                Description: `If true, inverts the result of evaluating this Predicate. Default is false.`,
                                Required:    true,
                                Type:        schema.TypeBool,
                        },
                        `output_field_missing_resolution`: {
                                Description: `The result of this predicate if the requested output field is missing from the data action's result`,
                                Required:    true,
                                Type:        schema.TypeBool,
                        },
                },
        }

        outboundrulesetconditionResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `type`: {
                                Description:  `The type of the condition.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`wrapupCondition`, `systemDispositionCondition`, `contactAttributeCondition`, `phoneNumberCondition`, `phoneNumberTypeCondition`, `callAnalysisCondition`, `contactPropertyCondition`, `dataActionCondition`}, false),
                        },
                        `inverted`: {
                                Description: `If true, inverts the result of evaluating this Condition. Default is false.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `attribute_name`: {
                                Description: `An attribute name associated with this Condition. Required for a contactAttributeCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `value`: {
                                Description: `A value associated with this Condition. This could be text, a number, or a relative time. Not used for a DataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `value_type`: {
                                Description:  `The type of the value associated with this Condition. Not used for a DataActionCondition.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`STRING`, `NUMERIC`, `DATETIME`, `PERIOD`}, false),
                        },
                        `operator`: {
                                Description:  `An operation with which to evaluate the Condition. Not used for a DataActionCondition.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`EQUALS`, `LESS_THAN`, `LESS_THAN_EQUALS`, `GREATER_THAN`, `GREATER_THAN_EQUALS`, `CONTAINS`, `BEGINS_WITH`, `ENDS_WITH`, `BEFORE`, `AFTER`, `IN`}, false),
                        },
                        `codes`: {
                                Description: `List of wrap-up code identifiers. Required for a wrapupCondition.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `property`: {
                                Description: `A value associated with the property type of this Condition. Required for a contactPropertyCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `property_type`: {
                                Description:  `The type of the property associated with this Condition. Required for a contactPropertyCondition.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`LAST_ATTEMPT_BY_COLUMN`, `LAST_ATTEMPT_OVERALL`, `LAST_WRAPUP_BY_COLUMN`, `LAST_WRAPUP_OVERALL`}, false),
                        },
                        `data_action_id`: {
                                Description: `The Data Action to use for this condition. Required for a dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `data_not_found_resolution`: {
                                Description: `The result of this condition if the data action returns a result indicating there was no data. Required for a DataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                        `contact_id_field`: {
                                Description: `The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `call_analysis_result_field`: {
                                Description: `The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `agent_wrapup_field`: {
                                Description: `The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_column_to_data_action_field_mappings`: {
                                Description: `A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetcontactcolumntodataactionfieldmappingResource,
                        },
                        `predicates`: {
                                Description: `A list of predicates defining the comparisons to use for this condition. Required for a dataActionCondition.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetdataactionconditionpredicateResource,
                        },
                },
        }

        outboundrulesetdialeractionResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `type`: {
                                Description:  `The type of this DialerAction.`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`Action`, `modifyContactAttribute`, `dataActionBehavior`}, false),
                        },
                        `action_type_name`: {
                                Description:  `Additional type specification for this DialerAction.`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`DO_NOT_DIAL`, `MODIFY_CONTACT_ATTRIBUTE`, `SWITCH_TO_PREVIEW`, `APPEND_NUMBER_TO_DNC_LIST`, `SCHEDULE_CALLBACK`, `CONTACT_UNCALLABLE`, `NUMBER_UNCALLABLE`, `SET_CALLER_ID`, `SET_SKILLS`, `DATA_ACTION`}, false),
                        },
                        `update_option`: {
                                Description:  `Specifies how a contact attribute should be updated. Required for MODIFY_CONTACT_ATTRIBUTE.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`SET`, `INCREMENT`, `DECREMENT`, `CURRENT_TIME`}, false),
                        },
                        `properties`: {
                                Description: `A map of key-value pairs pertinent to the DialerAction. Different types of DialerActions require different properties. MODIFY_CONTACT_ATTRIBUTE with an updateOption of SET takes a contact column as the key and accepts any value. SCHEDULE_CALLBACK takes a key 'callbackOffset' that specifies how far in the future the callback should be scheduled, in minutes. SET_CALLER_ID takes two keys: 'callerAddress', which should be the caller id phone number, and 'callerName'. For either key, you can also specify a column on the contact to get the value from. To do this, specify 'contact.Column', where 'Column' is the name of the contact column from which to get the value. SET_SKILLS takes a key 'skills' with an array of skill ids wrapped into a string (Example: {'skills': '['skillIdHere']'} ).`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeMap,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `data_action_id`: {
                                Description: `The Data Action to use for this action. Required for a dataActionBehavior.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_column_to_data_action_field_mappings`: {
                                Description: `A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionBehavior.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetcontactcolumntodataactionfieldmappingResource,
                        },
                        `contact_id_field`: {
                                Description: `The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionBehavior.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `call_analysis_result_field`: {
                                Description: `The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionBehavior.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `agent_wrapup_field`: {
                                Description: `The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionBehavior.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }

        outboundrulesetdialerruleResource := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the rule.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `order`: {
                                Description: `The ranked order of the rule. Rules are processed from lowest number to highest.`,
                                Optional:    true,
                                Type:        schema.TypeInt,
                        },
                        `category`: {
                                Description:  `The category of the rule.`,
                                Required:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`DIALER_PRECALL`, `DIALER_WRAPUP`}, false),
                        },
                        `conditions`: {
                                Description: `A list of Conditions. All of the Conditions must evaluate to true to trigger the actions.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetconditionResource,
                        },
                        `actions`: {
                                Description: `The list of actions to be taken if the conditions are true.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetdialeractionResource,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound ruleset`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundRuleset),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundRuleset),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundRuleset),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundRuleset),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `The name of the RuleSet.`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `contact_list_id`: {
                                Description: `A ContactList to provide user-interface suggestions for contact columns on relevant conditions and actions.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `queue_id`: {
                                Description: `A Queue to provide user-interface suggestions for wrap-up codes on relevant conditions and actions.`,
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                        `rules`: {
                                Description: `The list of rules.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem:        outboundrulesetdialerruleResource,
                        },
                },
        }
}</span>

// OutboundRulesetExporter returns the resourceExporter object used to hold the genesyscloud_outbound_ruleset exporter's config
func OutboundRulesetExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthOutboundRuleset),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "contact_list_id": {
                                RefType: "genesyscloud_outbound_contact_list",
                        },
                        "queue_id": {
                                RefType: "genesyscloud_routing_queue",
                        },
                        "rules.conditions.codes": {
                                RefType: "genesyscloud_routing_wrapupcode",
                        },
                        "rules.conditions.data_action_id": {
                                RefType: "genesyscloud_integration_action",
                        },
                        "rules.actions.data_action_id": {
                                RefType: "genesyscloud_integration_action",
                        },
                },
                JsonEncodeAttributes: []string{"rules.actions.properties.skills"},
                CustomAttributeResolver: map[string]*resourceExporter.RefAttrCustomResolver{
                        "rules.actions.properties":        {ResolverFunc: resourceExporter.RuleSetPropertyResolver},
                        "rules.actions.properties.skills": {ResolverFunc: resourceExporter.RuleSetSkillPropertyResolver},
                },
        }
}</span>

// DataSourceOutboundRuleset registers the genesyscloud_outbound_ruleset data source
func DataSourceOutboundRuleset() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Data source for Genesys Cloud Outbound Ruleset. Select an Outbound Ruleset by name.`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundRulesetRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `Outbound Ruleset name.`,
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package outbound_ruleset

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_outbound_ruleset_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.
*/

// getOutboundRulesetFromResourceData maps data from schema ResourceData object to a platformclientv2.Ruleset
func getOutboundRulesetFromResourceData(d *schema.ResourceData) platformclientv2.Ruleset <span class="cov8" title="1">{
        name := d.Get("name").(string)

        return platformclientv2.Ruleset{
                Name:        &amp;name,
                ContactList: gcloud.BuildSdkDomainEntityRef(d, "contact_list_id"),
                Queue:       gcloud.BuildSdkDomainEntityRef(d, "queue_id"),
                Rules:       buildDialerules(d.Get("rules").([]interface{})),
        }
}</span>

// buildDialerules maps a []interface{} into a Genesys Cloud *[]platformclientv2.Dialerrule
func buildDialerules(rules []interface{}) *[]platformclientv2.Dialerrule <span class="cov8" title="1">{
        rulesSlice := make([]platformclientv2.Dialerrule, 0)
        for _, rule := range rules </span><span class="cov8" title="1">{
                var sdkRule platformclientv2.Dialerrule
                ruleMap, ok := rule.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkRule.Name, ruleMap, "name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkRule.Category, ruleMap, "category")
                sdkRule.Order = platformclientv2.Int(ruleMap["order"].(int))
                resourcedata.BuildSDKInterfaceArrayValueIfNotNil(&amp;sdkRule.Conditions, ruleMap, "conditions", buildConditions)
                resourcedata.BuildSDKInterfaceArrayValueIfNotNil(&amp;sdkRule.Actions, ruleMap, "actions", buildDialeractions)

                rulesSlice = append(rulesSlice, sdkRule)</span>
        }

        <span class="cov8" title="1">return &amp;rulesSlice</span>
}

// buildConditions maps a []interface{} into a Genesys Cloud *[]platformclientv2.Condition
func buildConditions(conditions []interface{}) *[]platformclientv2.Condition <span class="cov8" title="1">{
        conditionSlice := make([]platformclientv2.Condition, 0)
        for _, conditions := range conditions </span><span class="cov8" title="1">{
                var sdkCondition platformclientv2.Condition
                conditionMap, ok := conditions.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.VarType, conditionMap, "type")
                sdkCondition.Inverted = platformclientv2.Bool(conditionMap["inverted"].(bool))
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.AttributeName, conditionMap, "attribute_name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.Value, conditionMap, "value")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.ValueType, conditionMap, "value_type")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.Operator, conditionMap, "operator")
                resourcedata.BuildSDKStringArrayValueIfNotNil(&amp;sdkCondition.Codes, conditionMap, "codes")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.Property, conditionMap, "property")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.PropertyType, conditionMap, "property_type")
                sdkCondition.DataAction = &amp;platformclientv2.Domainentityref{Id: platformclientv2.String(conditionMap["data_action_id"].(string))}
                sdkCondition.DataNotFoundResolution = platformclientv2.Bool(conditionMap["data_not_found_resolution"].(bool))
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.ContactIdField, conditionMap, "contact_id_field")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.CallAnalysisResultField, conditionMap, "call_analysis_result_field")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkCondition.AgentWrapupField, conditionMap, "agent_wrapup_field")
                resourcedata.BuildSDKInterfaceArrayValueIfNotNil(&amp;sdkCondition.ContactColumnToDataActionFieldMappings, conditionMap, "contact_column_to_data_action_field_mappings", buildContactcolumntodataactionfieldmappings)
                resourcedata.BuildSDKInterfaceArrayValueIfNotNil(&amp;sdkCondition.Predicates, conditionMap, "predicates", buildDataactionconditionpredicates)

                conditionSlice = append(conditionSlice, sdkCondition)</span>
        }

        <span class="cov8" title="1">return &amp;conditionSlice</span>
}

// buildDialeractions maps a []interface{} into a Genesys Cloud *[]platformclientv2.Dialeraction
func buildDialeractions(actions []interface{}) *[]platformclientv2.Dialeraction <span class="cov8" title="1">{
        actionsSlice := make([]platformclientv2.Dialeraction, 0)
        for _, action := range actions </span><span class="cov8" title="1">{
                var sdkAction platformclientv2.Dialeraction
                actionMap, ok := action.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.VarType, actionMap, "type")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.ActionTypeName, actionMap, "action_type_name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.UpdateOption, actionMap, "update_option")
                resourcedata.BuildSDKStringMapValueIfNotNil(&amp;sdkAction.Properties, actionMap, "properties")
                sdkAction.DataAction = &amp;platformclientv2.Domainentityref{Id: platformclientv2.String(actionMap["data_action_id"].(string))}
                resourcedata.BuildSDKInterfaceArrayValueIfNotNil(&amp;sdkAction.ContactColumnToDataActionFieldMappings, actionMap, "contact_column_to_data_action_field_mappings", buildContactcolumntodataactionfieldmappings)
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.ContactIdField, actionMap, "contact_id_field")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.CallAnalysisResultField, actionMap, "call_analysis_result_field")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkAction.AgentWrapupField, actionMap, "agent_wrapup_field")

                actionsSlice = append(actionsSlice, sdkAction)</span>
        }

        <span class="cov8" title="1">return &amp;actionsSlice</span>
}

// buildContactcolumntodataactionfieldmappings maps a []interface{} into a Genesys Cloud *[]platformclientv2.Contactcolumntodataactionfieldmapping
func buildContactcolumntodataactionfieldmappings(fieldmappings []interface{}) *[]platformclientv2.Contactcolumntodataactionfieldmapping <span class="cov8" title="1">{
        fieldmappingsSlice := make([]platformclientv2.Contactcolumntodataactionfieldmapping, 0)
        for _, fieldmapping := range fieldmappings </span><span class="cov0" title="0">{
                var sdkFieldmapping platformclientv2.Contactcolumntodataactionfieldmapping
                fieldmappingMap, ok := fieldmapping.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkFieldmapping.ContactColumnName, fieldmappingMap, "contact_column_name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkFieldmapping.DataActionField, fieldmappingMap, "data_action_field")

                fieldmappingsSlice = append(fieldmappingsSlice, sdkFieldmapping)</span>
        }

        <span class="cov8" title="1">return &amp;fieldmappingsSlice</span>
}

// buildDataactionconditionpredicates maps a []interface{} into a Genesys Cloud *[]platformclientv2.Dataactionconditionpredicate
func buildDataactionconditionpredicates(predicates []interface{}) *[]platformclientv2.Dataactionconditionpredicate <span class="cov8" title="1">{
        predicatesSlice := make([]platformclientv2.Dataactionconditionpredicate, 0)
        for _, predicate := range predicates </span><span class="cov0" title="0">{
                var sdkPredicate platformclientv2.Dataactionconditionpredicate
                predicateMap, ok := predicate.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkPredicate.OutputField, predicateMap, "output_field")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkPredicate.OutputOperator, predicateMap, "output_operator")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;sdkPredicate.ComparisonValue, predicateMap, "comparison_value")
                sdkPredicate.Inverted = platformclientv2.Bool(predicateMap["inverted"].(bool))
                sdkPredicate.OutputFieldMissingResolution = platformclientv2.Bool(predicateMap["output_field_missing_resolution"].(bool))

                predicatesSlice = append(predicatesSlice, sdkPredicate)</span>
        }

        <span class="cov8" title="1">return &amp;predicatesSlice</span>
}

// flattenDialerrules maps a Genesys Cloud *[]platformclientv2.Dialerrule into a []interface{}
func flattenDialerrules(rules *[]platformclientv2.Dialerrule) []interface{} <span class="cov8" title="1">{
        if len(*rules) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var dialerruleList []interface{}
        for _, rule := range *rules </span><span class="cov8" title="1">{
                ruleMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(ruleMap, "name", rule.Name)
                resourcedata.SetMapValueIfNotNil(ruleMap, "order", rule.Order)
                resourcedata.SetMapValueIfNotNil(ruleMap, "category", rule.Category)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(ruleMap, "conditions", rule.Conditions, flattenConditions)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(ruleMap, "actions", rule.Actions, flattenDialeractions)

                dialerruleList = append(dialerruleList, ruleMap)
        }</span>

        <span class="cov8" title="1">return dialerruleList</span>
}

// flattenDialeractions maps a Genesys Cloud *[]platformclientv2.Dialeraction into a []interface{}
func flattenDialeractions(actions *[]platformclientv2.Dialeraction) []interface{} <span class="cov8" title="1">{
        if len(*actions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var actionList []interface{}
        for _, action := range *actions </span><span class="cov8" title="1">{
                actionMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(actionMap, "type", action.VarType)
                resourcedata.SetMapValueIfNotNil(actionMap, "action_type_name", action.ActionTypeName)
                resourcedata.SetMapValueIfNotNil(actionMap, "update_option", action.UpdateOption)
                resourcedata.SetMapValueIfNotNil(actionMap, "contact_id_field", action.ContactIdField)
                resourcedata.SetMapValueIfNotNil(actionMap, "call_analysis_result_field", action.CallAnalysisResultField)
                resourcedata.SetMapValueIfNotNil(actionMap, "agent_wrapup_field", action.AgentWrapupField)
                resourcedata.SetMapReferenceValueIfNotNil(actionMap, "data_action_id", action.DataAction)
                resourcedata.SetMapStringMapValueIfNotNil(actionMap, "properties", action.Properties)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionMap, "contact_column_to_data_action_field_mappings", action.ContactColumnToDataActionFieldMappings, flattenContactcolumntodataactionfieldmappings)

                actionList = append(actionList, actionMap)
        }</span>

        <span class="cov8" title="1">return actionList</span>
}

// flattenConditions maps a Genesys Cloud *[]platformclientv2.Condition into a []interface{}
func flattenConditions(conditions *[]platformclientv2.Condition) []interface{} <span class="cov8" title="1">{
        if len(*conditions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var conditionList []interface{}
        for _, condition := range *conditions </span><span class="cov8" title="1">{
                conditionMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(conditionMap, "type", condition.VarType)
                resourcedata.SetMapValueIfNotNil(conditionMap, "inverted", condition.Inverted)
                resourcedata.SetMapValueIfNotNil(conditionMap, "attribute_name", condition.AttributeName)
                resourcedata.SetMapValueIfNotNil(conditionMap, "value", condition.Value)
                resourcedata.SetMapValueIfNotNil(conditionMap, "value_type", condition.ValueType)
                resourcedata.SetMapValueIfNotNil(conditionMap, "operator", condition.Operator)
                resourcedata.SetMapStringArrayValueIfNotNil(conditionMap, "codes", condition.Codes)
                resourcedata.SetMapValueIfNotNil(conditionMap, "property", condition.Property)
                resourcedata.SetMapValueIfNotNil(conditionMap, "property_type", condition.PropertyType)
                resourcedata.SetMapReferenceValueIfNotNil(conditionMap, "data_action_id", condition.DataAction)
                resourcedata.SetMapValueIfNotNil(conditionMap, "data_not_found_resolution", condition.DataNotFoundResolution)
                resourcedata.SetMapValueIfNotNil(conditionMap, "contact_id_field", condition.ContactIdField)
                resourcedata.SetMapValueIfNotNil(conditionMap, "call_analysis_result_field", condition.CallAnalysisResultField)
                resourcedata.SetMapValueIfNotNil(conditionMap, "agent_wrapup_field", condition.AgentWrapupField)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionMap, "contact_column_to_data_action_field_mappings", condition.ContactColumnToDataActionFieldMappings, flattenContactcolumntodataactionfieldmappings)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionMap, "predicates", condition.Predicates, flattenDataactionconditionpredicates)

                conditionList = append(conditionList, conditionMap)
        }</span>

        <span class="cov8" title="1">return conditionList</span>
}

// flattenContactcolumntodataactionfieldmappings maps a Genesys Cloud *[]platformclientv2.Contactcolumntodataactionfieldmapping into a []interface{}
func flattenContactcolumntodataactionfieldmappings(fieldmappings *[]platformclientv2.Contactcolumntodataactionfieldmapping) []interface{} <span class="cov0" title="0">{
        if len(*fieldmappings) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var fieldmappingsList []interface{}
        for _, fieldmapping := range *fieldmappings </span><span class="cov0" title="0">{
                fieldmappingMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(fieldmappingMap, "contact_column_name", fieldmapping.ContactColumnName)
                resourcedata.SetMapValueIfNotNil(fieldmappingMap, "data_action_field", fieldmapping.DataActionField)

                fieldmappingsList = append(fieldmappingsList, fieldmappingMap)
        }</span>

        <span class="cov0" title="0">return fieldmappingsList</span>
}

// flattenDataactionconditionpredicates maps a Genesys Cloud *[]platformclientv2.Dataactionconditionpredicate into a []interface{}
func flattenDataactionconditionpredicates(predicates *[]platformclientv2.Dataactionconditionpredicate) []interface{} <span class="cov0" title="0">{
        if len(*predicates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var predicateList []interface{}
        for _, predicate := range *predicates </span><span class="cov0" title="0">{
                predicateMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(predicateMap, "output_field", predicate.OutputField)
                resourcedata.SetMapValueIfNotNil(predicateMap, "output_operator", predicate.OutputOperator)
                resourcedata.SetMapValueIfNotNil(predicateMap, "comparison_value", predicate.ComparisonValue)
                resourcedata.SetMapValueIfNotNil(predicateMap, "inverted", predicate.Inverted)
                resourcedata.SetMapValueIfNotNil(predicateMap, "output_field_missing_resolution", predicate.OutputFieldMissingResolution)

                predicateList = append(predicateList, predicateMap)
        }</span>

        <span class="cov0" title="0">return predicateList</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package outbound_sequence

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_outbound_sequence.go contains the data source implementation
   for the resource.
*/

// dataSourceOutboundSequenceRead retrieves by name the id in question
func dataSourceOutboundSequenceRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newOutboundSequenceProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                campaignSequenceId, retryable, err := proxy.getOutboundSequenceIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error searching outbound sequence %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No outbound sequence found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(campaignSequenceId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package outbound_sequence

import (
        "context"
        "fmt"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
)

/*
The genesyscloud_outbound_sequence_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *outboundSequenceProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createOutboundSequenceFunc func(ctx context.Context, p *outboundSequenceProxy, campaignSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error)
type getAllOutboundSequenceFunc func(ctx context.Context, p *outboundSequenceProxy) (*[]platformclientv2.Campaignsequence, error)
type getOutboundSequenceIdByNameFunc func(ctx context.Context, p *outboundSequenceProxy, name string) (id string, retryable bool, err error)
type getOutboundSequenceByIdFunc func(ctx context.Context, p *outboundSequenceProxy, id string) (campaignSequence *platformclientv2.Campaignsequence, responseCode int, err error)
type updateOutboundSequenceFunc func(ctx context.Context, p *outboundSequenceProxy, id string, campaignSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error)
type deleteOutboundSequenceFunc func(ctx context.Context, p *outboundSequenceProxy, id string) (responseCode int, err error)

// outboundSequenceProxy contains all of the methods that call genesys cloud APIs.
type outboundSequenceProxy struct {
        clientConfig                    *platformclientv2.Configuration
        outboundApi                     *platformclientv2.OutboundApi
        createOutboundSequenceAttr      createOutboundSequenceFunc
        getAllOutboundSequenceAttr      getAllOutboundSequenceFunc
        getOutboundSequenceIdByNameAttr getOutboundSequenceIdByNameFunc
        getOutboundSequenceByIdAttr     getOutboundSequenceByIdFunc
        updateOutboundSequenceAttr      updateOutboundSequenceFunc
        deleteOutboundSequenceAttr      deleteOutboundSequenceFunc
}

// newOutboundSequenceProxy initializes the outbound sequence proxy with all of the data needed to communicate with Genesys Cloud
func newOutboundSequenceProxy(clientConfig *platformclientv2.Configuration) *outboundSequenceProxy <span class="cov8" title="1">{
        api := platformclientv2.NewOutboundApiWithConfig(clientConfig)
        return &amp;outboundSequenceProxy{
                clientConfig:                    clientConfig,
                outboundApi:                     api,
                createOutboundSequenceAttr:      createOutboundSequenceFn,
                getAllOutboundSequenceAttr:      getAllOutboundSequenceFn,
                getOutboundSequenceIdByNameAttr: getOutboundSequenceIdByNameFn,
                getOutboundSequenceByIdAttr:     getOutboundSequenceByIdFn,
                updateOutboundSequenceAttr:      updateOutboundSequenceFn,
                deleteOutboundSequenceAttr:      deleteOutboundSequenceFn,
        }
}</span>

// getOutboundSequenceProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getOutboundSequenceProxy(clientConfig *platformclientv2.Configuration) *outboundSequenceProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newOutboundSequenceProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// createOutboundSequence creates a Genesys Cloud outbound sequence
func (p *outboundSequenceProxy) createOutboundSequence(ctx context.Context, outboundSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error) <span class="cov8" title="1">{
        return p.createOutboundSequenceAttr(ctx, p, outboundSequence)
}</span>

// getOutboundSequence retrieves all Genesys Cloud outbound sequence
func (p *outboundSequenceProxy) getAllOutboundSequence(ctx context.Context) (*[]platformclientv2.Campaignsequence, error) <span class="cov0" title="0">{
        return p.getAllOutboundSequenceAttr(ctx, p)
}</span>

// getOutboundSequenceIdByName returns a single Genesys Cloud outbound sequence by a name
func (p *outboundSequenceProxy) getOutboundSequenceIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getOutboundSequenceIdByNameAttr(ctx, p, name)
}</span>

// getOutboundSequenceById returns a single Genesys Cloud outbound sequence by Id
func (p *outboundSequenceProxy) getOutboundSequenceById(ctx context.Context, id string) (outboundSequence *platformclientv2.Campaignsequence, statusCode int, err error) <span class="cov8" title="1">{
        return p.getOutboundSequenceByIdAttr(ctx, p, id)
}</span>

// updateOutboundSequence updates a Genesys Cloud outbound sequence
func (p *outboundSequenceProxy) updateOutboundSequence(ctx context.Context, id string, outboundSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error) <span class="cov8" title="1">{
        return p.updateOutboundSequenceAttr(ctx, p, id, outboundSequence)
}</span>

// deleteOutboundSequence deletes a Genesys Cloud outbound sequence by Id
func (p *outboundSequenceProxy) deleteOutboundSequence(ctx context.Context, id string) (statusCode int, err error) <span class="cov8" title="1">{
        return p.deleteOutboundSequenceAttr(ctx, p, id)
}</span>

// createOutboundSequenceFn is an implementation function for creating a Genesys Cloud outbound sequence
func createOutboundSequenceFn(ctx context.Context, p *outboundSequenceProxy, outboundSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error) <span class="cov8" title="1">{
        campaignSequence, _, err := p.outboundApi.PostOutboundSequences(*outboundSequence)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create outbound sequence: %s", err)
        }</span>

        <span class="cov8" title="1">return campaignSequence, nil</span>
}

// getAllOutboundSequenceFn is the implementation for retrieving all outbound sequence in Genesys Cloud
func getAllOutboundSequenceFn(ctx context.Context, p *outboundSequenceProxy) (*[]platformclientv2.Campaignsequence, error) <span class="cov0" title="0">{
        var allCampaignSequences []platformclientv2.Campaignsequence
        const pageSize = 100

        campaignSequences, _, err := p.outboundApi.GetOutboundSequences(pageSize, 1, true, "", "", "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to get campaign sequence: %v", err)
        }</span>
        <span class="cov0" title="0">if campaignSequences.Entities == nil || len(*campaignSequences.Entities) == 0 </span><span class="cov0" title="0">{
                return &amp;allCampaignSequences, nil
        }</span>
        <span class="cov0" title="0">for _, campaignSequence := range *campaignSequences.Entities </span><span class="cov0" title="0">{
                allCampaignSequences = append(allCampaignSequences, campaignSequence)
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *campaignSequences.PageCount; pageNum++ </span><span class="cov0" title="0">{
                campaignSequences, _, err := p.outboundApi.GetOutboundSequences(pageSize, pageNum, true, "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to get campaign sequence: %v", err)
                }</span>

                <span class="cov0" title="0">if campaignSequences.Entities == nil || len(*campaignSequences.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, campaignSequence := range *campaignSequences.Entities </span><span class="cov0" title="0">{
                        allCampaignSequences = append(allCampaignSequences, campaignSequence)
                }</span>
        }

        <span class="cov0" title="0">return &amp;allCampaignSequences, nil</span>
}

// getOutboundSequenceIdByNameFn is an implementation of the function to get a Genesys Cloud outbound sequence by name
func getOutboundSequenceIdByNameFn(ctx context.Context, p *outboundSequenceProxy, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        campaignSequences, _, err := p.outboundApi.GetOutboundSequences(100, 1, true, "", name, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov8" title="1">if campaignSequences.Entities == nil || len(*campaignSequences.Entities) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("No outbound sequence found with name %s", name)
        }</span>

        <span class="cov8" title="1">for _, campaignSequence := range *campaignSequences.Entities </span><span class="cov8" title="1">{
                if *campaignSequence.Name == name </span><span class="cov8" title="1">{
                        log.Printf("Retrieved the outbound sequence id %s by name %s", *campaignSequence.Id, name)
                        return *campaignSequence.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("Unable to find outbound sequence with name %s", name)</span>
}

// getOutboundSequenceByIdFn is an implementation of the function to get a Genesys Cloud outbound sequence by Id
func getOutboundSequenceByIdFn(ctx context.Context, p *outboundSequenceProxy, id string) (outboundSequence *platformclientv2.Campaignsequence, statusCode int, err error) <span class="cov8" title="1">{
        campaignSequence, resp, err := p.outboundApi.GetOutboundSequence(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve outbound sequence by id %s: %s", id, err)
        }</span>

        <span class="cov8" title="1">return campaignSequence, resp.StatusCode, nil</span>
}

// updateOutboundSequenceFn is an implementation of the function to update a Genesys Cloud outbound sequence
func updateOutboundSequenceFn(ctx context.Context, p *outboundSequenceProxy, id string, outboundSequence *platformclientv2.Campaignsequence) (*platformclientv2.Campaignsequence, error) <span class="cov8" title="1">{
        sequence, _, err := getOutboundSequenceByIdFn(ctx, p, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to sequence by id %s: %s", id, err)
        }</span>

        <span class="cov8" title="1">outboundSequence.Version = sequence.Version
        campaignSequence, _, err := p.outboundApi.PutOutboundSequence(id, *outboundSequence)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update outbound sequence: %s", err)
        }</span>
        <span class="cov8" title="1">return campaignSequence, nil</span>
}

// deleteOutboundSequenceFn is an implementation function for deleting a Genesys Cloud outbound sequence
func deleteOutboundSequenceFn(ctx context.Context, p *outboundSequenceProxy, id string) (statusCode int, err error) <span class="cov8" title="1">{
        resp, err := p.outboundApi.DeleteOutboundSequence(id)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete outbound sequence: %s", err)
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package outbound_sequence

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "log"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "time"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

/*
The resource_genesyscloud_outbound_sequence.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthOutboundSequence retrieves all of the outbound sequence via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthOutboundSequences(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := newOutboundSequenceProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        campaignSequences, err := proxy.getAllOutboundSequence(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get outbound sequence: %v", err)
        }</span>

        <span class="cov0" title="0">for _, campaignSequence := range *campaignSequences </span><span class="cov0" title="0">{
                resources[*campaignSequence.Id] = &amp;resourceExporter.ResourceMeta{Name: *campaignSequence.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createOutboundSequence is used by the outbound_sequence resource to create Genesys cloud outbound sequence
func createOutboundSequence(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundSequenceProxy(sdkConfig)
        status := d.Get("status").(string)

        outboundSequence := getOutboundSequenceFromResourceData(d)

        log.Printf("Creating outbound sequence %s", *outboundSequence.Name)
        campaignSequence, err := proxy.createOutboundSequence(ctx, &amp;outboundSequence)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create outbound sequence: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*campaignSequence.Id)
        // Campaigns sequences can be enabled after creation
        if status == "on" </span><span class="cov8" title="1">{
                d.Set("status", status)
                diag := updateOutboundSequence(ctx, d, meta)
                if diag != nil </span><span class="cov0" title="0">{
                        return diag
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Created outbound sequence %s", *campaignSequence.Id)
        return readOutboundSequence(ctx, d, meta)</span>
}

// readOutboundSequence is used by the outbound_sequence resource to read an outbound sequence from genesys cloud
func readOutboundSequence(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundSequenceProxy(sdkConfig)

        log.Printf("Reading outbound sequence %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                campaignSequence, respCode, getErr := proxy.getOutboundSequenceById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read outbound sequence %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read outbound sequence %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundSequence())

                resourcedata.SetNillableValue(d, "name", campaignSequence.Name)
                if campaignSequence.Campaigns != nil </span><span class="cov8" title="1">{
                        d.Set("campaign_ids", gcloud.SdkDomainEntityRefArrToList(*campaignSequence.Campaigns))
                }</span>
                <span class="cov8" title="1">resourcedata.SetNillableValue(d, "status", campaignSequence.Status)
                resourcedata.SetNillableValue(d, "repeat", campaignSequence.Repeat)

                log.Printf("Read outbound sequence %s %s", d.Id(), *campaignSequence.Name)
                return cc.CheckState()</span>
        })
}

// updateOutboundSequence is used by the outbound_sequence resource to update an outbound sequence in Genesys Cloud
func updateOutboundSequence(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundSequenceProxy(sdkConfig)
        status := d.Get("status").(string)

        outboundSequence := getOutboundSequenceFromResourceData(d)
        if status != "off" </span><span class="cov8" title="1">{
                outboundSequence.Status = &amp;status
        }</span>

        <span class="cov8" title="1">log.Printf("Updating outbound sequence %s", *outboundSequence.Name)
        campaignSequence, err := proxy.updateOutboundSequence(ctx, d.Id(), &amp;outboundSequence)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update outbound sequence: %s", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated outbound sequence %s", *campaignSequence.Id)
        return readOutboundSequence(ctx, d, meta)</span>
}

// deleteOutboundSequence is used by the outbound_sequence resource to delete an outbound sequence from Genesys cloud
func deleteOutboundSequence(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundSequenceProxy(sdkConfig)

        // Sequence can't be deleted while running
        sequence, _, err := proxy.getOutboundSequenceById(ctx, d.Id())
        if *sequence.Status == "on" </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to get outbound sequence %s: %s", d.Id(), err)
                }</span>
                <span class="cov8" title="1">sequence.Status = platformclientv2.String("off")
                _, err = proxy.updateOutboundSequence(ctx, d.Id(), sequence)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("Failed to turn off outbound sequence %s: %s", d.Id(), err)
                }</span>
                <span class="cov8" title="1">time.Sleep(20 * time.Second)</span> // Give the sequence a chance to turned off
        }

        <span class="cov8" title="1">_, err = proxy.deleteOutboundSequence(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete outbound sequence %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, respCode, err := proxy.getOutboundSequenceById(ctx, d.Id())

                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                                log.Printf("Deleted outbound sequence %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting outbound sequence %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("outbound sequence %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package outbound_sequence

import (
        "context"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_outbound_sequence_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the outbound_sequence resource.
3.  The datasource schema definitions for the outbound_sequence datasource.
4.  The resource exporter configuration for the outbound_sequence exporter.
*/
const resourceName = "genesyscloud_outbound_sequence"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceOutboundSequence())
        regInstance.RegisterDataSource(resourceName, DataSourceOutboundSequence())
        regInstance.RegisterExporter(resourceName, OutboundSequenceExporter())
}</span>

// ResourceOutboundSequence registers the genesyscloud_outbound_sequence resource with Terraform
func ResourceOutboundSequence() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound sequence`,

                CreateContext: gcloud.CreateWithPooledClient(createOutboundSequence),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundSequence),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundSequence),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundSequence),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `Name of outbound sequence`,
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        `campaign_ids`: {
                                Description: `The ordered list of Campaigns that this CampaignSequence will run.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        `status`: {
                                Description:  `The current status of the CampaignSequence. A CampaignSequence can be turned 'on' or 'off' (default). Changing from "on" to "off" will cause the current sequence to drop and be recreated with a new ID.`,
                                Optional:     true,
                                Computed:     true,
                                Type:         schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{`on`, `off`}, false),
                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov8" title="1">{
                                        return (old == `complete` &amp;&amp; new == `on`)
                                }</span>,
                        },
                        `repeat`: {
                                Description: `Indicates if a sequence should repeat from the beginning after the last campaign completes. Default is false.`,
                                Optional:    true,
                                Type:        schema.TypeBool,
                        },
                },
                CustomizeDiff: customdiff.ForceNewIfChange("status", func(ctx context.Context, old, new, meta any) bool <span class="cov8" title="1">{
                        return new.(string) == "off" &amp;&amp; (old.(string) == "on" || old.(string) == "complete")
                }</span>),
        }
}

// OutboundSequenceExporter returns the resourceExporter object used to hold the genesyscloud_outbound_sequence exporter's config
func OutboundSequenceExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthOutboundSequences),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        `campaign_ids`: {
                                RefType: "genesyscloud_outbound_campaign",
                        },
                },
        }
}</span>

// DataSourceOutboundSequence registers the genesyscloud_outbound_sequence data source
func DataSourceOutboundSequence() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud outbound sequence data source. Select an outbound sequence by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceOutboundSequenceRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `Outbound Sequence name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package outbound_sequence

import (
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
        "strings"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
The resource_genesyscloud_outbound_sequence.go contains all of the methods that perform the core logic for a resource.
*/

// getOutboundSequenceFromResourceData maps data from schema ResourceData object to a platformclientv2.Campaignsequence
func getOutboundSequenceFromResourceData(d *schema.ResourceData) platformclientv2.Campaignsequence <span class="cov8" title="1">{
        return platformclientv2.Campaignsequence{
                Name:      platformclientv2.String(d.Get("name").(string)),
                Campaigns: gcloud.BuildSdkDomainEntityRefArr(d, "campaign_ids"),
                Status:    platformclientv2.String("off"), // This will be updated separately
                Repeat:    platformclientv2.Bool(d.Get("repeat").(bool)),
        }
}</span>

func GenerateOutboundSequence(
        resourceId string,
        name string,
        campaignIds []string,
        status string,
        repeat string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`
                resource "genesyscloud_outbound_sequence" "%s" {
                        name = "%s"
                        campaign_ids = [%s]
                        status = %s
                        repeat = %s
                }
        `, resourceId, name, strings.Join(campaignIds, ", "), status, repeat)
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package outbound_wrapupcode_mappings

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var internalProxy *outboundWrapupCodeMappingsProxy

type getAllOutboundWrapupCodeMappingsFunc func(ctx context.Context, p *outboundWrapupCodeMappingsProxy) (wrapupcodeMappings *platformclientv2.Wrapupcodemapping, resp *platformclientv2.APIResponse, err error)
type updateOutboundWrapUpCodeMappingsFunc func(ctx context.Context, p *outboundWrapupCodeMappingsProxy, outBoundWrappingCodes *platformclientv2.Wrapupcodemapping) (updatedWrapupCodeMappings *platformclientv2.Wrapupcodemapping, resp *platformclientv2.APIResponse, err error)

type outboundWrapupCodeMappingsProxy struct {
        clientConfig                         *platformclientv2.Configuration
        outboundApi                          *platformclientv2.OutboundApi
        getAllOutboundWrapupCodeMappingsAttr getAllOutboundWrapupCodeMappingsFunc
        updateOutboundWrapUpCodeMappingsAttr updateOutboundWrapUpCodeMappingsFunc
}

// newOutboundWrapupCodeMappingsProxy is a constructor to create a new outboundWrapupCodeMappingsProxy struct instance
func newOutboundWrapupCodeMappingsProxy(clientConfig *platformclientv2.Configuration) *outboundWrapupCodeMappingsProxy <span class="cov8" title="1">{
        api := platformclientv2.NewOutboundApiWithConfig(clientConfig)
        return &amp;outboundWrapupCodeMappingsProxy{
                clientConfig:                         clientConfig,
                outboundApi:                          api,
                getAllOutboundWrapupCodeMappingsAttr: getAllOutboundWrapupCodeMappingsFn,
                updateOutboundWrapUpCodeMappingsAttr: updateOutboundWrapUpCodeMappingsFn,
        }
}</span>

// etOutboundWrapupCodeMappingsProxy is a singleton method to return a single instance outboundWrapupCodeMappingsProxy
func getOutboundWrapupCodeMappingsProxy(clientConfig *platformclientv2.Configuration) *outboundWrapupCodeMappingsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newOutboundWrapupCodeMappingsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllOutboundWrapupCodeMapping returns all of the outbound mapping.  This is the struct implementation that should be consumed by everypne.
func (p *outboundWrapupCodeMappingsProxy) getAllOutboundWrapupCodeMappings(ctx context.Context) (wrapupcodeMappings *platformclientv2.Wrapupcodemapping, resp *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.getAllOutboundWrapupCodeMappingsAttr(ctx, p)
}</span>

// updateOutboundWrapUpCodeMapping updates the outbound mappings.  This is the struct implementation that should be consumed by everyone.
func (p *outboundWrapupCodeMappingsProxy) updateOutboundWrapUpCodeMappings(ctx context.Context, outBoundWrapupCodes platformclientv2.Wrapupcodemapping) (updatedWrapupCodeMappings *platformclientv2.Wrapupcodemapping, response *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.updateOutboundWrapUpCodeMappingsAttr(ctx, p, &amp;outBoundWrapupCodes)
}</span>

// getAllOutboundWrapupCodeMappingsFn( is the implementation of the getAllOutboundWrapupCodeMappings call
func getAllOutboundWrapupCodeMappingsFn(ctx context.Context, p *outboundWrapupCodeMappingsProxy) (wrapupcodeMappings *platformclientv2.Wrapupcodemapping, resp *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        wrapupcodemappings, resp, err := p.outboundApi.GetOutboundWrapupcodemappings()
        return wrapupcodemappings, resp, err
}</span>

// updateOutboundWrapUpCodeMappingsFn is the implementation of the updateOutboundWrapUpCodeMappings call
func updateOutboundWrapUpCodeMappingsFn(ctx context.Context, p *outboundWrapupCodeMappingsProxy, outBoundWrapupCodes *platformclientv2.Wrapupcodemapping) (updatedWrapupCodeMappings *platformclientv2.Wrapupcodemapping, resp *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        w, resp, err := p.outboundApi.PutOutboundWrapupcodemappings(*outBoundWrapupCodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, fmt.Errorf("failed to update wrap-up code mappings: %s", err)
        }</span>
        <span class="cov8" title="1">return w, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package outbound_wrapupcode_mappings

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const resourceName = "genesyscloud_outbound_wrapupcodemappings"

// SetRegistrar registers the resource objects and the exporter.  Note:  There is no datasource implementation
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterResource(resourceName, ResourceOutboundWrapUpCodeMappings())
        l.RegisterExporter(resourceName, OutboundWrapupCodeMappingsExporter())
}</span>

// OutboundWrapupCodeMappingsExporter() returns the exporter used for exporting the outbound wrapping codes
func OutboundWrapupCodeMappingsExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getOutboundWrapupCodeMappings),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        `mappings.wrapup_code_id`: {
                                RefType: `genesyscloud_routing_wrapupcode`,
                        },
                },
        }
}</span>

// ResourceOutboundWrapUpCodeMappings returns the schema definition for outbound wrappings
func ResourceOutboundWrapUpCodeMappings() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description:   `Genesys Cloud Outbound Wrap-up Code Mappings`,
                CreateContext: gcloud.CreateWithPooledClient(createOutboundWrapUpCodeMappings),
                ReadContext:   gcloud.ReadWithPooledClient(readOutboundWrapUpCodeMappings),
                UpdateContext: gcloud.UpdateWithPooledClient(updateOutboundWrapUpCodeMappings),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteOutboundWrapUpCodeMappings),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `default_set`: {
                                Description: `The default set of wrap-up flags. These will be used if there is no entry for a given wrap-up code in the mapping.`,
                                Optional:    true,
                                Type:        schema.TypeList,
                                Elem: &amp;schema.Schema{
                                        Type:         schema.TypeString,
                                        ValidateFunc: validation.StringInSlice([]string{"CONTACT_UNCALLABLE", "NUMBER_UNCALLABLE", "RIGHT_PARTY_CONTACT"}, true),
                                },
                        },
                        `mappings`: {
                                Description: `A map from wrap-up code identifiers to a set of wrap-up flags.`,
                                Required:    true,
                                Type:        schema.TypeList,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                `wrapup_code_id`: {
                                                        Description: `The wrap-up code identifier.`,
                                                        Required:    true,
                                                        Type:        schema.TypeString,
                                                },
                                                `flags`: {
                                                        Description: `The set of wrap-up flags.`,
                                                        Required:    true,
                                                        Type:        schema.TypeList,
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice([]string{"CONTACT_UNCALLABLE", "NUMBER_UNCALLABLE", "RIGHT_PARTY_CONTACT"}, true),
                                                        },
                                                },
                                        },
                                },
                        },
                        `placeholder`: {
                                Description:  `Placeholder data used internally by the provider.`,
                                Optional:     true,
                                Type:         schema.TypeString,
                                Default:      "***",
                                ValidateFunc: validation.StringIsNotEmpty,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package outbound_wrapupcode_mappings

import (
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// flattenOutboundWrapupCodeMappings maps objects and flags lists come back ordered differently than what is defined by the user in their config
// To avoid plan not empty errors, this function:
// checks that the maps/lists from the schema &amp; sdk returned data are equivalent before returning the data in it's original order.
func flattenOutboundWrapupCodeMappings(d *schema.ResourceData, sdkWrapupcodemapping *platformclientv2.Wrapupcodemapping) []interface{} <span class="cov8" title="1">{
        mappings := make([]interface{}, 0)
        schemaMappings := d.Get("mappings").([]interface{})

        // If read is called from export function, placeholder field should not exist
        // In this case, dump whatever is returned from the API.
        if _, exists := d.GetOkExists("placeholder"); !exists </span><span class="cov8" title="1">{
                for sdkId, sdkFlags := range *sdkWrapupcodemapping.Mapping </span><span class="cov8" title="1">{
                        currentMap := make(map[string]interface{}, 0)
                        currentMap["wrapup_code_id"] = sdkId
                        currentMap["flags"] = lists.StringListToInterfaceList(sdkFlags)
                        mappings = append(mappings, currentMap)
                }</span>
                <span class="cov8" title="1">return mappings</span>
        }

        <span class="cov8" title="1">for _, m := range schemaMappings </span><span class="cov8" title="1">{
                if mMap, ok := m.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        var schemaFlags []string
                        if flags, ok := mMap["flags"].([]interface{}); ok </span><span class="cov8" title="1">{
                                schemaFlags = lists.InterfaceListToStrings(flags)
                        }</span>
                        <span class="cov8" title="1">for sdkId, sdkFlags := range *sdkWrapupcodemapping.Mapping </span><span class="cov8" title="1">{
                                if mMap["wrapup_code_id"].(string) == sdkId </span><span class="cov8" title="1">{
                                        currentMap := make(map[string]interface{}, 0)
                                        currentMap["wrapup_code_id"] = sdkId
                                        if lists.AreEquivalent(schemaFlags, sdkFlags) </span><span class="cov8" title="1">{
                                                currentMap["flags"] = lists.StringListToInterfaceList(schemaFlags)
                                        }</span> else<span class="cov0" title="0"> {
                                                currentMap["flags"] = lists.StringListToInterfaceList(sdkFlags)
                                        }</span>
                                        <span class="cov8" title="1">mappings = append(mappings, currentMap)</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return mappings</span>
}

// buildWrapupCodeMappings builds the list of wrapupcode mappings from the schema object
func buildWrapupCodeMappings(d *schema.ResourceData) *map[string][]string <span class="cov8" title="1">{
        wrapupCodeMappings := make(map[string][]string, 0)
        if mappings := d.Get("mappings").([]interface{}); mappings != nil &amp;&amp; len(mappings) &gt; 0 </span><span class="cov8" title="1">{
                for _, m := range mappings </span><span class="cov8" title="1">{
                        if mapping, ok := m.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                id := mapping["wrapup_code_id"].(string)
                                flags := lists.InterfaceListToStrings(mapping["flags"].([]interface{}))
                                wrapupCodeMappings[id] = flags
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;wrapupCodeMappings</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package outbound_wrapupcode_mappings

import (
        "context"
        "fmt"
        "log"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// getOutboundWrapupCodeMappings is used by the exporter to return all wrapupcode mappings
func getOutboundWrapupCodeMappings(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := getOutboundWrapupCodeMappingsProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        _, resp, err := proxy.getAllOutboundWrapupCodeMappings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                        // Don't export if config doesn't exist
                        return resources, nil
                }</span>
                <span class="cov0" title="0">return nil, diag.Errorf("Failed to get wrap-up code mappings: %v", err)</span>
        }

        <span class="cov0" title="0">resources["0"] = &amp;resourceExporter.ResourceMeta{Name: "wrapupcodemappings"}
        return resources, nil</span>
}

// createOutboundWrapUpCodeMappings is used to create the Terraform backing state associated with an outbound wrapup code mapping
func createOutboundWrapUpCodeMappings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        log.Printf("Creating Outbound Wrap-up Code Mappings")
        d.SetId("wrapupcodemappings")
        return updateOutboundWrapUpCodeMappings(ctx, d, meta)
}</span>

// updateOutboundWrapUpCodeMappings is sued to update the Terraform backing state associated with an outbound wrapup code mapping
func updateOutboundWrapUpCodeMappings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundWrapupCodeMappingsProxy(sdkConfig)

        log.Printf("Updating Outbound Wrap-up Code Mappings")
        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                wrapupCodeMappings, resp, err := proxy.getAllOutboundWrapupCodeMappings(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("failed to read wrap-up code mappings: %s", err)
                }</span>

                <span class="cov8" title="1">wrapupCodeUpdate := platformclientv2.Wrapupcodemapping{
                        DefaultSet: lists.BuildSdkStringListFromInterfaceArray(d, "default_set"),
                        Mapping:    buildWrapupCodeMappings(d),
                        Version:    wrapupCodeMappings.Version,
                }
                _, _, err = proxy.updateOutboundWrapUpCodeMappings(ctx, wrapupCodeUpdate)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("failed to update wrap-up code mappings: %s", err)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })

        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Print("Updated Outbound Wrap-up Code Mappings")
        return readOutboundWrapUpCodeMappings(ctx, d, meta)</span>
}

// readOutboundWrapUpCodeMappings reads the current state of the outboundwrapupcode mapping object
func readOutboundWrapUpCodeMappings(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getOutboundWrapupCodeMappingsProxy(sdkConfig)

        log.Printf("Reading Outbound Wrap-up Code Mappings")

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                sdkWrapupCodeMappings, resp, err := proxy.getAllOutboundWrapupCodeMappings(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Outbound Wrap-up Code Mappings: %s", err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Outbound Wrap-up Code Mappings: %s", err))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceOutboundWrapUpCodeMappings())

                // Match new random ordering of list returned from API
                if sdkWrapupCodeMappings.DefaultSet != nil </span><span class="cov8" title="1">{
                        defaultSet := make([]string, 0)
                        schemaDefaultSet := d.Get("default_set").([]interface{})
                        for _, v := range schemaDefaultSet </span><span class="cov8" title="1">{
                                defaultSet = append(defaultSet, v.(string))
                        }</span>
                        <span class="cov8" title="1">if lists.AreEquivalent(defaultSet, *sdkWrapupCodeMappings.DefaultSet) </span><span class="cov8" title="1">{
                                d.Set("default_set", defaultSet)
                        }</span> else<span class="cov8" title="1"> {
                                d.Set("default_set", lists.StringListToInterfaceList(*sdkWrapupCodeMappings.DefaultSet))
                        }</span>
                }

                <span class="cov8" title="1">if sdkWrapupCodeMappings.Mapping != nil </span><span class="cov8" title="1">{
                        d.Set("mappings", flattenOutboundWrapupCodeMappings(d, sdkWrapupCodeMappings))
                }</span>

                <span class="cov8" title="1">log.Print("Read Outbound Wrap-up Code Mappings")
                return cc.CheckState()</span>
        })
}

// deleteOutboundWrapUpCodeMappings This a no up to satisfy the deletion of outbound wrapping resource
func deleteOutboundWrapUpCodeMappings(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics <span class="cov8" title="1">{
        // Does not delete the wrap-up code mappings. This resource will just no longer manage them.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package process_automation_trigger

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

type ProcessAutomationTriggers struct {
        Entities *[]ProcessAutomationTrigger `json:"entities,omitempty"`
        NextUri  *string                     `json:"nextUri,omitempty"`
}

func dataSourceProcessAutomationTrigger() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud process automation trigger. Select a trigger by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceProcessAutomationTriggerRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the trigger",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

func dataSourceProcessAutomationTriggerRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        integrationAPI := platformclientv2.NewIntegrationsApiWithConfig(sdkConfig)

        triggerName := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                // create path
                path := integrationAPI.Configuration.BasePath + "/api/v2/processAutomation/triggers"

                for pageNum := 1; ; pageNum++ </span><span class="cov8" title="1">{
                        processAutomationTriggers, _, getErr := getAllProcessAutomationTriggers(path, integrationAPI)

                        if getErr != nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("failed to get page of process automation triggers: %s", getErr))
                        }</span>

                        <span class="cov8" title="1">if processAutomationTriggers.Entities == nil || len(*processAutomationTriggers.Entities) == 0 </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("no process automation triggers found with name: %s", triggerName))
                        }</span>

                        <span class="cov8" title="1">for _, trigger := range *processAutomationTriggers.Entities </span><span class="cov8" title="1">{
                                if trigger.Name != nil &amp;&amp; *trigger.Name == triggerName </span><span class="cov8" title="1">{
                                        d.SetId(*trigger.Id)
                                        return nil
                                }</span>
                        }

                        <span class="cov0" title="0">if processAutomationTriggers.NextUri == nil </span><span class="cov0" title="0">{
                                return retry.NonRetryableError(fmt.Errorf("no process automation triggers found with name: %s", getErr))
                        }</span>

                        <span class="cov0" title="0">path = integrationAPI.Configuration.BasePath + *processAutomationTriggers.NextUri</span>
                }
        })
}

func getAllProcessAutomationTriggers(path string, api *platformclientv2.IntegrationsApi) (*ProcessAutomationTriggers, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        apiClient := &amp;api.Configuration.APIClient

        headerParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov8" title="1">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov8" title="1">for key := range api.Configuration.DefaultHeader </span><span class="cov8" title="1">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov8" title="1">headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        var successPayload *ProcessAutomationTriggers
        response, err := apiClient.CallAPI(path, http.MethodGet, nil, headerParams, nil, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov8" title="1"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov8" title="1"> {
                err = json.Unmarshal([]byte(response.RawBody), &amp;successPayload)
        }</span>

        <span class="cov8" title="1">return successPayload, response, err</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package process_automation_trigger

import (
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource("genesyscloud_processautomation_trigger", ResourceProcessAutomationTrigger())
        regInstance.RegisterDataSource("genesyscloud_processautomation_trigger", dataSourceProcessAutomationTrigger())
        regInstance.RegisterExporter("genesyscloud_processautomation_trigger", ProcessAutomationTriggerExporter())
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package process_automation_trigger

import (
        "context"
        "encoding/json"
        "errors"
        "log"
        "net/http"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func postProcessAutomationTrigger(pat *ProcessAutomationTrigger, api *platformclientv2.IntegrationsApi) (*ProcessAutomationTrigger, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        apiClient := &amp;api.Configuration.APIClient
        jsonStr, err := pat.toJSONString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">var jsonMap map[string]interface{}
        json.Unmarshal([]byte(jsonStr), &amp;jsonMap)

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/processAutomation/triggers"

        // add default headers if any
        headerParams := make(map[string]string)

        for key := range api.Configuration.DefaultHeader </span><span class="cov8" title="1">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov8" title="1">headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        var successPayload *ProcessAutomationTrigger
        response, err := apiClient.CallAPI(path, http.MethodPost, jsonMap, headerParams, nil, nil, "", nil)

        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov8" title="1"> if response.Error != nil </span><span class="cov0" title="0">{

                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov8" title="1"> {
                err = json.Unmarshal([]byte(response.RawBody), &amp;successPayload)
                log.Printf("Process automation trigger created with Id %s and correlationId: %s", *successPayload.Id, response.CorrelationID)
        }</span>

        <span class="cov8" title="1">return successPayload, response, err</span>
}

func getProcessAutomationTrigger(triggerId string, api *platformclientv2.IntegrationsApi) (*ProcessAutomationTrigger, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        apiClient := &amp;api.Configuration.APIClient

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/processAutomation/triggers/" + triggerId

        headerParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov8" title="1">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov8" title="1">for key := range api.Configuration.DefaultHeader </span><span class="cov8" title="1">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov8" title="1">headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        response, err := apiClient.CallAPI(path, http.MethodGet, nil, headerParams, nil, nil, "", nil)
        if response.Error != nil </span><span class="cov8" title="1">{
                err = errors.New(response.ErrorMessage)
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">successPayload, err := NewProcessAutomationFromPayload(response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, response, err
        }</span>

        <span class="cov8" title="1">return successPayload, response, err</span>
}

func putProcessAutomationTrigger(triggerId string, pat *ProcessAutomationTrigger, api *platformclientv2.IntegrationsApi) (*ProcessAutomationTrigger, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        apiClient := &amp;api.Configuration.APIClient
        jsonStr, err := pat.toJSONString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">var jsonMap map[string]interface{}
        json.Unmarshal([]byte(jsonStr), &amp;jsonMap)

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/processAutomation/triggers/" + triggerId
        headerParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov8" title="1">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov8" title="1">for key := range api.Configuration.DefaultHeader </span><span class="cov8" title="1">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov8" title="1">headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        var successPayload *ProcessAutomationTrigger
        response, err := apiClient.CallAPI(path, http.MethodPut, jsonMap, headerParams, nil, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov8" title="1"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span> else<span class="cov8" title="1"> {
                err = json.Unmarshal([]byte(response.RawBody), &amp;successPayload)
                log.Printf("Process automation trigger updated with Id %s and correlationId: %s", *successPayload.Id, response.CorrelationID)
        }</span>
        <span class="cov8" title="1">return successPayload, response, err</span>
}

func deleteProcessAutomationTrigger(triggerId string, api *platformclientv2.IntegrationsApi) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        apiClient := &amp;api.Configuration.APIClient

        // create path and map variables
        path := api.Configuration.BasePath + "/api/v2/processAutomation/triggers/" + triggerId

        headerParams := make(map[string]string)

        // oauth required
        if api.Configuration.AccessToken != "" </span><span class="cov8" title="1">{
                headerParams["Authorization"] = "Bearer " + api.Configuration.AccessToken
        }</span>
        // add default headers if any
        <span class="cov8" title="1">for key := range api.Configuration.DefaultHeader </span><span class="cov8" title="1">{
                headerParams[key] = api.Configuration.DefaultHeader[key]
        }</span>

        <span class="cov8" title="1">headerParams["Content-Type"] = "application/json"
        headerParams["Accept"] = "application/json"

        response, err := apiClient.CallAPI(path, http.MethodDelete, nil, headerParams, nil, nil, "", nil)
        if err != nil </span>{<span class="cov0" title="0">
                // Nothing special to do here, but do avoid processing the response
        }</span> else<span class="cov8" title="1"> if response.Error != nil </span><span class="cov0" title="0">{
                err = errors.New(response.ErrorMessage)
        }</span>

        <span class="cov8" title="1">return response, err</span>
}

func getAllProcessAutomationTriggersResourceMap(_ context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        integAPI := platformclientv2.NewIntegrationsApiWithConfig(clientConfig)

        // create path and map variables
        path := integAPI.Configuration.BasePath + "/api/v2/processAutomation/triggers"

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                processAutomationTriggers, _, getErr := getAllProcessAutomationTriggers(path, integAPI)

                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, diag.Errorf("failed to get page of process automation triggers: %v", getErr)
                }</span>

                <span class="cov0" title="0">if processAutomationTriggers.Entities == nil || len(*processAutomationTriggers.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, trigger := range *processAutomationTriggers.Entities </span><span class="cov0" title="0">{
                        resources[*trigger.Id] = &amp;resourceExporter.ResourceMeta{Name: *trigger.Name}
                }</span>

                <span class="cov0" title="0">if processAutomationTriggers.NextUri == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">path = integAPI.Configuration.BasePath + *processAutomationTriggers.NextUri</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package process_automation_trigger

import (
        "encoding/json"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

type ProcessAutomationTrigger struct {
        Id              *string `json:"id,omitempty"`
        TopicName       *string `json:"topicName,omitempty"`
        Name            *string `json:"name,omitempty"`
        Target          *Target `json:"target,omitempty"`
        MatchCriteria   *string `json:"-"`
        Enabled         *bool   `json:"enabled,omitempty"`
        EventTTLSeconds *int    `json:"eventTTLSeconds,omitempty"`
        DelayBySeconds  *int    `json:"delayBySeconds,omitempty"`
        Version         *int    `json:"version,omitempty"`
        Description     *string `json:"description,omitempty"`
}

type WorkflowTargetSettings struct {
        DataFormat *string `json:"dataFormat,omitempty"`
}

type Target struct {
        Type                   *string                 `json:"type,omitempty"`
        Id                     *string                 `json:"id,omitempty"`
        WorkflowTargetSettings *WorkflowTargetSettings `json:"workflowTargetSettings,omitempty"`
}

func (p *ProcessAutomationTrigger) toJSONString() (string, error) <span class="cov8" title="1">{
        //Step #1: Converting the process automation trigger to a JSON byte arrays
        b, err := json.Marshal(p)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">patJson := string(b)

        //Step #2: Converting the JSON string to a Golang Map
        var patMap map[string]interface{}
        err = json.Unmarshal([]byte(patJson), &amp;patMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //Step #3: Converting the MatchCriteria field from a string to Map
        <span class="cov8" title="1">var data []map[string]interface{}
        err = json.Unmarshal([]byte(*p.MatchCriteria), &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">matchCriteriaArray := make([]interface{}, len(data))
        for i, obj := range data </span><span class="cov8" title="1">{
                value := make(map[string]interface{})

                value["jsonPath"] = obj["jsonPath"]
                value["operator"] = obj["operator"]
                value["value"] = obj["value"]
                value["values"] = obj["values"]

                matchCriteriaArray[i] = value
        }</span>

        //Step #4: Merging the match criteria array into the main map
        <span class="cov8" title="1">patMap["matchCriteria"] = matchCriteriaArray

        //Step #5: Converting the merged Map into a JSON string
        finalJsonBytes, err := json.Marshal(patMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">finalPAT := string(finalJsonBytes)
        return finalPAT, nil</span>
}

// Constructor that will take an platform client response object and build a new ProcessAutomationTrigger from it
func NewProcessAutomationFromPayload(response *platformclientv2.APIResponse) (*ProcessAutomationTrigger, error) <span class="cov8" title="1">{
        httpPayload := response.RawBody
        pat := &amp;ProcessAutomationTrigger{}
        patMap := make(map[string]interface{})
        err := json.Unmarshal(httpPayload, &amp;patMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">matchCriteria := patMap["matchCriteria"]
        matchCriteriaBytes, err := json.Marshal(matchCriteria)
        matchCriteriaStr := string(matchCriteriaBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(httpPayload, &amp;pat)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">pat.MatchCriteria = &amp;matchCriteriaStr

        return pat, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package process_automation_trigger

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "fmt"
        "log"

        "time"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

var (
        workflowTargetSettings = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "data_format": {
                                Description: "The data format to use when invoking target.",
                                Type:        schema.TypeString,
                                Required:    false,
                                Optional:    true,
                                ValidateFunc: validation.StringInSlice([]string{
                                        "Json",
                                        "TopLevelPrimitives",
                                }, false),
                        },
                },
        }
        target = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "type": {
                                Description: "Type of the target the trigger is configured to hit",
                                Type:        schema.TypeString,
                                Required:    true,
                                ValidateFunc: validation.StringInSlice([]string{
                                        "Workflow",
                                }, false),
                        },
                        "id": {
                                Description: "Id of the target the trigger is configured to hit",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "workflow_target_settings": {
                                Description: "Optional config for the target. Until the feature gets enabled will always operate in TopLevelPrimitives mode.",
                                Type:        schema.TypeSet,
                                Required:    false,
                                Optional:    true,
                                MaxItems:    1,
                                Elem:        workflowTargetSettings,
                        },
                },
        }
)

/*
NOTE:
This resource currently does not use the Go SDk and instead makes API calls directly.
The Go SDK can not properly handle process automation triggers due the value and values
attributes in the matchCriteria object being listed as JsonNode in the swagger docs.
A JsonNode is a placeholder type with no nested values which creates problems in Go
because it can't properly determine a type for the value/values field.
*/
func ResourceProcessAutomationTrigger() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud Process Automation Trigger`,

                CreateContext: gcloud.CreateWithPooledClient(createProcessAutomationTrigger),
                ReadContext:   gcloud.ReadWithPooledClient(readProcessAutomationTrigger),
                UpdateContext: gcloud.UpdateWithPooledClient(updateProcessAutomationTrigger),
                DeleteContext: gcloud.DeleteWithPooledClient(removeProcessAutomationTrigger),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description:  "Name of the Trigger",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringLenBetween(1, 256),
                        },
                        "topic_name": {
                                Description:  "Topic name that will fire trigger. Changing the topic_name attribute will cause the processautomation_trigger object to be dropped and recreated with a new ID. ",
                                Type:         schema.TypeString,
                                Required:     true,
                                ForceNew:     true,
                                ValidateFunc: validation.StringLenBetween(1, 256),
                        },
                        "enabled": {
                                Description: "Whether or not the trigger should be fired on events",
                                Type:        schema.TypeBool,
                                Required:    true,
                        },
                        "target": {
                                Description: "Target the trigger will invoke when fired",
                                Type:        schema.TypeSet,
                                Optional:    false,
                                Required:    true,
                                MaxItems:    1,
                                Elem:        target,
                        },
                        "match_criteria": {
                                Description: "Match criteria that controls when the trigger will fire. NOTE: The match_criteria field type has changed from a complex object to a string. This was done to allow for complex JSON object definitions.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "event_ttl_seconds": {
                                Description:  "How old an event can be to fire the trigger. Must be an number greater than or equal to 10. Only one of event_ttl_seconds or delay_by_seconds can be set.",
                                Type:         schema.TypeInt,
                                Optional:     true,
                                ValidateFunc: validation.IntAtLeast(10),
                        },
                        "delay_by_seconds": {
                                Description:  "How long to delay processing of a trigger after an event passes the match criteria. Must be an number between 60 and 900 inclusive. Only one of event_ttl_seconds or delay_by_seconds can be set.",
                                Type:         schema.TypeInt,
                                Optional:     true,
                                ValidateFunc: validation.IntBetween(60, 900),
                        },
                        "description": {
                                Description:  "A description of the trigger",
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringLenBetween(0, 512),
                        },
                },
        }
}</span>

func ProcessAutomationTriggerExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllProcessAutomationTriggersResourceMap),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "target.id": {RefType: "genesyscloud_flow"},
                },
        }
}</span>

func createProcessAutomationTrigger(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        topic_name := d.Get("topic_name").(string)
        enabled := d.Get("enabled").(bool)
        eventTTLSeconds := d.Get("event_ttl_seconds").(int)
        delayBySeconds := d.Get("delay_by_seconds").(int)
        description := d.Get("description").(string)
        matchingCriteria := d.Get("match_criteria").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        integAPI := platformclientv2.NewIntegrationsApiWithConfig(sdkConfig)

        if eventTTLSeconds &gt; 0 &amp;&amp; delayBySeconds &gt; 0 </span><span class="cov0" title="0">{
                return diag.Errorf("Only one of event_ttl_seconds or delay_by_seconds can be set.")
        }</span>

        <span class="cov8" title="1">log.Printf("Creating process automation trigger %s", name)

        triggerInput := &amp;ProcessAutomationTrigger{
                TopicName:     &amp;topic_name,
                Name:          &amp;name,
                Target:        buildTarget(d),
                MatchCriteria: &amp;matchingCriteria,
                Enabled:       &amp;enabled,
                Description:   &amp;description,
        }

        if eventTTLSeconds &gt; 0 </span><span class="cov8" title="1">{
                triggerInput.EventTTLSeconds = &amp;eventTTLSeconds
        }</span>

        <span class="cov8" title="1">if delayBySeconds &gt; 0 </span><span class="cov8" title="1">{
                triggerInput.DelayBySeconds = &amp;delayBySeconds
        }</span>

        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                trigger, resp, err := postProcessAutomationTrigger(triggerInput, integAPI)

                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to create process automation trigger %s: %s", name, err)
                }</span>
                <span class="cov8" title="1">d.SetId(*trigger.Id)

                log.Printf("Created process automation trigger %s %s", name, *trigger.Id)
                return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return readProcessAutomationTrigger(ctx, d, meta)</span>
}

func readProcessAutomationTrigger(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        integAPI := platformclientv2.NewIntegrationsApiWithConfig(sdkConfig)

        log.Printf("Reading process automation trigger %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                trigger, resp, getErr := getProcessAutomationTrigger(d.Id(), integAPI)
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read process automation trigger %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to process read automation trigger %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceProcessAutomationTrigger())

                if trigger.Name != nil </span><span class="cov8" title="1">{
                        d.Set("name", *trigger.Name)
                }</span> else<span class="cov0" title="0"> {
                        d.Set("name", nil)
                }</span>

                <span class="cov8" title="1">if trigger.TopicName != nil </span><span class="cov8" title="1">{
                        d.Set("topic_name", *trigger.TopicName)
                }</span> else<span class="cov0" title="0"> {
                        d.Set("topic_name", nil)
                }</span>

                <span class="cov8" title="1">d.Set("match_criteria", trigger.MatchCriteria)
                d.Set("target", flattenTarget(trigger.Target))

                if trigger.Enabled != nil </span><span class="cov8" title="1">{
                        d.Set("enabled", *trigger.Enabled)
                }</span> else<span class="cov0" title="0"> {
                        d.Set("enabled", nil)
                }</span>

                <span class="cov8" title="1">if trigger.EventTTLSeconds != nil </span><span class="cov8" title="1">{
                        d.Set("event_ttl_seconds", *trigger.EventTTLSeconds)
                }</span> else<span class="cov8" title="1"> {
                        d.Set("event_ttl_seconds", nil)
                }</span>

                <span class="cov8" title="1">if trigger.DelayBySeconds != nil </span><span class="cov8" title="1">{
                        d.Set("delay_by_seconds", *trigger.DelayBySeconds)
                }</span> else<span class="cov8" title="1"> {
                        d.Set("delay_by_seconds", nil)
                }</span>

                <span class="cov8" title="1">if trigger.Description != nil </span><span class="cov8" title="1">{
                        d.Set("description", *trigger.Description)
                }</span> else<span class="cov0" title="0"> {
                        d.Set("description", nil)
                }</span>

                <span class="cov8" title="1">log.Printf("Read process automation trigger %s %s", d.Id(), *trigger.Name)
                return cc.CheckState()</span>
        })
}

func updateProcessAutomationTrigger(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        enabled := d.Get("enabled").(bool)
        eventTTLSeconds := d.Get("event_ttl_seconds").(int)
        delayBySeconds := d.Get("delay_by_seconds").(int)
        description := d.Get("description").(string)
        matchingCriteria := d.Get("match_criteria").(string)

        topic_name := d.Get("topic_name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        integAPI := platformclientv2.NewIntegrationsApiWithConfig(sdkConfig)

        log.Printf("Updating process automation trigger %s", name)

        diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get the latest trigger version to send with PATCH
                trigger, resp, getErr := getProcessAutomationTrigger(d.Id(), integAPI)
                if getErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read process automation trigger %s: %s", d.Id(), getErr)
                }</span>

                <span class="cov8" title="1">if eventTTLSeconds &gt; 0 &amp;&amp; delayBySeconds &gt; 0 </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Only one of event_ttl_seconds or delay_by_seconds can be set.")
                }</span>

                <span class="cov8" title="1">triggerInput := &amp;ProcessAutomationTrigger{
                        TopicName:     &amp;topic_name,
                        Name:          &amp;name,
                        Enabled:       &amp;enabled,
                        Target:        buildTarget(d),
                        MatchCriteria: &amp;matchingCriteria,
                        Version:       trigger.Version,
                        Description:   &amp;description,
                }

                if eventTTLSeconds &gt; 0 </span><span class="cov8" title="1">{
                        triggerInput.EventTTLSeconds = &amp;eventTTLSeconds
                }</span>

                <span class="cov8" title="1">if delayBySeconds &gt; 0 </span><span class="cov8" title="1">{
                        triggerInput.DelayBySeconds = &amp;delayBySeconds
                }</span>

                <span class="cov8" title="1">_, putResp, err := putProcessAutomationTrigger(d.Id(), triggerInput, integAPI)

                if err != nil </span><span class="cov0" title="0">{
                        return putResp, diag.Errorf("Failed to update process automation trigger %s: %s", name, err)
                }</span>
                <span class="cov8" title="1">return putResp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Updated process automation trigger %s", name)
        return readProcessAutomationTrigger(ctx, d, meta)</span>
}

func removeProcessAutomationTrigger(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        integAPI := platformclientv2.NewIntegrationsApiWithConfig(sdkConfig)

        log.Printf("Deleting process automation trigger %s", name)

        return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                resp, err := deleteProcessAutomationTrigger(d.Id(), integAPI)

                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                log.Printf("process automation trigger already deleted %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("process automation trigger %s still exists", d.Id()))</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

func buildTarget(d *schema.ResourceData) *Target <span class="cov8" title="1">{
        if target := d.Get("target"); target != nil </span><span class="cov8" title="1">{
                if targetList := target.(*schema.Set).List(); len(targetList) &gt; 0 </span><span class="cov8" title="1">{
                        targetMap := targetList[0].(map[string]interface{})

                        targetType := targetMap["type"].(string)
                        id := targetMap["id"].(string)

                        target := &amp;Target{
                                Type: &amp;targetType,
                                Id:   &amp;id,
                        }

                        workflowTargetSettingsInput := targetMap["workflow_target_settings"].(*schema.Set).List()

                        if len(workflowTargetSettingsInput) &gt; 0 </span><span class="cov8" title="1">{
                                workflowTargetSettingsInputMap := workflowTargetSettingsInput[0].(map[string]interface{})
                                dataFormat := workflowTargetSettingsInputMap["data_format"].(string)
                                if dataFormat == "" </span><span class="cov0" title="0">{
                                        return target
                                }</span>
                                <span class="cov8" title="1">target.WorkflowTargetSettings = &amp;WorkflowTargetSettings{
                                        DataFormat: &amp;dataFormat,
                                }</span>
                        }

                        <span class="cov8" title="1">return target</span>
                }
        }

        <span class="cov0" title="0">return &amp;Target{}</span>
}

func flattenTarget(inputTarget *Target) *schema.Set <span class="cov8" title="1">{
        if inputTarget == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">targetSet := schema.NewSet(schema.HashResource(target), []interface{}{})

        flattendedTarget := make(map[string]interface{})
        flattendedTarget["id"] = *inputTarget.Id
        flattendedTarget["type"] = *inputTarget.Type

        if inputTarget.WorkflowTargetSettings != nil </span><span class="cov8" title="1">{
                worklfowTargetSettingsSet := schema.NewSet(schema.HashResource(target), []interface{}{})
                flattendedWorkflowTargetSettings := make(map[string]interface{})
                flattendedWorkflowTargetSettings["data_format"] = *inputTarget.WorkflowTargetSettings.DataFormat
                worklfowTargetSettingsSet.Add(flattendedWorkflowTargetSettings)

                flattendedTarget["workflow_target_settings"] = worklfowTargetSettingsSet
        }</span>
        <span class="cov8" title="1">targetSet.Add(flattendedTarget)

        return targetSet</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package recording_media_retention_policy

import (
        "context"
        "fmt"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
   The data_source_genesyscloud_recording_media_retention_policy.go contains the data source implementation
   for the resource.

   Note:  This code should contain no code for doing the actual lookup in Genesys Cloud.  Instead,
   it should be added to the _proxy.go file for the class using our proxy pattern.
*/

func dataSourceRecordingMediaRetentionPolicyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        pp := getPolicyProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                policy, retryable, err := pp.getPolicyByName(ctx, name)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting media retention policy %s: %s", name, err))
                }</span>

                <span class="cov0" title="0">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no media retention policy found with name %s", name))
                }</span>

                <span class="cov0" title="0">d.SetId(*policy.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package recording_media_retention_policy

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_recording_media_retention_policy_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *policyProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllPoliciesFunc func(ctx context.Context, p *policyProxy) (*[]platformclientv2.Policy, error)
type createPolicyFunc func(ctx context.Context, p *policyProxy, policyCreate *platformclientv2.Policycreate) (*platformclientv2.Policy, *platformclientv2.APIResponse, error)
type getPolicyByIdFunc func(ctx context.Context, p *policyProxy, policyId string) (policy *platformclientv2.Policy, response *platformclientv2.APIResponse, err error)
type getPolicyByNameFunc func(ctx context.Context, p *policyProxy, policyName string) (policy *platformclientv2.Policy, retryable bool, err error)
type updatePolicyFunc func(ctx context.Context, p *policyProxy, policyId string, policy *platformclientv2.Policy) (*platformclientv2.Policy, error)
type deletePolicyFunc func(ctx context.Context, p *policyProxy, policyId string) (responseCode int, err error)
type getFormsEvaluationFunc func(ctx context.Context, p *policyProxy, formId string) (*platformclientv2.Evaluationform, error)
type getEvaluationFormRecentVerIdFunc func(ctx context.Context, p *policyProxy, formId string) (string, error)
type getQualityFormsSurveyByNameFunc func(ctx context.Context, p *policyProxy, surveyName string) (*platformclientv2.Publishedsurveyformreference, error)

// integrationProxy contains all of the methods that call genesys cloud APIs.
type policyProxy struct {
        clientConfig                     *platformclientv2.Configuration
        qualityApi                       *platformclientv2.QualityApi
        recordingApi                     *platformclientv2.RecordingApi
        getAllPoliciesAttr               getAllPoliciesFunc
        createPolicyAttr                 createPolicyFunc
        getPolicyByIdAttr                getPolicyByIdFunc
        getPolicyByNameAttr              getPolicyByNameFunc
        updatePolicyAttr                 updatePolicyFunc
        deletePolicyAttr                 deletePolicyFunc
        getFormsEvaluationAttr           getFormsEvaluationFunc
        getEvaluationFormRecentVerIdAttr getEvaluationFormRecentVerIdFunc
        getQualityFormsSurveyByNameAttr  getQualityFormsSurveyByNameFunc
}

// newPolicyProxy initializes the Policy proxy with all of the data needed to communicate with Genesys Cloud
func newPolicyProxy(clientConfig *platformclientv2.Configuration) *policyProxy <span class="cov0" title="0">{
        qApi := platformclientv2.NewQualityApiWithConfig(clientConfig)
        rApi := platformclientv2.NewRecordingApiWithConfig(clientConfig)
        return &amp;policyProxy{
                clientConfig:                     clientConfig,
                qualityApi:                       qApi,
                recordingApi:                     rApi,
                getAllPoliciesAttr:               getAllPoliciesFn,
                createPolicyAttr:                 createPolicyFn,
                getPolicyByIdAttr:                getPolicyByIdFn,
                getPolicyByNameAttr:              getPolicyByNameFn,
                updatePolicyAttr:                 updatePolicyFn,
                deletePolicyAttr:                 deletePolicyFn,
                getFormsEvaluationAttr:           getFormsEvaluationFn,
                getEvaluationFormRecentVerIdAttr: getEvaluationFormRecentVerIdFn,
                getQualityFormsSurveyByNameAttr:  getQualityFormsSurveyByNameFn,
        }
}</span>

// getPolicyProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getPolicyProxy(clientConfig *platformclientv2.Configuration) *policyProxy <span class="cov0" title="0">{
        if internalProxy == nil </span><span class="cov0" title="0">{
                internalProxy = newPolicyProxy(clientConfig)
        }</span>

        <span class="cov0" title="0">return internalProxy</span>
}

// getAllPolicies retrieves all Genesys Cloud Recording Media Retention Policies
func (p *policyProxy) getAllPolicies(ctx context.Context) (*[]platformclientv2.Policy, error) <span class="cov0" title="0">{
        return p.getAllPoliciesAttr(ctx, p)
}</span>

// createPolicy creates a Genesys Cloud Recording Media Retention Policy
func (p *policyProxy) createPolicy(ctx context.Context, policyCreate *platformclientv2.Policycreate) (*platformclientv2.Policy, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.createPolicyAttr(ctx, p, policyCreate)
}</span>

// getPolicyById gets a Genesys Cloud Recording Media Retention Policy by id
func (p *policyProxy) getPolicyById(ctx context.Context, policyId string) (policy *platformclientv2.Policy, response *platformclientv2.APIResponse, err error) <span class="cov0" title="0">{
        return p.getPolicyByIdAttr(ctx, p, policyId)
}</span>

// getPolicyByName gets a Genesys Cloud Recording Media Retention Policy by name
func (p *policyProxy) getPolicyByName(ctx context.Context, policyName string) (policy *platformclientv2.Policy, retryable bool, err error) <span class="cov0" title="0">{
        return p.getPolicyByNameAttr(ctx, p, policyName)
}</span>

// updatePolicy updates a Genesys Cloud Recording Media Retention Policy
func (p *policyProxy) updatePolicy(ctx context.Context, policyId string, policy *platformclientv2.Policy) (*platformclientv2.Policy, error) <span class="cov0" title="0">{
        return p.updatePolicyAttr(ctx, p, policyId, policy)
}</span>

// deletePolicy deletes a Genesys Cloud Recording Media Retention Policy
func (p *policyProxy) deletePolicy(ctx context.Context, policyId string) (responseCode int, err error) <span class="cov0" title="0">{
        return p.deletePolicyAttr(ctx, p, policyId)
}</span>

// getFormsEvaluation gets a Genesys Cloud Evaluation Form by id
func (p *policyProxy) getFormsEvaluation(ctx context.Context, formId string) (*platformclientv2.Evaluationform, error) <span class="cov0" title="0">{
        return p.getFormsEvaluationAttr(ctx, p, formId)
}</span>

// getFormsEvaluation gets the most recent unpublished version id of a Genesys Cloud Evaluation Form
func (p *policyProxy) getEvaluationFormRecentVerId(ctx context.Context, formId string) (string, error) <span class="cov0" title="0">{
        return p.getEvaluationFormRecentVerIdAttr(ctx, p, formId)
}</span>

// getQualityFormsSurveyByName gets a Genesys Cloud Survey Form by name
func (p *policyProxy) getQualityFormsSurveyByName(ctx context.Context, surveyName string) (*platformclientv2.Publishedsurveyformreference, error) <span class="cov0" title="0">{
        return p.getQualityFormsSurveyByNameAttr(ctx, p, surveyName)
}</span>

// getAllIntegrationCredsFn is the implementation for getting all media retention policy in Genesys Cloud
func getAllPoliciesFn(ctx context.Context, p *policyProxy) (*[]platformclientv2.Policy, error) <span class="cov0" title="0">{
        var allPolicies []platformclientv2.Policy

        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                retentionPolicies, _, err := p.recordingApi.GetRecordingMediaretentionpolicies(pageSize, pageNum, "", []string{}, "", "", "", true, false, false, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if retentionPolicies.Entities == nil || len(*retentionPolicies.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">allPolicies = append(allPolicies, *retentionPolicies.Entities...)</span>
        }

        <span class="cov0" title="0">return &amp;allPolicies, nil</span>
}

// createPolicyFn is the implementation for creating a media retention policy in Genesys Cloud
func createPolicyFn(ctx context.Context, p *policyProxy, policyCreate *platformclientv2.Policycreate) (*platformclientv2.Policy, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        policy, resp, err := p.recordingApi.PostRecordingMediaretentionpolicies(*policyCreate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov0" title="0">return policy, resp, nil</span>
}

// getPolicyByIdFn is the implementation for getting a media retention policy in Genesys Cloud by id
func getPolicyByIdFn(ctx context.Context, p *policyProxy, policyId string) (policy *platformclientv2.Policy, response *platformclientv2.APIResponse, err error) <span class="cov0" title="0">{
        policy, resp, err := p.recordingApi.GetRecordingMediaretentionpolicy(policyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov0" title="0">return policy, resp, nil</span>
}

// getPolicyByNameFn is the implementation for getting a media retention policy in Genesys Cloud by name
func getPolicyByNameFn(ctx context.Context, p *policyProxy, policyName string) (policy *platformclientv2.Policy, retryable bool, err error) <span class="cov0" title="0">{
        const pageSize = 100
        const pageNum = 1
        policies, _, err := p.recordingApi.GetRecordingMediaretentionpolicies(pageSize, pageNum, "", nil, "", "", policyName, true, false, false, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if policies.Entities == nil || len(*policies.Entities) == 0 </span><span class="cov0" title="0">{
                return nil, true, fmt.Errorf("no media retention policy found with name %s", policyName)
        }</span>

        <span class="cov0" title="0">policy = &amp;(*policies.Entities)[0]
        return policy, false, nil</span>

}

// updatePolicyFn is the implementation for updating a media retention policy in Genesys Cloud
func updatePolicyFn(ctx context.Context, p *policyProxy, policyId string, policyBody *platformclientv2.Policy) (*platformclientv2.Policy, error) <span class="cov0" title="0">{
        policy, _, err := p.recordingApi.PutRecordingMediaretentionpolicy(policyId, *policyBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return policy, nil</span>
}

// deletePolicyFn is the implementation for deleting a media retention policy in Genesys Cloud
func deletePolicyFn(ctx context.Context, p *policyProxy, policyId string) (responseCode int, err error) <span class="cov0" title="0">{
        resp, err := p.recordingApi.DeleteRecordingMediaretentionpolicy(policyId)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

// getFormsEvaluationFn is the implementation for getting an evaluation form in Genesys Cloud
func getFormsEvaluationFn(ctx context.Context, p *policyProxy, formId string) (*platformclientv2.Evaluationform, error) <span class="cov0" title="0">{
        form, _, err := p.qualityApi.GetQualityFormsEvaluation(formId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return form, nil</span>
}

// getEvaluationFormRecentVerIdFn is the implementation for getting the most recent version if of an evaluation form in Genesys Cloud
func getEvaluationFormRecentVerIdFn(ctx context.Context, p *policyProxy, formId string) (string, error) <span class="cov0" title="0">{
        formVersions, _, err := p.qualityApi.GetQualityFormsEvaluationVersions(formId, 25, 1, "desc")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if formVersions.Entities == nil || len(*formVersions.Entities) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no versions found for form %s", formId)
        }</span>

        <span class="cov0" title="0">return *(*formVersions.Entities)[0].Id, nil</span>
}

// getQualityFormsSurveyByNameFn is the implementation for getting a survey form in Genesys Cloud
func getQualityFormsSurveyByNameFn(ctx context.Context, p *policyProxy, surveyName string) (*platformclientv2.Publishedsurveyformreference, error) <span class="cov0" title="0">{
        const pageNum = 1
        const pageSize = 100
        forms, _, err := p.qualityApi.GetQualityFormsSurveys(pageSize, pageNum, "", "", "", "", surveyName, "desc")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if forms.Entities == nil || len(*forms.Entities) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no survey forms found with name %s", surveyName)
        }</span>

        <span class="cov0" title="0">surveyFormReference := platformclientv2.Publishedsurveyformreference{Name: &amp;surveyName, ContextId: (*forms.Entities)[0].ContextId}
        return &amp;surveyFormReference, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package recording_media_retention_policy

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_recording_media_retention_policy.go contains all of the methods that perform the core logic for a resource.
In general a resource should have a approximately 5 methods in it:

1.  A getAll.... function that the CX as Code exporter will use during the process of exporting Genesys Cloud.
2.  A create.... function that the resource will use to create a Genesys Cloud object (e.g. genesyscloud_recording_media_retention_policy)
3.  A read.... function that looks up a single resource.
4.  An update... function that updates a single resource.
5.  A delete.... function that deletes a single resource.

Two things to note:

 1. All code in these methods should be focused on getting data in and out of Terraform.  All code that is used for interacting
    with a Genesys API should be encapsulated into a proxy class contained within the package.

 2. In general, to keep this file somewhat manageable, if you find yourself with a number of helper functions move them to a

utils function in the package.  This will keep the code manageable and easy to work through.
*/

// getAllMediaRetentionPolicies retrieves all of the recording media retention policies via Terraform in the Genesys Cloud and is used for the exporter
func getAllMediaRetentionPolicies(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        pp := getPolicyProxy(clientConfig)

        retentionPolicies, err := pp.getAllPolicies(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get page of media retention policies %v", err)
        }</span>

        <span class="cov0" title="0">for _, retentionPolicy := range *retentionPolicies </span><span class="cov0" title="0">{
                resources[*retentionPolicy.Id] = &amp;resourceExporter.ResourceMeta{Name: *retentionPolicy.Name}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createMediaRetentionPolicy is used by the recording media retention policy resource to create Genesyscloud a media retention policy
func createMediaRetentionPolicy(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPolicyProxy(sdkConfig)

        name := d.Get("name").(string)
        order := d.Get("order").(int)
        description := d.Get("description").(string)
        enabled := d.Get("enabled").(bool)
        mediaPolicies := buildMediaPolicies(d, pp, ctx)
        conditions := buildConditions(d)
        actions := buildPolicyActionsFromResource(d, pp, ctx)
        policyErrors := buildPolicyErrors(d)

        reqBody := platformclientv2.Policycreate{
                Name:          &amp;name,
                Order:         &amp;order,
                Description:   &amp;description,
                Enabled:       &amp;enabled,
                MediaPolicies: mediaPolicies,
                Conditions:    conditions,
                Actions:       actions,
                PolicyErrors:  policyErrors,
        }

        log.Printf("Creating media retention policy %s", name)

        policy, resp, err := pp.createPolicy(ctx, &amp;reqBody)
        log.Printf("Media retention policy creation status %#v", resp.Status)

        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create media retention policy %s: %s", name, err)
        }</span>

        // Make sure form is properly created
        <span class="cov0" title="0">policyId := policy.Id
        d.SetId(*policyId)
        log.Printf("Created media retention policy %s %s", name, *policy.Id)
        return readMediaRetentionPolicy(ctx, d, meta)</span>
}

// readMediaRetentionPolicy is used by the recording media retention policy resource to read a media retention policy from genesys cloud.
func readMediaRetentionPolicy(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPolicyProxy(sdkConfig)

        log.Printf("Reading media retention policy %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                retentionPolicy, resp, err := pp.getPolicyById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read media retention policy %s: %s", d.Id(), err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read media retention policy %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, gcloud.ResourceSurveyForm())

                resourcedata.SetNillableValue(d, "name", retentionPolicy.Name)
                resourcedata.SetNillableValue(d, "order", retentionPolicy.Order)
                resourcedata.SetNillableValue(d, "description", retentionPolicy.Description)
                resourcedata.SetNillableValue(d, "enabled", retentionPolicy.Enabled)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "conditions", retentionPolicy.Conditions, flattenConditions)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "policy_errors", retentionPolicy.PolicyErrors, flattenPolicyErrors)

                if retentionPolicy.MediaPolicies != nil </span><span class="cov0" title="0">{
                        d.Set("media_policies", flattenMediaPolicies(retentionPolicy.MediaPolicies, pp, ctx))
                }</span>
                <span class="cov0" title="0">if retentionPolicy.Actions != nil </span><span class="cov0" title="0">{
                        d.Set("actions", flattenPolicyActions(retentionPolicy.Actions, pp, ctx))
                }</span>

                <span class="cov0" title="0">return cc.CheckState()</span>
        })
}

// updateMediaRetentionPolicy is used by the recording media retention policy resource to update a media retention policy in Genesys Cloud
func updateMediaRetentionPolicy(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPolicyProxy(sdkConfig)

        name := d.Get("name").(string)
        order := d.Get("order").(int)
        description := d.Get("description").(string)
        enabled := d.Get("enabled").(bool)

        mediaPolicies := buildMediaPolicies(d, pp, ctx)
        conditions := buildConditions(d)
        actions := buildPolicyActionsFromResource(d, pp, ctx)
        policyErrors := buildPolicyErrors(d)

        reqBody := platformclientv2.Policy{
                Name:          &amp;name,
                Order:         &amp;order,
                Description:   &amp;description,
                Enabled:       &amp;enabled,
                MediaPolicies: mediaPolicies,
                Conditions:    conditions,
                Actions:       actions,
                PolicyErrors:  policyErrors,
        }

        log.Printf("Updating media retention policy %s", name)
        policy, err := pp.updatePolicy(ctx, d.Id(), &amp;reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update media retention policy %s: %s", name, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated media retention policy %s %s", name, *policy.Id)
        return readMediaRetentionPolicy(ctx, d, meta)</span>
}

// deleteMediaRetentionPolicy is used by the recording media retention policy resource to delete a media retention policy from Genesys cloud.
func deleteMediaRetentionPolicy(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        name := d.Get("name").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPolicyProxy(sdkConfig)

        log.Printf("Deleting media retention policy %s", name)
        _, err := pp.deletePolicy(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete media retention policy %s: %s", name, err)
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, resp, err := pp.getPolicyById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                // media retention policy deleted
                                log.Printf("Deleted media retention policy %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting media retention policy %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("media retention policy %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package recording_media_retention_policy

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

/*
The genesyscloud_recording_media_retention_policy_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the genesyscloud_recording_media_retention_policy resource.
3.  The datasource schema definitions for the genesyscloud_recording_media_retention_policy datasource.
4.  The resource exporter configuration for the genesyscloud_recording_media_retention_policy exporter.
*/

const resourceName = "genesyscloud_recording_media_retention_policy"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceRecordingMediaRetentionPolicy())
        l.RegisterResource(resourceName, ResourceMediaRetentionPolicy())
        l.RegisterExporter(resourceName, MediaRetentionPolicyExporter())
}</span>

// ResourceMediaRetentionPolicy registers the genesyscloud_recording_media_retention_policy resource with Terraform
func ResourceMediaRetentionPolicy() *schema.Resource <span class="cov8" title="1">{
        timeSlot := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "start_time": {
                                Description: "start time in xx:xx:xx.xxx format",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "stop_time": {
                                Description: "stop time in xx:xx:xx.xxx format",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "day": {
                                Description: "Day for this time slot, Monday = 1 ... Sunday = 7",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                },
        }

        timeAllowed := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "time_slots": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        timeSlot,
                        },
                        "time_zone_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "empty": {
                                Description: "",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                },
        }

        durationCondition := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "duration_target": {
                                Description:  "",
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"DURATION", "DURATION_RANGE"}, false),
                        },
                        "duration_operator": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "duration_range": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "duration_mode": {
                                Description:  "",
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"Between", "Over", "Under"}, false),
                        },
                },
        }

        callMediaPolicyConditions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "for_user_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "date_ranges": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "for_queue_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "wrapup_code_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "language_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "time_allowed": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeAllowed,
                        },
                        "directions": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "duration": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        durationCondition,
                        },
                },
        }

        chatMediaPolicyConditions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "for_user_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "date_ranges": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "for_queue_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "wrapup_code_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "language_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "time_allowed": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeAllowed,
                        },
                        "duration": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        durationCondition,
                        },
                },
        }

        emailMediaPolicyConditions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "for_user_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "date_ranges": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "for_queue_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "wrapup_code_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "language_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "time_allowed": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeAllowed,
                        },
                },
        }

        messageMediaPolicyConditions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "for_user_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "date_ranges": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "for_queue_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "wrapup_code_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "language_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "time_allowed": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeAllowed,
                        },
                },
        }

        policyConditions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "for_user_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "directions": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "date_ranges": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Default:     nil,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "media_types": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "for_queue_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "duration": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        durationCondition,
                        },
                        "wrapup_code_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "time_allowed": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeAllowed,
                        },
                },
        }

        userParam := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "key": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "value": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        archiveRetention := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "days": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "storage_medium": {
                                Description:  "",
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"CLOUDARCHIVE"}, false)},
                },
        }

        deleteRetention := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "days": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                },
        }

        policyErrorMessage := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "status_code": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "user_message": {
                                Description: "",
                                Type:        schema.TypeMap,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                Optional:    true,
                        },
                        "user_params_message": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "error_code": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "correlation_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "user_params": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        userParam,
                        },
                        "insert_date": {
                                Description: "Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        timeInterval := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "months": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "weeks": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "days": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "hours": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                },
        }

        policyErrors := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "policy_error_messages": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        policyErrorMessage,
                        },
                },
        }

        evaluationAssignment := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "evaluation_form_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "user_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        meteredEvaluationAssignment := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "evaluator_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "max_number_evaluations": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "evaluation_form_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "assign_to_active_user": {
                                Description: "",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "time_interval": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeInterval,
                        },
                },
        }

        meteredAssignmentByAgent := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "evaluator_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "max_number_evaluations": {
                                Description: "",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "evaluation_form_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "time_interval": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        timeInterval,
                        },
                        "time_zone": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        calibrationAssignment := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "calibrator_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "evaluator_ids": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "evaluation_form_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "expert_evaluator_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        surveyAssignment := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "survey_form_name": {
                                Description: "The survey form used for this survey.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "flow_id": {
                                Description: "The UUID reference to the flow associated with this survey.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "invite_time_interval": {
                                Description: "An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days.",
                                Type:        schema.TypeString,
                                Default:     "R1/P0M",
                                Optional:    true,
                        },
                        "sending_user": {
                                Description: "User together with sendingDomain used to send email, null to use no-reply",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "sending_domain": {
                                Description: "Validated email domain, required",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }

        retentionDuration := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "archive_retention": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        archiveRetention,
                        },
                        "delete_retention": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        deleteRetention,
                        },
                },
        }

        initiateScreenRecording := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "record_acw": {
                                Description: "",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "archive_retention": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        archiveRetention,
                        },
                        "delete_retention": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        deleteRetention,
                        },
                },
        }

        mediaTranscription := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "display_name": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "transcription_provider": {
                                Description:  "",
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"VOCI", "CALLJOURNEY"}, false),
                        },
                        "integration_id": {
                                Description: "",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }

        integrationExport := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "integration_id": {
                                Description: "The aws-s3-recording-bulk-actions-integration that the policy uses for exports.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "should_export_screen_recordings": {
                                Description: "True if the policy should export screen recordings in addition to the other conversation media.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     true,
                        },
                },
        }

        policyActions := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "retain_recording": {
                                Description: "true to retain the recording associated with the conversation.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "delete_recording": {
                                Description: "true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "always_delete": {
                                Description: "true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "assign_evaluations": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        evaluationAssignment,
                        },
                        "assign_metered_evaluations": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        meteredEvaluationAssignment,
                        },
                        "assign_metered_assignment_by_agent": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        meteredAssignmentByAgent,
                        },
                        "assign_calibrations": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        calibrationAssignment,
                        },
                        "assign_surveys": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        surveyAssignment,
                        },
                        "retention_duration": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        retentionDuration,
                        },
                        "initiate_screen_recording": {
                                Description: "",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        initiateScreenRecording,
                        },
                        "media_transcriptions": {
                                Description: "",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        mediaTranscription,
                        },
                        "integration_export": {
                                Description: "Policy action for exporting recordings using an integration to 3rd party s3.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        integrationExport,
                        },
                },
        }

        callMediaPolicy := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "actions": {
                                Description: "Actions applied when specified conditions are met",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyActions,
                        },
                        "conditions": {
                                Description: "Conditions for when actions should be applied",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        callMediaPolicyConditions,
                        },
                },
        }

        chatMediaPolicy := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "actions": {
                                Description: "Actions applied when specified conditions are met",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyActions,
                        },
                        "conditions": {
                                Description: "Conditions for when actions should be applied",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        chatMediaPolicyConditions,
                        },
                },
        }

        emailMediaPolicy := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "actions": {
                                Description: "Actions applied when specified conditions are met",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyActions,
                        },
                        "conditions": {
                                Description: "Conditions for when actions should be applied",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        emailMediaPolicyConditions,
                        },
                },
        }

        messageMediaPolicy := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "actions": {
                                Description: "Actions applied when specified conditions are met",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyActions,
                        },
                        "conditions": {
                                Description: "Conditions for when actions should be applied",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        messageMediaPolicyConditions,
                        },
                },
        }

        mediaPolicies := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "call_policy": {
                                Description: "Conditions and actions for calls",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        callMediaPolicy,
                        },
                        "chat_policy": {
                                Description: "Conditions and actions for calls",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        chatMediaPolicy,
                        },
                        "email_policy": {
                                Description: "Conditions and actions for calls",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        emailMediaPolicy,
                        },
                        "message_policy": {
                                Description: "Conditions and actions for calls",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        messageMediaPolicy,
                        },
                },
        }

        return &amp;schema.Resource{
                Description:   "Genesys Cloud Media Retention Policies",
                CreateContext: gcloud.CreateWithPooledClient(createMediaRetentionPolicy),
                ReadContext:   gcloud.ReadWithPooledClient(readMediaRetentionPolicy),
                UpdateContext: gcloud.UpdateWithPooledClient(updateMediaRetentionPolicy),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteMediaRetentionPolicy),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The policy name. Changing the policy_name attribute will cause the recording_media_retention_policy to be dropped and recreated with a new ID.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "order": {
                                Description: "The ordinal number for the policy",
                                Type:        schema.TypeInt,
                                Optional:    true,
                        },
                        "description": {
                                Description: "The description for the policy",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "enabled": {
                                Description: "The policy will be enabled if true, otherwise it will be disabled",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "media_policies": {
                                Description: "Conditions and actions per media type",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        mediaPolicies,
                        },
                        "conditions": {
                                Description: "Conditions",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyConditions,
                        },
                        "actions": {
                                Description: "Actions",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyActions,
                        },
                        "policy_errors": {
                                Description: "A list of errors in the policy configuration",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        policyErrors,
                        },
                },
        }
}</span>

// MediaRetentionPolicyExporter returns the resourceExporter object used to hold the genesyscloud_recording_media_retention_policy exporter's config
func MediaRetentionPolicyExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllMediaRetentionPolicies),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "media_policies.chat_policy.conditions.for_queue_ids":                                         {RefType: "genesyscloud_routing_queue", AltValues: []string{"*"}},
                        "media_policies.call_policy.conditions.for_queue_ids":                                         {RefType: "genesyscloud_routing_queue", AltValues: []string{"*"}},
                        "media_policies.message_policy.conditions.for_queue_ids":                                      {RefType: "genesyscloud_routing_queue", AltValues: []string{"*"}},
                        "media_policies.email_policy.conditions.for_queue_ids":                                        {RefType: "genesyscloud_routing_queue", AltValues: []string{"*"}},
                        "conditions.for_queue_ids":                                                                    {RefType: "genesyscloud_routing_queue", AltValues: []string{"*"}},
                        "media_policies.call_policy.conditions.for_user_ids":                                          {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.chat_policy.conditions.for_user_ids":                                          {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.email_policy.conditions.for_user_ids":                                         {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.message_policy.conditions.for_user_ids":                                       {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "conditions.for_user_ids":                                                                     {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.assign_evaluations.evaluation_form_id":                    {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.call_policy.actions.assign_calibrations.evaluation_form_id":                   {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.call_policy.actions.assign_metered_evaluations.evaluation_form_id":            {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.call_policy.actions.assign_metered_assignment_by_agent.evaluation_form_id":    {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.chat_policy.actions.assign_evaluations.evaluation_form_id":                    {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.chat_policy.actions.assign_calibrations.evaluation_form_id":                   {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.chat_policy.actions.assign_metered_evaluations.evaluation_form_id":            {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.chat_policy.actions.assign_metered_assignment_by_agent.evaluation_form_id":    {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.message_policy.actions.assign_evaluations.evaluation_form_id":                 {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.message_policy.actions.assign_calibrations.evaluation_form_id":                {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.message_policy.actions.assign_metered_evaluations.evaluation_form_id":         {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.message_policy.actions.assign_metered_assignment_by_agent.evaluation_form_id": {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.email_policy.actions.assign_evaluations.evaluation_form_id":                   {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.email_policy.actions.assign_calibrations.evaluation_form_id":                  {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.email_policy.actions.assign_metered_evaluations.evaluation_form_id":           {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.email_policy.actions.assign_metered_assignment_by_agent.evaluation_form_id":   {RefType: "genesyscloud_quality_forms_evaluation"},
                        "actions.assign_evaluations.evaluation_form_id":                                               {RefType: "genesyscloud_quality_forms_evaluation"},
                        "actions.assign_calibrations.evaluation_form_id":                                              {RefType: "genesyscloud_quality_forms_evaluation"},
                        "actions.assign_metered_evaluations.evaluation_form_id":                                       {RefType: "genesyscloud_quality_forms_evaluation"},
                        "actions.assign_metered_assignment_by_agent.evaluation_form_id":                               {RefType: "genesyscloud_quality_forms_evaluation"},
                        "media_policies.call_policy.actions.assign_evaluations.evaluator_ids":                         {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.assign_calibrations.evaluator_ids":                        {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.assign_metered_evaluations.evaluator_ids":                 {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.assign_metered_assignment_by_agent.evaluator_ids":         {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.chat_policy.actions.assign_evaluations.evaluator_ids":                         {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.chat_policy.actions.assign_calibrations.evaluator_ids":                        {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.chat_policy.actions.assign_metered_evaluations.evaluator_ids":                 {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.chat_policy.actions.assign_metered_assignment_by_agent.evaluator_ids":         {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.message_policy.actions.assign_evaluations.evaluator_ids":                      {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.message_policy.actions.assign_calibrations.evaluator_ids":                     {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.message_policy.actions.assign_metered_evaluations.evaluator_ids":              {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.message_policy.actions.assign_metered_assignment_by_agent.evaluator_ids":      {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.email_policy.actions.assign_evaluations.evaluator_ids":                        {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.email_policy.actions.assign_calibrations.evaluator_ids":                       {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.email_policy.actions.assign_metered_evaluations.evaluator_ids":                {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.email_policy.actions.assign_metered_assignment_by_agent.evaluator_ids":        {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "actions.assign_evaluations.evaluator_ids":                                                    {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "actions.assign_calibrations.evaluator_ids":                                                   {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "actions.assign_metered_evaluations.evaluator_ids":                                            {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "actions.assign_metered_assignment_by_agent.evaluator_ids":                                    {RefType: "genesyscloud_user", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.assign_calibrations.calibrator_id":                        {RefType: "genesyscloud_user"},
                        "media_policies.chat_policy.actions.assign_calibrations.calibrator_id":                        {RefType: "genesyscloud_user"},
                        "media_policies.message_policy.actions.assign_calibrations.calibrator_id":                     {RefType: "genesyscloud_user"},
                        "media_policies.email_policy.actions.assign_calibrations.calibrator_id":                       {RefType: "genesyscloud_user"},
                        "media_policies.call_policy.actions.assign_calibrations.expert_evaluator_id":                  {RefType: "genesyscloud_user"},
                        "media_policies.chat_policy.actions.assign_calibrations.expert_evaluator_id":                  {RefType: "genesyscloud_user"},
                        "media_policies.message_policy.actions.assign_calibrations.expert_evaluator_id":               {RefType: "genesyscloud_user"},
                        "media_policies.email_policy.actions.assign_calibrations.expert_evaluator_id":                 {RefType: "genesyscloud_user"},
                        "actions.assign_calibrations.expert_evaluator_id":                                             {RefType: "genesyscloud_user"},
                        "media_policies.call_policy.conditions.language_ids":                                          {RefType: "genesyscloud_routing_language", AltValues: []string{"*"}},
                        "media_policies.chat_policy.conditions.language_ids":                                          {RefType: "genesyscloud_routing_language", AltValues: []string{"*"}},
                        "media_policies.message_policy.conditions.language_ids":                                       {RefType: "genesyscloud_routing_language", AltValues: []string{"*"}},
                        "media_policies.email_policy.conditions.language_ids":                                         {RefType: "genesyscloud_routing_language", AltValues: []string{"*"}},
                        "media_policies.call_policy.conditions.wrapup_code_ids":                                       {RefType: "genesyscloud_routing_wrapupcode", AltValues: []string{"*"}},
                        "media_policies.chat_policy.conditions.wrapup_code_ids":                                       {RefType: "genesyscloud_routing_wrapupcode", AltValues: []string{"*"}},
                        "media_policies.message_policy.conditions.wrapup_code_ids":                                    {RefType: "genesyscloud_routing_wrapupcode", AltValues: []string{"*"}},
                        "media_policies.email_policy.conditions.wrapup_code_ids":                                      {RefType: "genesyscloud_routing_wrapupcode", AltValues: []string{"*"}},
                        "conditions.wrapup_code_ids":                                                                  {RefType: "genesyscloud_routing_wrapupcode", AltValues: []string{"*"}},
                        "media_policies.call_policy.actions.integration_export.integration_id":                        {RefType: "genesyscloud_integration"},
                        "media_policies.chat_policy.actions.integration_export.integration_id":                        {RefType: "genesyscloud_integration"},
                        "media_policies.message_policy.actions.integration_export.integration_id":                     {RefType: "genesyscloud_integration"},
                        "media_policies.email_policy.actions.integration_export.integration_id":                       {RefType: "genesyscloud_integration"},
                        "actions.media_transcriptions.integration_id":                                                 {RefType: "genesyscloud_integration"},
                        "media_policies.call_policy.actions.assign_surveys.flow_id":                                   {RefType: "genesyscloud_flow"},
                        "media_policies.chat_policy.actions.assign_surveys.flow_id":                                   {RefType: "genesyscloud_flow"},
                        "media_policies.message_policy.actions.assign_surveys.flow_id":                                {RefType: "genesyscloud_flow"},
                        "media_policies.email_policy.actions.assign_surveys.flow_id":                                  {RefType: "genesyscloud_flow"},
                        "actions.assign_surveys.flow_id":                                                              {RefType: "genesyscloud_flow"},
                        "media_policies.call_policy.actions.assign_evaluations.user_id":                               {RefType: "genesyscloud_user"},
                        "media_policies.chat_policy.actions.assign_evaluations.user_id":                               {RefType: "genesyscloud_user"},
                        "media_policies.message_policy.actions.assign_evaluations.user_id":                            {RefType: "genesyscloud_user"},
                        "media_policies.email_policy.actions.assign_evaluations.user_id":                              {RefType: "genesyscloud_user"},
                        "actions.assign_evaluations.user_id":                                                          {RefType: "genesyscloud_user"},
                },
                AllowZeroValues: []string{"order"},
                RemoveIfMissing: map[string][]string{
                        "":               {"conditions", "actions"},
                        "media_policies": {"call_policy", "chat_policy", "message_policy", "email_policy"},
                },
        }
}</span>

// DataSourceRecordingMediaRetentionPolicy registers the genesyscloud_recording_media_retention_policy data source
func DataSourceRecordingMediaRetentionPolicy() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud media retention policy. Select a policy by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceRecordingMediaRetentionPolicyRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Media retention policy name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package recording_media_retention_policy

import (
        "context"
        "fmt"
        "log"
        "reflect"
        "time"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The resource_genesyscloud_recording_media_retention_policy_utils.go file contains various helper methods to marshal
and unmarshal data into formats consumable by Terraform and/or Genesys Cloud.

Note:  Look for opportunities to minimize boilerplate code using functions and Generics
*/

type VisibilityConditionStruct struct {
        CombiningOperation string
        Predicates         []string
}

func buildEvaluationAssignments(evaluations []interface{}, pp *policyProxy, ctx context.Context) *[]platformclientv2.Evaluationassignment <span class="cov0" title="0">{
        assignEvaluations := make([]platformclientv2.Evaluationassignment, 0)

        for _, assignEvaluation := range evaluations </span><span class="cov0" title="0">{
                assignEvaluationMap, ok := assignEvaluation.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">evaluationFormId := assignEvaluationMap["evaluation_form_id"].(string)
                userId := assignEvaluationMap["user_id"].(string)
                assignment := platformclientv2.Evaluationassignment{}

                // if evaluation form id is present, get the context id and build the evaluation form
                if evaluationFormId != "" </span><span class="cov0" title="0">{
                        form, err := pp.getFormsEvaluation(ctx, evaluationFormId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to read evaluation form %s: %s", evaluationFormId, err)
                        }</span> else<span class="cov0" title="0"> {
                                evaluationFormContextId := form.ContextId
                                assignment.EvaluationForm = &amp;platformclientv2.Evaluationform{Id: &amp;evaluationFormId, ContextId: evaluationFormContextId}
                        }</span>
                }
                <span class="cov0" title="0">if userId != "" </span><span class="cov0" title="0">{
                        assignment.User = &amp;platformclientv2.User{Id: &amp;userId}
                }</span>
                <span class="cov0" title="0">assignEvaluations = append(assignEvaluations, assignment)</span>
        }

        <span class="cov0" title="0">return &amp;assignEvaluations</span>
}

func flattenEvaluationAssignments(assignments *[]platformclientv2.Evaluationassignment, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if assignments == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">evaluationAssignments := make([]interface{}, 0)
        for _, assignment := range *assignments </span><span class="cov0" title="0">{
                assignmentMap := make(map[string]interface{})

                // if form is present in the response, assign the most recent unpublished version id to align with evaluation form resource behavior for export purposes.
                if assignment.EvaluationForm != nil </span><span class="cov0" title="0">{
                        formId := *assignment.EvaluationForm.Id
                        formVersionId, err := pp.getEvaluationFormRecentVerId(ctx, formId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to get evaluation form versions %s", *assignment.EvaluationForm.Name)
                        }</span> else<span class="cov0" title="0"> {
                                formId = formVersionId
                        }</span>

                        <span class="cov0" title="0">assignmentMap["evaluation_form_id"] = formId</span>
                }
                <span class="cov0" title="0">if assignment.User != nil </span><span class="cov0" title="0">{
                        assignmentMap["user_id"] = *assignment.User.Id
                }</span>
                <span class="cov0" title="0">evaluationAssignments = append(evaluationAssignments, assignmentMap)</span>
        }
        <span class="cov0" title="0">return evaluationAssignments</span>
}

func buildTimeInterval(timeInterval []interface{}) *platformclientv2.Timeinterval <span class="cov0" title="0">{
        if timeInterval == nil || len(timeInterval) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">timeIntervalMap, ok := timeInterval[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">months := timeIntervalMap["months"].(int)
        weeks := timeIntervalMap["weeks"].(int)
        days := timeIntervalMap["days"].(int)
        hours := timeIntervalMap["hours"].(int)

        return &amp;platformclientv2.Timeinterval{
                Months: &amp;months,
                Weeks:  &amp;weeks,
                Days:   &amp;days,
                Hours:  &amp;hours,
        }</span>
}

func flattenTimeInterval(timeInterval *platformclientv2.Timeinterval) []interface{} <span class="cov0" title="0">{
        if timeInterval == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">timeIntervalMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(timeIntervalMap, "months", timeInterval.Months)
        resourcedata.SetMapValueIfNotNil(timeIntervalMap, "weeks", timeInterval.Weeks)
        resourcedata.SetMapValueIfNotNil(timeIntervalMap, "days", timeInterval.Days)
        resourcedata.SetMapValueIfNotNil(timeIntervalMap, "hours", timeInterval.Hours)

        return []interface{}{timeIntervalMap}</span>
}

func buildAssignMeteredEvaluations(assignments []interface{}, pp *policyProxy, ctx context.Context) *[]platformclientv2.Meteredevaluationassignment <span class="cov0" title="0">{
        meteredAssignments := make([]platformclientv2.Meteredevaluationassignment, 0)

        for _, assignment := range assignments </span><span class="cov0" title="0">{
                assignmentMap, ok := assignment.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">maxNumberEvaluations := assignmentMap["max_number_evaluations"].(int)
                assignToActiveUser := assignmentMap["assign_to_active_user"].(bool)
                evaluationFormId := assignmentMap["evaluation_form_id"].(string)
                evaluatorIds := assignmentMap["evaluator_ids"].([]interface{})

                idStrings := make([]string, 0)
                for _, evaluatorId := range evaluatorIds </span><span class="cov0" title="0">{
                        idStrings = append(idStrings, fmt.Sprintf("%v", evaluatorId))
                }</span>

                <span class="cov0" title="0">evaluators := make([]platformclientv2.User, 0)
                for _, evaluatorId := range idStrings </span><span class="cov0" title="0">{
                        evaluator := evaluatorId
                        evaluators = append(evaluators, platformclientv2.User{Id: &amp;evaluator})
                }</span>

                <span class="cov0" title="0">temp := platformclientv2.Meteredevaluationassignment{
                        Evaluators:           &amp;evaluators,
                        MaxNumberEvaluations: &amp;maxNumberEvaluations,
                        AssignToActiveUser:   &amp;assignToActiveUser,
                        TimeInterval:         buildTimeInterval(assignmentMap["time_interval"].([]interface{})),
                }

                // if evaluation form id is present, get the context id and build the evaluation form
                if evaluationFormId != "" </span><span class="cov0" title="0">{
                        form, err := pp.getFormsEvaluation(ctx, evaluationFormId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to read media evaluation form %s: %s", evaluationFormId, err)
                        }</span> else<span class="cov0" title="0"> {
                                evaluationFormContextId := form.ContextId
                                temp.EvaluationForm = &amp;platformclientv2.Evaluationform{Id: &amp;evaluationFormId, ContextId: evaluationFormContextId}
                        }</span>
                }
                <span class="cov0" title="0">meteredAssignments = append(meteredAssignments, temp)</span>
        }

        <span class="cov0" title="0">return &amp;meteredAssignments</span>
}

func flattenAssignMeteredEvaluations(assignments *[]platformclientv2.Meteredevaluationassignment, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if assignments == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">meteredAssignments := make([]interface{}, 0)
        for _, assignment := range *assignments </span><span class="cov0" title="0">{
                assignmentMap := make(map[string]interface{})
                if assignment.Evaluators != nil </span><span class="cov0" title="0">{
                        evaluatorIds := make([]string, 0)
                        for _, evaluator := range *assignment.Evaluators </span><span class="cov0" title="0">{
                                evaluatorIds = append(evaluatorIds, *evaluator.Id)
                        }</span>
                        <span class="cov0" title="0">assignmentMap["evaluator_ids"] = evaluatorIds</span>
                }

                <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(assignmentMap, "max_number_evaluations", assignment.MaxNumberEvaluations)

                // if form is present in the response, assign the most recent unpublished version id to align with evaluation form resource behavior for export purposes.
                if assignment.EvaluationForm != nil </span><span class="cov0" title="0">{
                        formId := *assignment.EvaluationForm.Id
                        formVersionId, err := pp.getEvaluationFormRecentVerId(ctx, formId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to get evaluation form versions %s", *assignment.EvaluationForm.Name)
                        }</span> else<span class="cov0" title="0"> {
                                formId = formVersionId
                        }</span>

                        <span class="cov0" title="0">assignmentMap["evaluation_form_id"] = formId</span>
                }

                <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(assignmentMap, "assign_to_active_user", assignment.AssignToActiveUser)
                resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(assignmentMap, "time_interval", assignment.TimeInterval, flattenTimeInterval)

                meteredAssignments = append(meteredAssignments, assignmentMap)</span>
        }
        <span class="cov0" title="0">return meteredAssignments</span>
}

func buildAssignMeteredAssignmentByAgent(assignments []interface{}, pp *policyProxy, ctx context.Context) *[]platformclientv2.Meteredassignmentbyagent <span class="cov0" title="0">{
        meteredAssignments := make([]platformclientv2.Meteredassignmentbyagent, 0)
        for _, assignment := range assignments </span><span class="cov0" title="0">{
                assignmentMap, ok := assignment.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">maxNumberEvaluations := assignmentMap["max_number_evaluations"].(int)
                timeZone := assignmentMap["time_zone"].(string)
                evaluationFormId := assignmentMap["evaluation_form_id"].(string)
                evaluatorIds := assignmentMap["evaluator_ids"].([]interface{})

                idStrings := make([]string, 0)
                for _, evaluatorId := range evaluatorIds </span><span class="cov0" title="0">{
                        idStrings = append(idStrings, fmt.Sprintf("%v", evaluatorId))
                }</span>

                <span class="cov0" title="0">evaluators := make([]platformclientv2.User, 0)
                for _, evaluatorId := range idStrings </span><span class="cov0" title="0">{
                        evaluator := evaluatorId
                        evaluators = append(evaluators, platformclientv2.User{Id: &amp;evaluator})
                }</span>

                <span class="cov0" title="0">temp := platformclientv2.Meteredassignmentbyagent{
                        Evaluators:           &amp;evaluators,
                        MaxNumberEvaluations: &amp;maxNumberEvaluations,
                        TimeInterval:         buildTimeInterval(assignmentMap["time_interval"].([]interface{})),
                        TimeZone:             &amp;timeZone,
                }

                // if evaluation form id is present, get the context id and build the evaluation form
                if evaluationFormId != "" </span><span class="cov0" title="0">{
                        form, err := pp.getFormsEvaluation(ctx, evaluationFormId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to read evaluation form %s: %s", evaluationFormId, err)
                        }</span> else<span class="cov0" title="0"> {
                                evaluationFormContextId := form.ContextId
                                temp.EvaluationForm = &amp;platformclientv2.Evaluationform{Id: &amp;evaluationFormId, ContextId: evaluationFormContextId}
                        }</span>
                }

                <span class="cov0" title="0">meteredAssignments = append(meteredAssignments, temp)</span>
        }

        <span class="cov0" title="0">return &amp;meteredAssignments</span>
}

func flattenAssignMeteredAssignmentByAgent(assignments *[]platformclientv2.Meteredassignmentbyagent, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if assignments == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">meteredAssignments := make([]interface{}, 0)
        for _, assignment := range *assignments </span><span class="cov0" title="0">{
                assignmentMap := make(map[string]interface{})
                if assignment.Evaluators != nil </span><span class="cov0" title="0">{
                        evaluatorIds := make([]string, 0)
                        for _, evaluator := range *assignment.Evaluators </span><span class="cov0" title="0">{
                                evaluatorIds = append(evaluatorIds, *evaluator.Id)
                        }</span>
                        <span class="cov0" title="0">assignmentMap["evaluator_ids"] = evaluatorIds</span>
                }

                <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(assignmentMap, "max_number_evaluations", assignment.MaxNumberEvaluations)

                // if form is present in the response, assign the most recent unpublished version id to align with evaluation form resource behavior for export purposes.
                if assignment.EvaluationForm != nil </span><span class="cov0" title="0">{
                        formId := *assignment.EvaluationForm.Id
                        formVersionId, err := pp.getEvaluationFormRecentVerId(ctx, formId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to get evaluation form versions %s", *assignment.EvaluationForm.Name)
                        }</span> else<span class="cov0" title="0"> {
                                formId = formVersionId
                        }</span>

                        <span class="cov0" title="0">assignmentMap["evaluation_form_id"] = formId</span>
                }

                <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(assignmentMap, "time_interval", assignment.TimeInterval, flattenTimeInterval)
                resourcedata.SetMapValueIfNotNil(assignmentMap, "time_zone", assignment.TimeZone)

                meteredAssignments = append(meteredAssignments, assignmentMap)</span>
        }
        <span class="cov0" title="0">return meteredAssignments</span>
}

func buildAssignCalibrations(assignments []interface{}, pp *policyProxy, ctx context.Context) *[]platformclientv2.Calibrationassignment <span class="cov0" title="0">{
        calibrationAssignments := make([]platformclientv2.Calibrationassignment, 0)

        for _, assignment := range assignments </span><span class="cov0" title="0">{
                assignmentMap, ok := assignment.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">evaluationFormId := assignmentMap["evaluation_form_id"].(string)
                calibratorId := assignmentMap["calibrator_id"].(string)
                expertEvaluatorId := assignmentMap["expert_evaluator_id"].(string)
                evaluatorIds := assignmentMap["evaluator_ids"].([]interface{})

                idStrings := make([]string, 0)
                for _, evaluatorId := range evaluatorIds </span><span class="cov0" title="0">{
                        idStrings = append(idStrings, fmt.Sprintf("%v", evaluatorId))
                }</span>

                <span class="cov0" title="0">evaluators := make([]platformclientv2.User, 0)
                for _, evaluatorId := range idStrings </span><span class="cov0" title="0">{
                        id := evaluatorId
                        evaluators = append(evaluators, platformclientv2.User{Id: &amp;id})
                }</span>

                <span class="cov0" title="0">temp := platformclientv2.Calibrationassignment{
                        Evaluators: &amp;evaluators,
                }

                // if evaluation form id is present, get the context id and build the evaluation form
                if evaluationFormId != "" </span><span class="cov0" title="0">{
                        form, err := pp.getFormsEvaluation(ctx, evaluationFormId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to read evaluation form %s: %s", evaluationFormId, err)
                        }</span> else<span class="cov0" title="0"> {
                                evaluationFormContextId := form.ContextId
                                temp.EvaluationForm = &amp;platformclientv2.Evaluationform{Id: &amp;evaluationFormId, ContextId: evaluationFormContextId}
                        }</span>
                }

                <span class="cov0" title="0">if calibratorId != "" </span><span class="cov0" title="0">{
                        temp.Calibrator = &amp;platformclientv2.User{Id: &amp;calibratorId}
                }</span>
                <span class="cov0" title="0">if expertEvaluatorId != "" </span><span class="cov0" title="0">{
                        temp.ExpertEvaluator = &amp;platformclientv2.User{Id: &amp;expertEvaluatorId}
                }</span>

                <span class="cov0" title="0">calibrationAssignments = append(calibrationAssignments, temp)</span>
        }

        <span class="cov0" title="0">return &amp;calibrationAssignments</span>
}

func flattenAssignCalibrations(assignments *[]platformclientv2.Calibrationassignment, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if assignments == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">calibrationAssignments := make([]interface{}, 0)
        for _, assignment := range *assignments </span><span class="cov0" title="0">{
                assignmentMap := make(map[string]interface{})
                if assignment.Calibrator != nil </span><span class="cov0" title="0">{
                        assignmentMap["calibrator_id"] = *assignment.Calibrator.Id
                }</span>
                <span class="cov0" title="0">if assignment.Evaluators != nil </span><span class="cov0" title="0">{
                        evaluatorIds := make([]string, 0)
                        for _, evaluator := range *assignment.Evaluators </span><span class="cov0" title="0">{
                                evaluatorIds = append(evaluatorIds, *evaluator.Id)
                        }</span>
                        <span class="cov0" title="0">assignmentMap["evaluator_ids"] = evaluatorIds</span>
                }
                // if form is present in the response, assign the most recent unpublished version id to align with evaluation form resource behavior for export purposes.
                <span class="cov0" title="0">if assignment.EvaluationForm != nil </span><span class="cov0" title="0">{
                        formId := *assignment.EvaluationForm.Id
                        formVersionId, err := pp.getEvaluationFormRecentVerId(ctx, formId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to get evaluation form versions %s", *assignment.EvaluationForm.Name)
                        }</span> else<span class="cov0" title="0"> {
                                formId = formVersionId
                        }</span>

                        <span class="cov0" title="0">assignmentMap["evaluation_form_id"] = formId</span>
                }
                <span class="cov0" title="0">if assignment.ExpertEvaluator != nil </span><span class="cov0" title="0">{
                        assignmentMap["expert_evaluator_id"] = *assignment.ExpertEvaluator.Id
                }</span>

                <span class="cov0" title="0">calibrationAssignments = append(calibrationAssignments, assignmentMap)</span>
        }
        <span class="cov0" title="0">return calibrationAssignments</span>
}

func buildDomainEntityRef(idVal string) *platformclientv2.Domainentityref <span class="cov0" title="0">{
        if idVal == "nil" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Domainentityref{
                Id: &amp;idVal,
        }</span>
}

func buildAssignSurveys(assignments []interface{}, pp *policyProxy, ctx context.Context) *[]platformclientv2.Surveyassignment <span class="cov0" title="0">{
        surveyAssignments := make([]platformclientv2.Surveyassignment, 0)

        for _, assignment := range assignments </span><span class="cov0" title="0">{
                assignmentMap, ok := assignment.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sendingUser := assignmentMap["sending_user"].(string)
                sendingDomain := assignmentMap["sending_domain"].(string)
                inviteTimeInterval := assignmentMap["invite_time_interval"].(string)
                surveyFormName := assignmentMap["survey_form_name"].(string)

                temp := platformclientv2.Surveyassignment{
                        Flow:               buildDomainEntityRef(assignmentMap["flow_id"].(string)),
                        InviteTimeInterval: &amp;inviteTimeInterval,
                        SendingUser:        &amp;sendingUser,
                        SendingDomain:      &amp;sendingDomain,
                }

                // If a survey form name is provided, get the context id and build the published survey form reference
                if surveyFormName != "" </span><span class="cov0" title="0">{
                        form, err := pp.getQualityFormsSurveyByName(ctx, surveyFormName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Error requesting survey forms %s: %s", surveyFormName, err)
                        }</span> else<span class="cov0" title="0"> {
                                surveyFormReference := platformclientv2.Publishedsurveyformreference{Name: &amp;surveyFormName, ContextId: form.ContextId}
                                temp.SurveyForm = &amp;surveyFormReference
                        }</span>
                }

                <span class="cov0" title="0">surveyAssignments = append(surveyAssignments, temp)</span>
        }

        <span class="cov0" title="0">return &amp;surveyAssignments</span>
}

func flattenAssignSurveys(assignments *[]platformclientv2.Surveyassignment) []interface{} <span class="cov0" title="0">{
        if assignments == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var surveyAssignments []interface{}

        for _, assignment := range *assignments </span><span class="cov0" title="0">{
                assignmentMap := make(map[string]interface{}, 0)
                if assignment.SurveyForm != nil &amp;&amp; assignment.SurveyForm.Name != nil </span><span class="cov0" title="0">{
                        assignmentMap["survey_form_name"] = *assignment.SurveyForm.Name
                }</span>
                <span class="cov0" title="0">if assignment.Flow != nil &amp;&amp; assignment.Flow.Id != nil </span><span class="cov0" title="0">{
                        assignmentMap["flow_id"] = *assignment.Flow.Id
                }</span>

                <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(assignmentMap, "invite_time_interval", assignment.InviteTimeInterval)
                resourcedata.SetMapValueIfNotNil(assignmentMap, "sending_user", assignment.SendingUser)
                resourcedata.SetMapValueIfNotNil(assignmentMap, "sending_domain", assignment.SendingDomain)

                surveyAssignments = append(surveyAssignments, assignmentMap)</span>
        }
        <span class="cov0" title="0">return surveyAssignments</span>
}

func buildArchiveRetention(archiveRetention []interface{}) *platformclientv2.Archiveretention <span class="cov0" title="0">{
        if archiveRetention == nil || len(archiveRetention) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">archiveRetentionMap, ok := archiveRetention[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">days := archiveRetentionMap["days"].(int)
        storageMedium := archiveRetentionMap["storage_medium"].(string)

        return &amp;platformclientv2.Archiveretention{
                Days:          &amp;days,
                StorageMedium: &amp;storageMedium,
        }</span>
}

func flattenArchiveRetention(archiveRetention *platformclientv2.Archiveretention) []interface{} <span class="cov0" title="0">{
        if archiveRetention == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">archiveRetentionMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(archiveRetentionMap, "days", archiveRetention.Days)
        resourcedata.SetMapValueIfNotNil(archiveRetentionMap, "storage_medium", archiveRetention.StorageMedium)

        return []interface{}{archiveRetentionMap}</span>
}

func buildDeleteRetention(deleteRetention []interface{}) *platformclientv2.Deleteretention <span class="cov0" title="0">{
        if deleteRetention == nil || len(deleteRetention) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">deleteRetentionMap, ok := deleteRetention[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">days := deleteRetentionMap["days"].(int)

        return &amp;platformclientv2.Deleteretention{
                Days: &amp;days,
        }</span>
}

func flattenDeleteRetention(deleteRetention *platformclientv2.Deleteretention) []interface{} <span class="cov0" title="0">{
        if deleteRetention == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">deleteRetentionMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(deleteRetentionMap, "days", deleteRetention.Days)

        return []interface{}{deleteRetentionMap}</span>
}

func buildRetentionDuration(retentionDuration []interface{}) *platformclientv2.Retentionduration <span class="cov0" title="0">{
        if retentionDuration == nil || len(retentionDuration) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">retentionDurationMap, ok := retentionDuration[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Retentionduration{
                ArchiveRetention: buildArchiveRetention(retentionDurationMap["archive_retention"].([]interface{})),
                DeleteRetention:  buildDeleteRetention(retentionDurationMap["delete_retention"].([]interface{})),
        }</span>
}

func flattenRetentionDuration(retentionDuration *platformclientv2.Retentionduration) []interface{} <span class="cov0" title="0">{
        if retentionDuration == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">retentionDurationMap := make(map[string]interface{})

        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(retentionDurationMap, "archive_retention", retentionDuration.ArchiveRetention, flattenArchiveRetention)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(retentionDurationMap, "delete_retention", retentionDuration.DeleteRetention, flattenDeleteRetention)

        return []interface{}{retentionDurationMap}</span>
}

func buildInitiateScreenRecording(initiateScreenRecording []interface{}) *platformclientv2.Initiatescreenrecording <span class="cov0" title="0">{
        if initiateScreenRecording == nil || len(initiateScreenRecording) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">initiateScreenRecordingMap, ok := initiateScreenRecording[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">recordACW := initiateScreenRecordingMap["record_acw"].(bool)

        return &amp;platformclientv2.Initiatescreenrecording{
                RecordACW:        &amp;recordACW,
                ArchiveRetention: buildArchiveRetention(initiateScreenRecordingMap["archive_retention"].([]interface{})),
                DeleteRetention:  buildDeleteRetention(initiateScreenRecordingMap["delete_retention"].([]interface{})),
        }</span>
}

func flattenInitiateScreenRecording(recording *platformclientv2.Initiatescreenrecording) []interface{} <span class="cov0" title="0">{
        if recording == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">recordingMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(recordingMap, "record_acw", recording.RecordACW)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(recordingMap, "archive_retention", recording.ArchiveRetention, flattenArchiveRetention)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(recordingMap, "delete_retention", recording.DeleteRetention, flattenDeleteRetention)

        return []interface{}{recordingMap}</span>
}

func buildMediaTranscriptions(transcriptions []interface{}) *[]platformclientv2.Mediatranscription <span class="cov0" title="0">{
        mediaTranscriptions := make([]platformclientv2.Mediatranscription, 0)

        for _, transcription := range transcriptions </span><span class="cov0" title="0">{
                transcriptionMap, ok := transcription.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">displayName := transcriptionMap["display_name"].(string)
                transcriptionProvider := transcriptionMap["transcription_provider"].(string)
                integrationId := transcriptionMap["integration_id"].(string)

                mediaTranscriptions = append(mediaTranscriptions, platformclientv2.Mediatranscription{
                        DisplayName:           &amp;displayName,
                        TranscriptionProvider: &amp;transcriptionProvider,
                        IntegrationId:         &amp;integrationId,
                })</span>
        }

        <span class="cov0" title="0">return &amp;mediaTranscriptions</span>
}

func flattenMediaTranscriptions(transcriptions *[]platformclientv2.Mediatranscription) []interface{} <span class="cov0" title="0">{
        if transcriptions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mediaTranscriptions := make([]interface{}, 0)

        for _, transcription := range *transcriptions </span><span class="cov0" title="0">{
                transcriptionMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(transcriptionMap, "display_name", transcription.DisplayName)
                resourcedata.SetMapValueIfNotNil(transcriptionMap, "transcription_provider", transcription.TranscriptionProvider)
                resourcedata.SetMapValueIfNotNil(transcriptionMap, "integration_id", transcription.IntegrationId)

                mediaTranscriptions = append(mediaTranscriptions, transcriptionMap)
        }</span>

        <span class="cov0" title="0">return mediaTranscriptions</span>
}

func buildIntegrationExport(integrationExport []interface{}) *platformclientv2.Integrationexport <span class="cov0" title="0">{
        if integrationExport == nil || len(integrationExport) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">integrationExportMap, ok := integrationExport[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">shouldExportScreenRecordings := integrationExportMap["should_export_screen_recordings"].(bool)

        return &amp;platformclientv2.Integrationexport{
                Integration:                  buildDomainEntityRef(integrationExportMap["integration_id"].(string)),
                ShouldExportScreenRecordings: &amp;shouldExportScreenRecordings,
        }</span>
}

func flattenIntegrationExport(integrationExport *platformclientv2.Integrationexport) []interface{} <span class="cov0" title="0">{
        if integrationExport == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">integrationExportMap := make(map[string]interface{})
        if integrationExport.Integration != nil </span><span class="cov0" title="0">{
                integrationExportMap["integration_id"] = *integrationExport.Integration.Id
        }</span>
        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(integrationExportMap, "should_export_screen_recordings", integrationExport.ShouldExportScreenRecordings)

        return []interface{}{integrationExportMap}</span>
}

func buildPolicyActionsFromMediaPolicy(actions []interface{}, pp *policyProxy, ctx context.Context) *platformclientv2.Policyactions <span class="cov0" title="0">{
        if actions == nil || len(actions) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">actionsMap, ok := actions[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">retainRecording := actionsMap["retain_recording"].(bool)
        deleteRecording := actionsMap["delete_recording"].(bool)
        alwaysDelete := actionsMap["always_delete"].(bool)

        return &amp;platformclientv2.Policyactions{
                RetainRecording:                &amp;retainRecording,
                DeleteRecording:                &amp;deleteRecording,
                AlwaysDelete:                   &amp;alwaysDelete,
                AssignEvaluations:              buildEvaluationAssignments(actionsMap["assign_evaluations"].([]interface{}), pp, ctx),
                AssignMeteredEvaluations:       buildAssignMeteredEvaluations(actionsMap["assign_metered_evaluations"].([]interface{}), pp, ctx),
                AssignMeteredAssignmentByAgent: buildAssignMeteredAssignmentByAgent(actionsMap["assign_metered_assignment_by_agent"].([]interface{}), pp, ctx),
                AssignCalibrations:             buildAssignCalibrations(actionsMap["assign_calibrations"].([]interface{}), pp, ctx),
                AssignSurveys:                  buildAssignSurveys(actionsMap["assign_surveys"].([]interface{}), pp, ctx),
                RetentionDuration:              buildRetentionDuration(actionsMap["retention_duration"].([]interface{})),
                InitiateScreenRecording:        buildInitiateScreenRecording(actionsMap["initiate_screen_recording"].([]interface{})),
                MediaTranscriptions:            buildMediaTranscriptions(actionsMap["media_transcriptions"].([]interface{})),
                IntegrationExport:              buildIntegrationExport(actionsMap["integration_export"].([]interface{})),
        }</span>
}

func flattenPolicyActions(actions *platformclientv2.Policyactions, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if actions == nil || reflect.DeepEqual(platformclientv2.Policyactions{}, *actions) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">actionsMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(actionsMap, "retain_recording", actions.RetainRecording)
        resourcedata.SetMapValueIfNotNil(actionsMap, "delete_recording", actions.DeleteRecording)
        resourcedata.SetMapValueIfNotNil(actionsMap, "always_delete", actions.AlwaysDelete)

        if actions.AssignEvaluations != nil </span><span class="cov0" title="0">{
                actionsMap["assign_evaluations"] = flattenEvaluationAssignments(actions.AssignEvaluations, pp, ctx)
        }</span>
        <span class="cov0" title="0">if actions.AssignMeteredEvaluations != nil </span><span class="cov0" title="0">{
                actionsMap["assign_metered_evaluations"] = flattenAssignMeteredEvaluations(actions.AssignMeteredEvaluations, pp, ctx)
        }</span>
        <span class="cov0" title="0">if actions.AssignMeteredAssignmentByAgent != nil </span><span class="cov0" title="0">{
                actionsMap["assign_metered_assignment_by_agent"] = flattenAssignMeteredAssignmentByAgent(actions.AssignMeteredAssignmentByAgent, pp, ctx)
        }</span>
        <span class="cov0" title="0">if actions.AssignCalibrations != nil </span><span class="cov0" title="0">{
                actionsMap["assign_calibrations"] = flattenAssignCalibrations(actions.AssignCalibrations, pp, ctx)
        }</span>

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionsMap, "assign_surveys", actions.AssignSurveys, flattenAssignSurveys)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionsMap, "retention_duration", actions.RetentionDuration, flattenRetentionDuration)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionsMap, "initiate_screen_recording", actions.InitiateScreenRecording, flattenInitiateScreenRecording)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionsMap, "media_transcriptions", actions.MediaTranscriptions, flattenMediaTranscriptions)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(actionsMap, "integration_export", actions.IntegrationExport, flattenIntegrationExport)

        return []interface{}{actionsMap}</span>
}

func buildTimeSlots(slots []interface{}) *[]platformclientv2.Timeslot <span class="cov0" title="0">{
        timeSlots := make([]platformclientv2.Timeslot, 0)

        for _, slot := range slots </span><span class="cov0" title="0">{
                slotMap, ok := slot.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">startTime := slotMap["start_time"].(string)
                stopTime := slotMap["stop_time"].(string)
                day := slotMap["day"].(int)

                timeSlots = append(timeSlots, platformclientv2.Timeslot{
                        StartTime: &amp;startTime,
                        StopTime:  &amp;stopTime,
                        Day:       &amp;day,
                })</span>
        }

        <span class="cov0" title="0">return &amp;timeSlots</span>
}

func flattenTimeSlots(slots *[]platformclientv2.Timeslot) []interface{} <span class="cov0" title="0">{
        if slots == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">slotList := make([]interface{}, 0)

        for _, slot := range *slots </span><span class="cov0" title="0">{
                slotMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(slotMap, "start_time", slot.StartTime)
                resourcedata.SetMapValueIfNotNil(slotMap, "stop_time", slot.StopTime)
                resourcedata.SetMapValueIfNotNil(slotMap, "day", slot.Day)

                slotList = append(slotList, slotMap)
        }</span>

        <span class="cov0" title="0">return slotList</span>
}

func buildTimeAllowed(timeAllowed []interface{}) *platformclientv2.Timeallowed <span class="cov0" title="0">{
        if timeAllowed == nil || len(timeAllowed) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">timeAllowedMap, ok := timeAllowed[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">timeZoneId := timeAllowedMap["time_zone_id"].(string)
        empty := timeAllowedMap["empty"].(bool)

        return &amp;platformclientv2.Timeallowed{
                TimeSlots:  buildTimeSlots(timeAllowedMap["time_slots"].([]interface{})),
                TimeZoneId: &amp;timeZoneId,
                Empty:      &amp;empty,
        }</span>
}

func flattenTimeAllowed(timeAllowed *platformclientv2.Timeallowed) []interface{} <span class="cov0" title="0">{
        if timeAllowed == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">timeAllowedMap := make(map[string]interface{})

        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(timeAllowedMap, "time_slots", timeAllowed.TimeSlots, flattenTimeSlots)
        resourcedata.SetMapValueIfNotNil(timeAllowedMap, "time_zone_id", timeAllowed.TimeZoneId)
        resourcedata.SetMapValueIfNotNil(timeAllowedMap, "empty", timeAllowed.Empty)

        return []interface{}{timeAllowedMap}</span>
}

func buildDurationCondition(durationCondition []interface{}) *platformclientv2.Durationcondition <span class="cov0" title="0">{
        if durationCondition == nil || len(durationCondition) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">durationConditionMap, ok := durationCondition[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">durationTarget := durationConditionMap["duration_target"].(string)
        durationOperator := durationConditionMap["duration_operator"].(string)
        durationRange := durationConditionMap["duration_range"].(string)
        durationMode := durationConditionMap["duration_mode"].(string)

        return &amp;platformclientv2.Durationcondition{
                DurationTarget:   &amp;durationTarget,
                DurationOperator: &amp;durationOperator,
                DurationRange:    &amp;durationRange,
                DurationMode:     &amp;durationMode,
        }</span>
}

func flattenDurationCondition(durationCondition *platformclientv2.Durationcondition) []interface{} <span class="cov0" title="0">{
        if durationCondition == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">durationConditionMap := make(map[string]interface{})

        resourcedata.SetMapValueIfNotNil(durationConditionMap, "duration_target", durationCondition.DurationTarget)
        resourcedata.SetMapValueIfNotNil(durationConditionMap, "duration_operator", durationCondition.DurationOperator)
        resourcedata.SetMapValueIfNotNil(durationConditionMap, "duration_range", durationCondition.DurationRange)
        resourcedata.SetMapValueIfNotNil(durationConditionMap, "duration_mode", durationCondition.DurationMode)

        return []interface{}{durationConditionMap}</span>
}

func buildCallMediaPolicyConditions(callMediaPolicyConditions []interface{}) *platformclientv2.Callmediapolicyconditions <span class="cov0" title="0">{
        if callMediaPolicyConditions == nil || len(callMediaPolicyConditions) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap, ok := callMediaPolicyConditions[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">directions := make([]string, 0)
        for _, v := range conditionsMap["directions"].([]interface{}) </span><span class="cov0" title="0">{
                direction := fmt.Sprintf("%v", v)
                directions = append(directions, direction)
        }</span>

        <span class="cov0" title="0">dateRanges := make([]string, 0)
        for _, v := range conditionsMap["date_ranges"].([]interface{}) </span><span class="cov0" title="0">{
                dateRange := fmt.Sprintf("%v", v)
                dateRanges = append(dateRanges, dateRange)
        }</span>

        <span class="cov0" title="0">forUserIds := conditionsMap["for_user_ids"].([]interface{})
        idStrings := make([]string, 0)
        for _, id := range forUserIds </span><span class="cov0" title="0">{
                idStrings = append(idStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forUsers := make([]platformclientv2.User, 0)
        for _, id := range idStrings </span><span class="cov0" title="0">{
                userId := id
                forUsers = append(forUsers, platformclientv2.User{Id: &amp;userId})
        }</span>

        <span class="cov0" title="0">wrapupCodeIds := conditionsMap["wrapup_code_ids"].([]interface{})
        wrapupCodeIdStrings := make([]string, 0)
        for _, id := range wrapupCodeIds </span><span class="cov0" title="0">{
                wrapupCodeIdStrings = append(wrapupCodeIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">wrapupCodes := make([]platformclientv2.Wrapupcode, 0)
        for _, id := range wrapupCodeIdStrings </span><span class="cov0" title="0">{
                wrapupId := id
                wrapupCodes = append(wrapupCodes, platformclientv2.Wrapupcode{Id: &amp;wrapupId})
        }</span>

        <span class="cov0" title="0">languageIds := conditionsMap["language_ids"].([]interface{})
        languageIdStrings := make([]string, 0)
        for _, id := range languageIds </span><span class="cov0" title="0">{
                languageIdStrings = append(languageIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">languages := make([]platformclientv2.Language, 0)
        for _, id := range languageIdStrings </span><span class="cov0" title="0">{
                languageId := id
                languages = append(languages, platformclientv2.Language{Id: &amp;languageId})
        }</span>

        <span class="cov0" title="0">forQueueIds := conditionsMap["for_queue_ids"].([]interface{})
        queueIdStrings := make([]string, 0)
        for _, id := range forQueueIds </span><span class="cov0" title="0">{
                queueIdStrings = append(queueIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forQueues := make([]platformclientv2.Queue, 0)
        for _, id := range queueIdStrings </span><span class="cov0" title="0">{
                queueId := id
                forQueues = append(forQueues, platformclientv2.Queue{Id: &amp;queueId})
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Callmediapolicyconditions{
                ForUsers:    &amp;forUsers,
                DateRanges:  &amp;dateRanges,
                ForQueues:   &amp;forQueues,
                WrapupCodes: &amp;wrapupCodes,
                Languages:   &amp;languages,
                TimeAllowed: buildTimeAllowed(conditionsMap["time_allowed"].([]interface{})),
                Directions:  &amp;directions,
                Duration:    buildDurationCondition(conditionsMap["duration"].([]interface{})),
        }</span>
}

func flattenCallMediaPolicyConditions(conditions *platformclientv2.Callmediapolicyconditions) []interface{} <span class="cov0" title="0">{
        if conditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap := make(map[string]interface{})
        if conditions.ForUsers != nil </span><span class="cov0" title="0">{
                userIds := make([]string, 0)
                for _, user := range *conditions.ForUsers </span><span class="cov0" title="0">{
                        userIds = append(userIds, *user.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_user_ids"] = userIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(conditionsMap, "date_ranges", conditions.DateRanges)
        resourcedata.SetMapValueIfNotNil(conditionsMap, "directions", conditions.Directions)

        if conditions.ForQueues != nil </span><span class="cov0" title="0">{
                queueIds := make([]string, 0)
                for _, queue := range *conditions.ForQueues </span><span class="cov0" title="0">{
                        queueIds = append(queueIds, *queue.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_queue_ids"] = queueIds</span>
        }
        <span class="cov0" title="0">if conditions.WrapupCodes != nil </span><span class="cov0" title="0">{
                wrapupCodeIds := make([]string, 0)
                for _, code := range *conditions.WrapupCodes </span><span class="cov0" title="0">{
                        wrapupCodeIds = append(wrapupCodeIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["wrapup_code_ids"] = wrapupCodeIds</span>
        }
        <span class="cov0" title="0">if conditions.Languages != nil </span><span class="cov0" title="0">{
                languageIds := make([]string, 0)
                for _, code := range *conditions.Languages </span><span class="cov0" title="0">{
                        languageIds = append(languageIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["language_ids"] = languageIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "time_allowed", conditions.TimeAllowed, flattenTimeAllowed)

        return []interface{}{conditionsMap}</span>
}

func buildChatMediaPolicyConditions(chatMediaPolicyConditions []interface{}) *platformclientv2.Chatmediapolicyconditions <span class="cov0" title="0">{
        if chatMediaPolicyConditions == nil || len(chatMediaPolicyConditions) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap, ok := chatMediaPolicyConditions[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dateRanges := make([]string, 0)
        for _, v := range conditionsMap["date_ranges"].([]interface{}) </span><span class="cov0" title="0">{
                dateRange := fmt.Sprintf("%v", v)
                dateRanges = append(dateRanges, dateRange)
        }</span>

        <span class="cov0" title="0">forUserIds := conditionsMap["for_user_ids"].([]interface{})
        idStrings := make([]string, 0)
        for _, id := range forUserIds </span><span class="cov0" title="0">{
                idStrings = append(idStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forUsers := make([]platformclientv2.User, 0)
        for _, id := range idStrings </span><span class="cov0" title="0">{
                userId := id
                forUsers = append(forUsers, platformclientv2.User{Id: &amp;userId})
        }</span>

        <span class="cov0" title="0">wrapupCodeIds := conditionsMap["wrapup_code_ids"].([]interface{})
        wrapupCodeIdStrings := make([]string, 0)
        for _, id := range wrapupCodeIds </span><span class="cov0" title="0">{
                wrapupCodeIdStrings = append(wrapupCodeIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">wrapupCodes := make([]platformclientv2.Wrapupcode, 0)
        for _, id := range wrapupCodeIdStrings </span><span class="cov0" title="0">{
                wrapupId := id
                wrapupCodes = append(wrapupCodes, platformclientv2.Wrapupcode{Id: &amp;wrapupId})
        }</span>

        <span class="cov0" title="0">languageIds := conditionsMap["language_ids"].([]interface{})
        languageIdStrings := make([]string, 0)
        for _, id := range languageIds </span><span class="cov0" title="0">{
                languageIdStrings = append(languageIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">languages := make([]platformclientv2.Language, 0)
        for _, id := range languageIdStrings </span><span class="cov0" title="0">{
                languageId := id
                languages = append(languages, platformclientv2.Language{Id: &amp;languageId})
        }</span>

        <span class="cov0" title="0">forQueueIds := conditionsMap["for_queue_ids"].([]interface{})
        queueIdStrings := make([]string, 0)
        for _, id := range forQueueIds </span><span class="cov0" title="0">{
                queueIdStrings = append(queueIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forQueues := make([]platformclientv2.Queue, 0)
        for _, id := range queueIdStrings </span><span class="cov0" title="0">{
                queueId := id
                forQueues = append(forQueues, platformclientv2.Queue{Id: &amp;queueId})
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Chatmediapolicyconditions{
                ForUsers:    &amp;forUsers,
                DateRanges:  &amp;dateRanges,
                ForQueues:   &amp;forQueues,
                WrapupCodes: &amp;wrapupCodes,
                Languages:   &amp;languages,
                TimeAllowed: buildTimeAllowed(conditionsMap["time_allowed"].([]interface{})),
                Duration:    buildDurationCondition(conditionsMap["duration"].([]interface{})),
        }</span>
}

func flattenChatMediaPolicyConditions(conditions *platformclientv2.Chatmediapolicyconditions) []interface{} <span class="cov0" title="0">{
        if conditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap := make(map[string]interface{})
        if conditions.ForUsers != nil </span><span class="cov0" title="0">{
                userIds := make([]string, 0)
                for _, user := range *conditions.ForUsers </span><span class="cov0" title="0">{
                        userIds = append(userIds, *user.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_user_ids"] = userIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(conditionsMap, "date_ranges", conditions.DateRanges)

        if conditions.ForQueues != nil </span><span class="cov0" title="0">{
                queueIds := make([]string, 0)
                for _, queue := range *conditions.ForQueues </span><span class="cov0" title="0">{
                        queueIds = append(queueIds, *queue.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_queue_ids"] = queueIds</span>
        }
        <span class="cov0" title="0">if conditions.WrapupCodes != nil </span><span class="cov0" title="0">{
                wrapupCodeIds := make([]string, 0)
                for _, code := range *conditions.WrapupCodes </span><span class="cov0" title="0">{
                        wrapupCodeIds = append(wrapupCodeIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["wrapup_code_ids"] = wrapupCodeIds</span>
        }
        <span class="cov0" title="0">if conditions.Languages != nil </span><span class="cov0" title="0">{
                languageIds := make([]string, 0)
                for _, code := range *conditions.Languages </span><span class="cov0" title="0">{
                        languageIds = append(languageIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["language_ids"] = languageIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "time_allowed", conditions.TimeAllowed, flattenTimeAllowed)
        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "duration", conditions.Duration, flattenDurationCondition)

        return []interface{}{conditionsMap}</span>
}

func buildEmailMediaPolicyConditions(emailMediaPolicyConditions []interface{}) *platformclientv2.Emailmediapolicyconditions <span class="cov0" title="0">{
        if emailMediaPolicyConditions == nil || len(emailMediaPolicyConditions) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap, ok := emailMediaPolicyConditions[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dateRanges := make([]string, 0)
        for _, v := range conditionsMap["date_ranges"].([]interface{}) </span><span class="cov0" title="0">{
                dateRange := fmt.Sprintf("%v", v)
                dateRanges = append(dateRanges, dateRange)
        }</span>

        <span class="cov0" title="0">forUserIds := conditionsMap["for_user_ids"].([]interface{})
        idStrings := make([]string, 0)
        for _, id := range forUserIds </span><span class="cov0" title="0">{
                idStrings = append(idStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forUsers := make([]platformclientv2.User, 0)
        for _, id := range idStrings </span><span class="cov0" title="0">{
                userId := id
                forUsers = append(forUsers, platformclientv2.User{Id: &amp;userId})
        }</span>

        <span class="cov0" title="0">wrapupCodeIds := conditionsMap["wrapup_code_ids"].([]interface{})
        wrapupCodeIdStrings := make([]string, 0)
        for _, id := range wrapupCodeIds </span><span class="cov0" title="0">{
                wrapupCodeIdStrings = append(wrapupCodeIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">wrapupCodes := make([]platformclientv2.Wrapupcode, 0)
        for _, id := range wrapupCodeIdStrings </span><span class="cov0" title="0">{
                wrapupId := id
                wrapupCodes = append(wrapupCodes, platformclientv2.Wrapupcode{Id: &amp;wrapupId})
        }</span>

        <span class="cov0" title="0">languageIds := conditionsMap["language_ids"].([]interface{})
        languageIdStrings := make([]string, 0)
        for _, id := range languageIds </span><span class="cov0" title="0">{
                languageIdStrings = append(languageIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">languages := make([]platformclientv2.Language, 0)
        for _, id := range languageIdStrings </span><span class="cov0" title="0">{
                languageId := id
                languages = append(languages, platformclientv2.Language{Id: &amp;languageId})
        }</span>

        <span class="cov0" title="0">forQueueIds := conditionsMap["for_queue_ids"].([]interface{})
        queueIdStrings := make([]string, 0)
        for _, id := range forQueueIds </span><span class="cov0" title="0">{
                queueIdStrings = append(queueIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forQueues := make([]platformclientv2.Queue, 0)
        for _, id := range queueIdStrings </span><span class="cov0" title="0">{
                queueId := id
                forQueues = append(forQueues, platformclientv2.Queue{Id: &amp;queueId})
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Emailmediapolicyconditions{
                ForUsers:    &amp;forUsers,
                DateRanges:  &amp;dateRanges,
                ForQueues:   &amp;forQueues,
                WrapupCodes: &amp;wrapupCodes,
                Languages:   &amp;languages,
                TimeAllowed: buildTimeAllowed(conditionsMap["time_allowed"].([]interface{})),
        }</span>
}

func flattenEmailMediaPolicyConditions(conditions *platformclientv2.Emailmediapolicyconditions) []interface{} <span class="cov0" title="0">{
        if conditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap := make(map[string]interface{})
        if conditions.ForUsers != nil </span><span class="cov0" title="0">{
                userIds := make([]string, 0)
                for _, user := range *conditions.ForUsers </span><span class="cov0" title="0">{
                        userIds = append(userIds, *user.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_user_ids"] = userIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(conditionsMap, "date_ranges", conditions.DateRanges)

        if conditions.ForQueues != nil </span><span class="cov0" title="0">{
                queueIds := make([]string, 0)
                for _, queue := range *conditions.ForQueues </span><span class="cov0" title="0">{
                        queueIds = append(queueIds, *queue.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_queue_ids"] = queueIds</span>
        }
        <span class="cov0" title="0">if conditions.WrapupCodes != nil </span><span class="cov0" title="0">{
                wrapupCodeIds := make([]string, 0)
                for _, code := range *conditions.WrapupCodes </span><span class="cov0" title="0">{
                        wrapupCodeIds = append(wrapupCodeIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["wrapup_code_ids"] = wrapupCodeIds</span>
        }
        <span class="cov0" title="0">if conditions.Languages != nil </span><span class="cov0" title="0">{
                languageIds := make([]string, 0)
                for _, code := range *conditions.Languages </span><span class="cov0" title="0">{
                        languageIds = append(languageIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["language_ids"] = languageIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "time_allowed", conditions.TimeAllowed, flattenTimeAllowed)

        return []interface{}{conditionsMap}</span>
}

func buildMessageMediaPolicyConditions(messageMediaPolicyConditions []interface{}) *platformclientv2.Messagemediapolicyconditions <span class="cov0" title="0">{
        if messageMediaPolicyConditions == nil || len(messageMediaPolicyConditions) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap, ok := messageMediaPolicyConditions[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dateRanges := make([]string, 0)
        for _, v := range conditionsMap["date_ranges"].([]interface{}) </span><span class="cov0" title="0">{
                dateRange := fmt.Sprintf("%v", v)
                dateRanges = append(dateRanges, dateRange)
        }</span>

        <span class="cov0" title="0">forUserIds := conditionsMap["for_user_ids"].([]interface{})
        idStrings := make([]string, 0)
        for _, id := range forUserIds </span><span class="cov0" title="0">{
                idStrings = append(idStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forUsers := make([]platformclientv2.User, 0)
        for _, id := range idStrings </span><span class="cov0" title="0">{
                userId := id
                forUsers = append(forUsers, platformclientv2.User{Id: &amp;userId})
        }</span>

        <span class="cov0" title="0">wrapupCodeIds := conditionsMap["wrapup_code_ids"].([]interface{})
        wrapupCodeIdStrings := make([]string, 0)
        for _, id := range wrapupCodeIds </span><span class="cov0" title="0">{
                wrapupCodeIdStrings = append(wrapupCodeIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">wrapupCodes := make([]platformclientv2.Wrapupcode, 0)
        for _, id := range wrapupCodeIdStrings </span><span class="cov0" title="0">{
                wrapupId := id
                wrapupCodes = append(wrapupCodes, platformclientv2.Wrapupcode{Id: &amp;wrapupId})
        }</span>

        <span class="cov0" title="0">languageIds := conditionsMap["language_ids"].([]interface{})
        languageIdStrings := make([]string, 0)
        for _, id := range languageIds </span><span class="cov0" title="0">{
                languageIdStrings = append(languageIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">languages := make([]platformclientv2.Language, 0)
        for _, id := range languageIdStrings </span><span class="cov0" title="0">{
                languageId := id
                languages = append(languages, platformclientv2.Language{Id: &amp;languageId})
        }</span>

        <span class="cov0" title="0">forQueueIds := conditionsMap["for_queue_ids"].([]interface{})
        queueIdStrings := make([]string, 0)
        for _, id := range forQueueIds </span><span class="cov0" title="0">{
                queueIdStrings = append(queueIdStrings, fmt.Sprintf("%v", id))
        }</span>

        <span class="cov0" title="0">forQueues := make([]platformclientv2.Queue, 0)
        for _, id := range queueIdStrings </span><span class="cov0" title="0">{
                queueId := id
                forQueues = append(forQueues, platformclientv2.Queue{Id: &amp;queueId})
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Messagemediapolicyconditions{
                ForUsers:    &amp;forUsers,
                DateRanges:  &amp;dateRanges,
                ForQueues:   &amp;forQueues,
                WrapupCodes: &amp;wrapupCodes,
                Languages:   &amp;languages,
                TimeAllowed: buildTimeAllowed(conditionsMap["time_allowed"].([]interface{})),
        }</span>
}

func flattenMessageMediaPolicyConditions(conditions *platformclientv2.Messagemediapolicyconditions) []interface{} <span class="cov0" title="0">{
        if conditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap := make(map[string]interface{})
        if conditions.ForUsers != nil </span><span class="cov0" title="0">{
                userIds := make([]string, 0)
                for _, user := range *conditions.ForUsers </span><span class="cov0" title="0">{
                        userIds = append(userIds, *user.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_user_ids"] = userIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(conditionsMap, "date_ranges", conditions.DateRanges)

        if conditions.ForQueues != nil </span><span class="cov0" title="0">{
                queueIds := make([]string, 0)
                for _, queue := range *conditions.ForQueues </span><span class="cov0" title="0">{
                        queueIds = append(queueIds, *queue.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_queue_ids"] = queueIds</span>
        }
        <span class="cov0" title="0">if conditions.WrapupCodes != nil </span><span class="cov0" title="0">{
                wrapupCodeIds := make([]string, 0)
                for _, code := range *conditions.WrapupCodes </span><span class="cov0" title="0">{
                        wrapupCodeIds = append(wrapupCodeIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["wrapup_code_ids"] = wrapupCodeIds</span>
        }
        <span class="cov0" title="0">if conditions.Languages != nil </span><span class="cov0" title="0">{
                languageIds := make([]string, 0)
                for _, code := range *conditions.Languages </span><span class="cov0" title="0">{
                        languageIds = append(languageIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["language_ids"] = languageIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "time_allowed", conditions.TimeAllowed, flattenTimeAllowed)

        return []interface{}{conditionsMap}</span>
}

func buildCallMediaPolicy(callMediaPolicy []interface{}, pp *policyProxy, ctx context.Context) *platformclientv2.Callmediapolicy <span class="cov0" title="0">{
        if callMediaPolicy == nil || len(callMediaPolicy) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">policyMap, ok := callMediaPolicy[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;platformclientv2.Callmediapolicy{
                Actions:    buildPolicyActionsFromMediaPolicy(policyMap["actions"].([]interface{}), pp, ctx),
                Conditions: buildCallMediaPolicyConditions(policyMap["conditions"].([]interface{})),
        }</span>
}

func flattenCallMediaPolicy(chatMediaPolicy *platformclientv2.Callmediapolicy, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if chatMediaPolicy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">chatMediaPolicyMap := make(map[string]interface{})
        if chatMediaPolicy.Actions != nil </span><span class="cov0" title="0">{
                chatMediaPolicyMap["actions"] = flattenPolicyActions(chatMediaPolicy.Actions, pp, ctx)
        }</span>

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(chatMediaPolicyMap, "conditions", chatMediaPolicy.Conditions, flattenCallMediaPolicyConditions)

        return []interface{}{chatMediaPolicyMap}</span>
}

func buildChatMediaPolicy(chatMediaPolicy []interface{}, pp *policyProxy, ctx context.Context) *platformclientv2.Chatmediapolicy <span class="cov0" title="0">{
        if chatMediaPolicy == nil || len(chatMediaPolicy) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">policyMap, ok := chatMediaPolicy[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Chatmediapolicy{
                Actions:    buildPolicyActionsFromMediaPolicy(policyMap["actions"].([]interface{}), pp, ctx),
                Conditions: buildChatMediaPolicyConditions(policyMap["conditions"].([]interface{})),
        }</span>
}

func flattenChatMediaPolicy(chatMediaPolicy *platformclientv2.Chatmediapolicy, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if chatMediaPolicy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">chatMediaPolicyMap := make(map[string]interface{})
        if chatMediaPolicy.Actions != nil </span><span class="cov0" title="0">{
                chatMediaPolicyMap["actions"] = flattenPolicyActions(chatMediaPolicy.Actions, pp, ctx)
        }</span>

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(chatMediaPolicyMap, "conditions", chatMediaPolicy.Conditions, flattenChatMediaPolicyConditions)

        return []interface{}{chatMediaPolicyMap}</span>
}

func buildEmailMediaPolicy(emailMediaPolicy []interface{}, pp *policyProxy, ctx context.Context) *platformclientv2.Emailmediapolicy <span class="cov0" title="0">{
        if emailMediaPolicy == nil || len(emailMediaPolicy) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">policyMap, ok := emailMediaPolicy[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Emailmediapolicy{
                Actions:    buildPolicyActionsFromMediaPolicy(policyMap["actions"].([]interface{}), pp, ctx),
                Conditions: buildEmailMediaPolicyConditions(policyMap["conditions"].([]interface{})),
        }</span>
}

func flattenEmailMediaPolicy(emailMediaPolicy *platformclientv2.Emailmediapolicy, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if emailMediaPolicy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">emailMediaPolicyMap := make(map[string]interface{})
        if emailMediaPolicy.Actions != nil </span><span class="cov0" title="0">{
                emailMediaPolicyMap["actions"] = flattenPolicyActions(emailMediaPolicy.Actions, pp, ctx)
        }</span>

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(emailMediaPolicyMap, "conditions", emailMediaPolicy.Conditions, flattenEmailMediaPolicyConditions)

        return []interface{}{emailMediaPolicyMap}</span>
}

func buildMessageMediaPolicy(messageMediaPolicy []interface{}, pp *policyProxy, ctx context.Context) *platformclientv2.Messagemediapolicy <span class="cov0" title="0">{
        if messageMediaPolicy == nil || len(messageMediaPolicy) &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">policyMap, ok := messageMediaPolicy[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;platformclientv2.Messagemediapolicy{
                Actions:    buildPolicyActionsFromMediaPolicy(policyMap["actions"].([]interface{}), pp, ctx),
                Conditions: buildMessageMediaPolicyConditions(policyMap["conditions"].([]interface{})),
        }</span>
}

func flattenMessageMediaPolicy(messageMediaPolicy *platformclientv2.Messagemediapolicy, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if messageMediaPolicy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">messageMediaPolicyMap := make(map[string]interface{})
        if messageMediaPolicy.Actions != nil </span><span class="cov0" title="0">{
                messageMediaPolicyMap["actions"] = flattenPolicyActions(messageMediaPolicy.Actions, pp, ctx)
        }</span>

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(messageMediaPolicyMap, "conditions", messageMediaPolicy.Conditions, flattenMessageMediaPolicyConditions)

        return []interface{}{messageMediaPolicyMap}</span>
}

func buildMediaPolicies(d *schema.ResourceData, pp *policyProxy, ctx context.Context) *platformclientv2.Mediapolicies <span class="cov0" title="0">{
        sdkMediaPolicies := platformclientv2.Mediapolicies{}

        if mediaPolicies, ok := d.Get("media_policies").([]interface{}); ok &amp;&amp; len(mediaPolicies) &gt; 0 </span><span class="cov0" title="0">{
                mediaPoliciesMap, ok := mediaPolicies[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if callPolicy := mediaPoliciesMap["call_policy"]; callPolicy != nil </span><span class="cov0" title="0">{
                        sdkMediaPolicies.CallPolicy = buildCallMediaPolicy(callPolicy.([]interface{}), pp, ctx)
                }</span>

                <span class="cov0" title="0">if chatPolicy := mediaPoliciesMap["chat_policy"]; chatPolicy != nil </span><span class="cov0" title="0">{
                        sdkMediaPolicies.ChatPolicy = buildChatMediaPolicy(chatPolicy.([]interface{}), pp, ctx)
                }</span>

                <span class="cov0" title="0">if emailPolicy := mediaPoliciesMap["email_policy"]; emailPolicy != nil </span><span class="cov0" title="0">{
                        sdkMediaPolicies.EmailPolicy = buildEmailMediaPolicy(emailPolicy.([]interface{}), pp, ctx)
                }</span>

                <span class="cov0" title="0">if messagePolicy := mediaPoliciesMap["message_policy"]; messagePolicy != nil </span><span class="cov0" title="0">{
                        sdkMediaPolicies.MessagePolicy = buildMessageMediaPolicy(messagePolicy.([]interface{}), pp, ctx)
                }</span>
        }

        <span class="cov0" title="0">return &amp;sdkMediaPolicies</span>
}

func flattenMediaPolicies(mediaPolicies *platformclientv2.Mediapolicies, pp *policyProxy, ctx context.Context) []interface{} <span class="cov0" title="0">{
        if mediaPolicies == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mediaPoliciesMap := make(map[string]interface{})
        if mediaPolicies.CallPolicy != nil </span><span class="cov0" title="0">{
                mediaPoliciesMap["call_policy"] = flattenCallMediaPolicy(mediaPolicies.CallPolicy, pp, ctx)
        }</span>
        <span class="cov0" title="0">if mediaPolicies.ChatPolicy != nil </span><span class="cov0" title="0">{
                mediaPoliciesMap["chat_policy"] = flattenChatMediaPolicy(mediaPolicies.ChatPolicy, pp, ctx)
        }</span>
        <span class="cov0" title="0">if mediaPolicies.EmailPolicy != nil </span><span class="cov0" title="0">{
                mediaPoliciesMap["email_policy"] = flattenEmailMediaPolicy(mediaPolicies.EmailPolicy, pp, ctx)
        }</span>
        <span class="cov0" title="0">if mediaPolicies.MessagePolicy != nil </span><span class="cov0" title="0">{
                mediaPoliciesMap["message_policy"] = flattenMessageMediaPolicy(mediaPolicies.MessagePolicy, pp, ctx)
        }</span>

        <span class="cov0" title="0">return []interface{}{mediaPoliciesMap}</span>
}

func buildConditions(d *schema.ResourceData) *platformclientv2.Policyconditions <span class="cov0" title="0">{
        if conditions, ok := d.Get("conditions").([]interface{}); ok &amp;&amp; len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                conditionsMap, ok := conditions[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">directions := make([]string, 0)
                for _, v := range conditionsMap["directions"].([]interface{}) </span><span class="cov0" title="0">{
                        direction := fmt.Sprintf("%v", v)
                        directions = append(directions, direction)
                }</span>

                <span class="cov0" title="0">dateRanges := make([]string, 0)
                for _, v := range conditionsMap["date_ranges"].([]interface{}) </span><span class="cov0" title="0">{
                        dateRange := fmt.Sprintf("%v", v)
                        dateRanges = append(dateRanges, dateRange)
                }</span>

                <span class="cov0" title="0">mediaTypes := make([]string, 0)
                for _, v := range conditionsMap["media_types"].([]interface{}) </span><span class="cov0" title="0">{
                        mediaType := fmt.Sprintf("%v", v)
                        mediaTypes = append(mediaTypes, mediaType)
                }</span>

                <span class="cov0" title="0">forUserIds := conditionsMap["for_user_ids"].([]interface{})
                idStrings := make([]string, 0)
                for _, id := range forUserIds </span><span class="cov0" title="0">{
                        idStrings = append(idStrings, fmt.Sprintf("%v", id))
                }</span>

                <span class="cov0" title="0">forUsers := make([]platformclientv2.User, 0)
                for _, id := range idStrings </span><span class="cov0" title="0">{
                        userId := id
                        forUsers = append(forUsers, platformclientv2.User{Id: &amp;userId})
                }</span>

                <span class="cov0" title="0">wrapupCodeIds := conditionsMap["wrapup_code_ids"].([]interface{})
                wrapupCodeIdStrings := make([]string, 0)
                for _, id := range wrapupCodeIds </span><span class="cov0" title="0">{
                        wrapupCodeIdStrings = append(wrapupCodeIdStrings, fmt.Sprintf("%v", id))
                }</span>

                <span class="cov0" title="0">wrapupCodes := make([]platformclientv2.Wrapupcode, 0)
                for _, id := range wrapupCodeIdStrings </span><span class="cov0" title="0">{
                        wrapupId := id
                        wrapupCodes = append(wrapupCodes, platformclientv2.Wrapupcode{Id: &amp;wrapupId})
                }</span>

                <span class="cov0" title="0">forQueueIds := conditionsMap["for_queue_ids"].([]interface{})
                queueIdStrings := make([]string, 0)
                for _, id := range forQueueIds </span><span class="cov0" title="0">{
                        queueIdStrings = append(queueIdStrings, fmt.Sprintf("%v", id))
                }</span>

                <span class="cov0" title="0">forQueues := make([]platformclientv2.Queue, 0)
                for _, id := range queueIdStrings </span><span class="cov0" title="0">{
                        queueId := id
                        forQueues = append(forQueues, platformclientv2.Queue{Id: &amp;queueId})
                }</span>

                <span class="cov0" title="0">return &amp;platformclientv2.Policyconditions{
                        ForUsers:    &amp;forUsers,
                        Directions:  &amp;directions,
                        DateRanges:  &amp;dateRanges,
                        MediaTypes:  &amp;mediaTypes,
                        ForQueues:   &amp;forQueues,
                        Duration:    buildDurationCondition(conditionsMap["duration"].([]interface{})),
                        WrapupCodes: &amp;wrapupCodes,
                        TimeAllowed: buildTimeAllowed(conditionsMap["time_allowed"].([]interface{})),
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func flattenConditions(conditions *platformclientv2.Policyconditions) []interface{} <span class="cov0" title="0">{
        if conditions == nil || reflect.DeepEqual(platformclientv2.Policyconditions{}, *conditions) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conditionsMap := make(map[string]interface{})
        if conditions.ForUsers != nil </span><span class="cov0" title="0">{
                userIds := make([]string, 0)
                for _, user := range *conditions.ForUsers </span><span class="cov0" title="0">{
                        userIds = append(userIds, *user.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_user_ids"] = userIds</span>
        }
        <span class="cov0" title="0">resourcedata.SetMapValueIfNotNil(conditionsMap, "directions", conditions.Directions)
        resourcedata.SetMapValueIfNotNil(conditionsMap, "date_ranges", conditions.DateRanges)
        resourcedata.SetMapValueIfNotNil(conditionsMap, "media_types", conditions.MediaTypes)

        if conditions.ForQueues != nil </span><span class="cov0" title="0">{
                queueIds := make([]string, 0)
                for _, queue := range *conditions.ForQueues </span><span class="cov0" title="0">{
                        queueIds = append(queueIds, *queue.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["for_queue_ids"] = queueIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "duration", conditions.Duration, flattenDurationCondition)

        if conditions.WrapupCodes != nil </span><span class="cov0" title="0">{
                wrapupCodeIds := make([]string, 0)
                for _, code := range *conditions.WrapupCodes </span><span class="cov0" title="0">{
                        wrapupCodeIds = append(wrapupCodeIds, *code.Id)
                }</span>
                <span class="cov0" title="0">conditionsMap["wrapup_code_ids"] = wrapupCodeIds</span>
        }

        <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(conditionsMap, "time_allowed", conditions.TimeAllowed, flattenTimeAllowed)

        return []interface{}{conditionsMap}</span>
}

func buildPolicyActionsFromResource(d *schema.ResourceData, pp *policyProxy, ctx context.Context) *platformclientv2.Policyactions <span class="cov0" title="0">{

        if actions, ok := d.Get("actions").([]interface{}); ok &amp;&amp; len(actions) &gt; 0 </span><span class="cov0" title="0">{
                actionsMap, ok := actions[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">retainRecording := actionsMap["retain_recording"].(bool)
                deleteRecording := actionsMap["delete_recording"].(bool)
                alwaysDelete := actionsMap["always_delete"].(bool)

                return &amp;platformclientv2.Policyactions{
                        RetainRecording:                &amp;retainRecording,
                        DeleteRecording:                &amp;deleteRecording,
                        AlwaysDelete:                   &amp;alwaysDelete,
                        AssignEvaluations:              buildEvaluationAssignments(actionsMap["assign_evaluations"].([]interface{}), pp, ctx),
                        AssignMeteredEvaluations:       buildAssignMeteredEvaluations(actionsMap["assign_metered_evaluations"].([]interface{}), pp, ctx),
                        AssignMeteredAssignmentByAgent: buildAssignMeteredAssignmentByAgent(actionsMap["assign_metered_assignment_by_agent"].([]interface{}), pp, ctx),
                        AssignCalibrations:             buildAssignCalibrations(actionsMap["assign_calibrations"].([]interface{}), pp, ctx),
                        AssignSurveys:                  buildAssignSurveys(actionsMap["assign_surveys"].([]interface{}), pp, ctx),
                        RetentionDuration:              buildRetentionDuration(actionsMap["retention_duration"].([]interface{})),
                        InitiateScreenRecording:        buildInitiateScreenRecording(actionsMap["initiate_screen_recording"].([]interface{})),
                        MediaTranscriptions:            buildMediaTranscriptions(actionsMap["media_transcriptions"].([]interface{})),
                        IntegrationExport:              buildIntegrationExport(actionsMap["integration_export"].([]interface{})),
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func buildUserParams(params []interface{}) *[]platformclientv2.Userparam <span class="cov0" title="0">{
        userParams := make([]platformclientv2.Userparam, 0)

        for _, param := range params </span><span class="cov0" title="0">{
                paramMap, ok := param.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">key := paramMap["key"].(string)
                value := paramMap["value"].(string)

                userParams = append(userParams, platformclientv2.Userparam{
                        Key:   &amp;key,
                        Value: &amp;value,
                })</span>
        }

        <span class="cov0" title="0">return &amp;userParams</span>
}

func flattenUserParams(params *[]platformclientv2.Userparam) []interface{} <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">paramList := make([]interface{}, 0)

        for _, param := range *params </span><span class="cov0" title="0">{
                paramMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(paramMap, "key", param.Key)
                resourcedata.SetMapValueIfNotNil(paramMap, "value", param.Value)

                paramList = append(paramList, paramMap)
        }</span>

        <span class="cov0" title="0">return paramList</span>
}

func buildPolicyErrorMessages(messages []interface{}) *[]platformclientv2.Policyerrormessage <span class="cov0" title="0">{
        policyErrorMessages := make([]platformclientv2.Policyerrormessage, 0)

        for _, message := range messages </span><span class="cov0" title="0">{
                messageMap, ok := message.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">statusCode := messageMap["status_code"].(int)
                userMessage := messageMap["user_message"]
                userParamsMessage := messageMap["user_params_message"].(string)
                errorCode := messageMap["error_code"].(string)
                correlationId := messageMap["correlation_id"].(string)
                insertDateString := messageMap["insert_date"].(string)

                temp := platformclientv2.Policyerrormessage{
                        StatusCode:        &amp;statusCode,
                        UserMessage:       &amp;userMessage,
                        UserParamsMessage: &amp;userParamsMessage,
                        ErrorCode:         &amp;errorCode,
                        CorrelationId:     &amp;correlationId,
                        UserParams:        buildUserParams(messageMap["user_params"].([]interface{})),
                }

                insertDate, insertErr := time.Parse("2006-01-02T15:04:05-0700", insertDateString)
                if insertErr == nil </span><span class="cov0" title="0">{
                        temp.InsertDate = &amp;insertDate
                }</span>

                <span class="cov0" title="0">policyErrorMessages = append(policyErrorMessages, temp)</span>
        }

        <span class="cov0" title="0">return &amp;policyErrorMessages</span>
}

func flattenPolicyErrorMessages(errorMessages *[]platformclientv2.Policyerrormessage) []interface{} <span class="cov0" title="0">{
        if errorMessages == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">errorMessageList := make([]interface{}, 0)

        for _, errorMessage := range *errorMessages </span><span class="cov0" title="0">{
                errorMessageMap := make(map[string]interface{})

                resourcedata.SetMapValueIfNotNil(errorMessageMap, "status_code", errorMessage.StatusCode)
                resourcedata.SetMapValueIfNotNil(errorMessageMap, "user_message", errorMessage.UserMessage)
                resourcedata.SetMapValueIfNotNil(errorMessageMap, "user_params_message", errorMessage.UserParamsMessage)
                resourcedata.SetMapValueIfNotNil(errorMessageMap, "error_code", errorMessage.ErrorCode)
                resourcedata.SetMapValueIfNotNil(errorMessageMap, "correlation_id", errorMessage.CorrelationId)
                if errorMessage.InsertDate != nil &amp;&amp; len(errorMessage.InsertDate.String()) &gt; 0 </span><span class="cov0" title="0">{
                        temp := *errorMessage.InsertDate
                        errorMessageMap["insert_date"] = temp.String()
                }</span>
                <span class="cov0" title="0">resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(errorMessageMap, "user_params", errorMessage.UserParams, flattenUserParams)

                errorMessageList = append(errorMessageList, errorMessageMap)</span>
        }

        <span class="cov0" title="0">return errorMessageList</span>
}

func buildPolicyErrors(d *schema.ResourceData) *platformclientv2.Policyerrors <span class="cov0" title="0">{
        if errors, ok := d.GetOk("policy_errors"); ok </span><span class="cov0" title="0">{
                if errorsList, ok := errors.([]interface{}); ok || len(errorsList) &gt; 0 </span><span class="cov0" title="0">{
                        errorsMap, ok := errorsList[0].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return &amp;platformclientv2.Policyerrors{
                                PolicyErrorMessages: buildPolicyErrorMessages(errorsMap["policy_error_messages"].([]interface{})),
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func flattenPolicyErrors(policyErrors *platformclientv2.Policyerrors) []interface{} <span class="cov0" title="0">{
        if policyErrors == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">policyErrorsMap := make(map[string]interface{})

        resourcedata.SetMapInterfaceArrayWithFuncIfNotNil(policyErrorsMap, "policy_error_messages", policyErrors.PolicyErrorMessages, flattenPolicyErrorMessages)

        return []interface{}{policyErrorsMap}</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package resource_exporter

import (
        "context"
        "regexp"
        "strings"
        "sync"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
)

var resourceExporters map[string]*ResourceExporter
var resourceExporterMapMutex = sync.RWMutex{}

type ResourceMeta struct {
        // Name of the resource to be used in exports
        Name string

        // Prefix to add to the ID when reading state
        IdPrefix string
}

// resourceExporter.ResourceIDMetaMap is a map of IDs to ResourceMeta
type ResourceIDMetaMap map[string]*ResourceMeta

// GetAllResourcesFunc is a method that returns all resource IDs
type GetAllResourcesFunc func(context.Context) (ResourceIDMetaMap, diag.Diagnostics)

// RefAttrSettings contains behavior settings for references
type RefAttrSettings struct {

        // Referenced resource type
        RefType string

        // Values that may be set that should not be treated as IDs
        AltValues []string
}

// Allows the definition of a custom resolver for an exporter.
type RefAttrCustomResolver struct {
        ResolverFunc func(map[string]interface{}, map[string]*ResourceExporter) error
}

// Allows the definition of a custom resolver for an exporter.
type CustomFlowResolver struct {
        ResolverFunc func(map[string]interface{}, string) error
}

type CustomFileWriterSettings struct {
        // Custom function for dumping data/media stored in an object in a sub directory along
        // with the exported config. For example: prompt audio files, csv data, jps/pngs
        RetrieveAndWriteFilesFunc func(string, string, string, map[string]interface{}, interface{}) error

        // Sub directory within export folder in which to write files retrieved by RetrieveAndWriteFilesFunc
        // For example, the user_prompt resource defines SubDirectory as "audio", so the prompt audio files will
        // be written to genesyscloud_tf_export.directory/audio/
        // The logic for retrieving and writing data to this dir should be defined in RetrieveAndWriteFilesFunc
        SubDirectory string
}

type JsonEncodeRefAttr struct {
        // The outer key
        Attr string

        // The RefAttr nested inside the json data
        NestedAttr string
}

// ResourceExporter is an interface to implement for resources that can be exported
type ResourceExporter struct {

        // Method to load all resource IDs for a given resource.
        // Returned map key should be the ID and the value should be a name to use for the resource.
        // Names will be sanitized with part of the ID appended, so it is not required that they be unique
        GetResourcesFunc GetAllResourcesFunc

        // A map of resource attributes to types that they reference
        // Attributes in nested objects can be defined with a '.' separator
        RefAttrs map[string]*RefAttrSettings

        // AllowZeroValues is a list of attributes that should allow zero values in the export.
        // By default zero values are removed from the config due to lack of "null" support in the plugin SDK
        AllowZeroValues []string

        // Some of our dependencies can not be exported properly because they have interdependencies between attributes.  You can
        // define a map of custom attribute resolvers with an exporter.  See resource_genesyscloud_routing_queue for an example of how to define this.
        // NOTE: CustomAttributeResolvers should be the exception and not the norm so use them when you have to do logic that will help you
        // resolve to the write reference
        CustomAttributeResolver map[string]*RefAttrCustomResolver

        // RemoveIfMissing is a map of attributes to a list of inner object attributes.
        // When all specified inner attributes are missing from an object, that object is removed
        RemoveIfMissing map[string][]string

        // Map of resource id-&gt;names. This is set after a call to loadSanitizedResourceMap
        SanitizedResourceMap ResourceIDMetaMap

        // List of attributes to exclude from config. This is set by the export configuration.
        ExcludedAttributes []string

        // Map of attributes that cannot be resolved. E.g. edge Ids which are locked to an org or properties that cannot be retrieved from the API
        UnResolvableAttributes map[string]*schema.Schema

        // List of attributes which can and should be exported in a jsonencode object rather than as a long escaped string of JSON data.
        JsonEncodeAttributes []string

        // Attributes that are jsonencode objects, and that contain nested RefAttrs
        EncodedRefAttrs map[*JsonEncodeRefAttr]*RefAttrSettings

        CustomFileWriter CustomFileWriterSettings

        CustomFlowResolver map[string]*CustomFlowResolver

        //This a place holder filter out specific resources from a filter.
        FilterResource func(ResourceIDMetaMap, string, []string) ResourceIDMetaMap
        // Attributes that are e164 numbers and should be ensured to export in the correct format (remove hyphens, whitespace, etc.)
        E164Numbers []string
}

func (r *ResourceExporter) LoadSanitizedResourceMap(ctx context.Context, name string, filter []string) diag.Diagnostics <span class="cov0" title="0">{
        result, err := r.GetResourcesFunc(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if r.FilterResource != nil </span><span class="cov0" title="0">{
                result = r.FilterResource(result, name, filter)
        }</span>

        <span class="cov0" title="0">r.SanitizedResourceMap = result
        sanitizer := NewSanitizerProvider()
        sanitizer.S.Sanitize(r.SanitizedResourceMap)

        return nil</span>
}

func (r *ResourceExporter) GetRefAttrSettings(attribute string) *RefAttrSettings <span class="cov0" title="0">{
        if r.RefAttrs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.RefAttrs[attribute]</span>
}

func (r *ResourceExporter) GetNestedRefAttrSettings(attribute string) *RefAttrSettings <span class="cov0" title="0">{
        for key, val := range r.EncodedRefAttrs </span><span class="cov0" title="0">{
                if key.NestedAttr == attribute </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *ResourceExporter) ContainsNestedRefAttrs(attribute string) ([]string, bool) <span class="cov0" title="0">{
        var nestedAttributes []string
        for key, _ := range r.EncodedRefAttrs </span><span class="cov0" title="0">{
                if key.Attr == attribute </span><span class="cov0" title="0">{
                        nestedAttributes = append(nestedAttributes, key.NestedAttr)
                }</span>
        }
        <span class="cov0" title="0">return nestedAttributes, len(nestedAttributes) &gt; 0</span>
}

func (r *ResourceExporter) AllowForZeroValues(attribute string) bool <span class="cov0" title="0">{
        return lists.ItemInSlice(attribute, r.AllowZeroValues)
}</span>

func (r *ResourceExporter) IsJsonEncodable(attribute string) bool <span class="cov0" title="0">{
        return lists.ItemInSlice(attribute, r.JsonEncodeAttributes)
}</span>

func (r *ResourceExporter) IsAttributeE164(attribute string) bool <span class="cov0" title="0">{
        return lists.ItemInSlice(attribute, r.E164Numbers)
}</span>

func (r *ResourceExporter) AddExcludedAttribute(attribute string) <span class="cov0" title="0">{
        r.ExcludedAttributes = append(r.ExcludedAttributes, attribute)
}</span>

func (r *ResourceExporter) IsAttributeExcluded(attribute string) bool <span class="cov0" title="0">{
        for _, excluded := range r.ExcludedAttributes </span><span class="cov0" title="0">{
                // Excluded if attributes match, or the specified attribute is nested in the excluded attribute
                if excluded == attribute || strings.HasPrefix(attribute, excluded+".") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (r *ResourceExporter) RemoveFieldIfMissing(attribute string, config map[string]interface{}) bool <span class="cov0" title="0">{
        if attrs, ok := r.RemoveIfMissing[attribute]; ok </span><span class="cov0" title="0">{
                // Check if all required inner attributes are missing
                missingAll := true
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        if val, foundInner := config[attr]; foundInner &amp;&amp; val != nil </span><span class="cov0" title="0">{
                                missingAll = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">return missingAll</span>
        }
        <span class="cov0" title="0">return false</span>
}

func GetResourceExporters() map[string]*ResourceExporter <span class="cov0" title="0">{

        //Make a Copy of the Map
        exportCopy := make(map[string]*ResourceExporter, len(resourceExporters))

        for k, v := range resourceExporters </span><span class="cov0" title="0">{
                exportCopy[k] = v
        }</span>
        <span class="cov0" title="0">return exportCopy</span>
}

// terraform-provider-genesyscloud/genesyscloud/tfexporter
func GetAvailableExporterTypes() []string <span class="cov0" title="0">{
        exporters := GetResourceExporters()
        types := make([]string, len(exporters))
        i := 0
        for k := range exporters </span><span class="cov0" title="0">{
                types[i] = k
                i++
        }</span>
        <span class="cov0" title="0">return types</span>
}

func escapeRune(s string) string <span class="cov8" title="1">{
        // Always replace with an underscore for readability. The appended hash will help ensure uniqueness
        return "_"
}</span>

// Resource names must only contain alphanumeric chars, underscores, or dashes
// https://www.terraform.io/docs/language/syntax/configuration.html#identifiers
var unsafeNameChars = regexp.MustCompile(`[^0-9A-Za-z_-]`)

// Resource names must start with a letter or underscore
// https://www.terraform.io/docs/language/syntax/configuration.html#identifiers
var unsafeNameStartingChars = regexp.MustCompile(`[^A-Za-z_]`)

func RegisterExporter(exporterName string, resourceExporter *ResourceExporter) <span class="cov0" title="0">{
        resourceExporterMapMutex.Lock()
        defer resourceExporterMapMutex.Unlock()
        resourceExporters[exporterName] = resourceExporter
}</span>

func SetRegisterExporter(resources map[string]*ResourceExporter) <span class="cov0" title="0">{
        resourceExporterMapMutex.Lock()
        defer resourceExporterMapMutex.Unlock()
        resourceExporters = resources
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package resource_exporter

import (
        "encoding/json"
        "fmt"
        "strings"
)

/*
The resource_genesyscloud_routing_queue object has the concept of bullseye ring with a member_groups attribute.
The routing team has overloaded the meaning of the member_groups so you can id and then define what "type" of id this is.
This causes problems with the exporter because our export process expects id to map to a specific resource.

This customer custom router will look at the member_group_type and resolve whether it is SKILLGROUP, GROUP type.  It will then
find the appropriate resource out of the exporters and build a reference appropriately.
*/
func MemberGroupsResolver(configMap map[string]interface{}, exporters map[string]*ResourceExporter) error <span class="cov8" title="1">{

        memberGroupType := configMap["member_group_type"]
        memberGroupID := configMap["member_group_id"].(string)

        switch memberGroupType </span>{
        case "SKILLGROUP":<span class="cov8" title="1">
                if exporter, ok := exporters["genesyscloud_routing_skill_group"]; ok </span><span class="cov8" title="1">{
                        exportId := (*exporter.SanitizedResourceMap[memberGroupID]).Name
                        configMap["member_group_id"] = fmt.Sprintf("${genesyscloud_routing_skill_group.%s.id}", exportId)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("unable to locate genesyscloud_routing_skill_group in the exporters array. Unable to resolve the ID for the member group resource")
                }</span>

        case "GROUP":<span class="cov8" title="1">
                if exporter, ok := exporters["genesyscloud_group"]; ok </span><span class="cov8" title="1">{
                        exportId := (*exporter.SanitizedResourceMap[memberGroupID]).Name
                        configMap["member_group_id"] = fmt.Sprintf("${genesyscloud_group.%s.id}", exportId)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("unable to locate genesyscloud_group in the exporters array. Unable to resolve the ID for the member group resource")
                }</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("the memberGroupType %s cannot be located. Can not resolve to a reference attribute", memberGroupType)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

/*
For resource_genesyscloud_outbound_ruleset, there is a property called properties which is a map of stings.
When exporting outbound rulesets, if one of the keys in the map is set to an empty string it will be ignored
by the export process. Example: properties = {"contact.Attempts" = ""}.

During the export process the value associated with the key is set to nil.
This custom exporter checks if a key has a value of nil and if it does sets it to an empty string so it is exported.
*/
func RuleSetPropertyResolver(configMap map[string]interface{}, exporters map[string]*ResourceExporter) error <span class="cov0" title="0">{
        if properties, ok := configMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for key, value := range properties </span><span class="cov0" title="0">{
                        if value == nil </span><span class="cov0" title="0">{
                                properties[key] = ""
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

/*
This property takes a key 'skills' with an array of skill ids wrapped into a string (Example: {'skills': '['skillIdHere']'} ).
This causes problems with the exporter because our export process expects id to map to a specific resource
and we have an array of attributes wrapped in a string.

This customer custom router will look at the skills array if present and resolve each string id find the appropriate resource out of the exporters and build a reference appropriately.
*/
func RuleSetSkillPropertyResolver(configMap map[string]interface{}, exporters map[string]*ResourceExporter) error <span class="cov8" title="1">{

        if exporter, ok := exporters["genesyscloud_routing_skill"]; ok </span><span class="cov8" title="1">{
                skillIDs := configMap["skills"].(string)

                if len(skillIDs) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov8" title="1"> {
                        sanitisedSkillIds := []string{}
                        skillIDs = skillIDs[1 : len(skillIDs)-1]
                        skillIdList := strings.Split(skillIDs, ",")
                        exportId := ""

                        // Trim the double quotes from each element in the array
                        for i := 0; i &lt; len(skillIdList); i++ </span><span class="cov8" title="1">{
                                skillIdList[i] = strings.Trim(skillIdList[i], "\"")
                        }</span>

                        <span class="cov8" title="1">for _, skillId := range skillIdList </span><span class="cov8" title="1">{
                                exportId = (*exporter.SanitizedResourceMap[skillId]).Name
                                sanitisedSkillIds = append(sanitisedSkillIds, fmt.Sprintf("${genesyscloud_routing_skill.%s.id}", exportId))
                        }</span>

                        <span class="cov8" title="1">jsonData, _ := json.Marshal(sanitisedSkillIds)
                        configMap["skills"] = string(jsonData)</span>
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("unable to locate genesyscloud_routing_skill in the exporters array.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func FileContentHashResolver(configMap map[string]interface{}, filepath string) error <span class="cov0" title="0">{
        configMap["file_content_hash"] = fmt.Sprintf(`${filesha256(var.%s)}`, filepath)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package resource_exporter

import (
        "hash/fnv"
        "log"
        "os"
        "strconv"
)

type SanitizerProvider struct {
        S Sanitizer
}

type Sanitizer interface {
        Sanitize(idMetaMap ResourceIDMetaMap)
        SanitizeResourceName(inputName string) string
}

// Two different Sanitizer structs one with the original algorithmn
type sanitizerOriginal struct{}
type sanitizerOptimized struct{}

// NewSanitizierProvider returns a Sanitizer. Without a GENESYS_SANITIZER_OPTIMIZED environment variable set it will always use the original Sanitizer
func NewSanitizerProvider() *SanitizerProvider <span class="cov8" title="1">{
        // Check if the environment variable is set
        _, exists := os.LookupEnv("GENESYS_SANITIZER_OPTIMIZED")

        //If the
        if exists </span><span class="cov8" title="1">{
                log.Print("Using the optimized resource name sanitizer")
                return &amp;SanitizerProvider{
                        S: &amp;sanitizerOptimized{},
                }
        }</span>

        <span class="cov8" title="1">log.Print("Using the original resource name sanitizer")
        return &amp;SanitizerProvider{
                S: &amp;sanitizerOriginal{},
        }</span>
}

/**
        The next two functions are the original Sanitizer functions and is a bit heavier then Brian Goad's implementation.(DEVENGAGE-2891)
        The problem is that the PS team built some of their migration tools around the old names. Even though this is not a contract I am
    trying to be a good citizen and keep their apps running
*/

// Sanitize sanitizes all of the resource names using the original algorithm
func (so *sanitizerOriginal) Sanitize(idMetaMap ResourceIDMetaMap) <span class="cov0" title="0">{
        for _, meta := range idMetaMap </span><span class="cov0" title="0">{
                meta.Name = so.SanitizeResourceName(meta.Name)
        }</span>
}

// SanitizeResourceName sanitizes a single resource name using  the original resource name sanitizer
func (so *sanitizerOriginal) SanitizeResourceName(inputName string) string <span class="cov8" title="1">{
        name := unsafeNameChars.ReplaceAllStringFunc(inputName, escapeRune)
        if name != inputName </span><span class="cov8" title="1">{
                // Append a hash of the original name to ensure uniqueness for similar names
                // and that equivalent names are consistent across orgs
                algorithm := fnv.New32()
                algorithm.Write([]byte(inputName))
                name = name + "_" + strconv.FormatUint(uint64(algorithm.Sum32()), 10)
        }</span>
        <span class="cov8" title="1">if unsafeNameStartingChars.MatchString(string(rune(name[0]))) </span><span class="cov8" title="1">{
                // Terraform does not allow names to begin with a number. Prefix with an underscore instead
                name = "_" + name
        }</span>

        <span class="cov8" title="1">return name</span>
}

/**
  The next two functions are Brian Goad's (DEVENGAGE-2891) more optimized and easier to read resource names.
*/

// Santize sanitizes all resource name using the optimized algorithm
func (sod *sanitizerOptimized) Sanitize(idMetaMap ResourceIDMetaMap) <span class="cov8" title="1">{
        // Pull out all the original names of the resources for reference later
        originalResourceNames := make(map[string]string)
        for k, v := range idMetaMap </span><span class="cov8" title="1">{
                originalResourceNames[k] = v.Name
        }</span>

        // Iterate over the idMetaMap and sanitize the names of each resource
        <span class="cov8" title="1">for _, meta := range idMetaMap </span><span class="cov8" title="1">{

                sanitizedName := sod.SanitizeResourceName(meta.Name)

                // If there are more than one resource name that ends up with the same sanitized name,
                // append a hash of the original name to ensure uniqueness for names to prevent duplicates
                if sanitizedName != meta.Name </span><span class="cov8" title="1">{
                        numSeen := 0
                        for _, originalName := range originalResourceNames </span><span class="cov8" title="1">{
                                originalSanitizedName := sod.SanitizeResourceName(originalName)
                                if sanitizedName == originalSanitizedName </span><span class="cov8" title="1">{
                                        numSeen++
                                }</span>
                        }
                        <span class="cov8" title="1">if numSeen &gt; 1 </span><span class="cov8" title="1">{
                                algorithm := fnv.New32()
                                algorithm.Write([]byte(meta.Name))
                                sanitizedName = sanitizedName + "_" + strconv.FormatUint(uint64(algorithm.Sum32()), 10)
                        }</span>
                        <span class="cov8" title="1">meta.Name = sanitizedName</span>
                }
        }
}

// SanitizeResourceName sanitizes a single resource name
func (sod *sanitizerOptimized) SanitizeResourceName(inputName string) string <span class="cov8" title="1">{
        name := unsafeNameChars.ReplaceAllStringFunc(inputName, escapeRune)

        if unsafeNameStartingChars.MatchString(string(rune(name[0]))) </span><span class="cov8" title="1">{
                // Terraform does not allow names to begin with a number. Prefix with an underscore instead
                name = "_" + name
        }</span>

        <span class="cov8" title="1">return name</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package genesyscloud

import (
        "context"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceRoutingSmsAddressRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        smsAddressProxy := getRoutingSmsAddressProxy(sdkConfig)
        name := d.Get("name").(string)

        log.Printf("Searching for routing sms address with name '%s'", name)
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                smsAddressId, retryable, err := smsAddressProxy.getSmsAddressIdByName(name, ctx)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(err)
                }</span>
                <span class="cov0" title="0">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(err)
                }</span>
                <span class="cov0" title="0">d.SetId(smsAddressId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package genesyscloud

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// Type definitions for each func on our proxy so we can easily mock them out later
type createSmsAddressFunc func(p *routingSmsAddressProxy, body platformclientv2.Smsaddressprovision) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error)
type getAllSmsAddressesFunc func(p *routingSmsAddressProxy, ctx context.Context) (*[]platformclientv2.Smsaddress, error)
type getSmsAddressByIdFunc func(p *routingSmsAddressProxy, id string) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error)
type getSmsAddressIdByNameFunc func(p *routingSmsAddressProxy, name string, ctx context.Context) (id string, retryable bool, err error)
type deleteSmsAddressByIdFunc func(p *routingSmsAddressProxy, id string) (*platformclientv2.APIResponse, error)

// routingSmsAddressProxy contains all of the methods that call genesys cloud APIs.
type routingSmsAddressProxy struct {
        routingApi                *platformclientv2.RoutingApi
        createSmsAddressAttr      createSmsAddressFunc
        getAllSmsAddressesAttr    getAllSmsAddressesFunc
        getSmsAddressByIdAttr     getSmsAddressByIdFunc
        getSmsAddressIdByNameAttr getSmsAddressIdByNameFunc
        deleteSmsAddressByIdAttr  deleteSmsAddressByIdFunc
}

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *routingSmsAddressProxy

// newRoutingSmsAddressProxy initializes the sms address proxy with all of the data needed to communicate with Genesys Cloud
func newRoutingSmsAddressProxy(clientConfig *platformclientv2.Configuration) *routingSmsAddressProxy <span class="cov8" title="1">{
        api := platformclientv2.NewRoutingApiWithConfig(clientConfig)
        return &amp;routingSmsAddressProxy{
                routingApi:                api,
                createSmsAddressAttr:      createSmsAddressFn,
                getAllSmsAddressesAttr:    getAllSmsAddressesFn,
                getSmsAddressByIdAttr:     getSmsAddressByIdFn,
                getSmsAddressIdByNameAttr: getSmsAddressIdByNameFn,
                deleteSmsAddressByIdAttr:  deleteSmsAddressByIdFn,
        }
}</span>

// getRoutingSmsAddressProxy acts as a singleton for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getRoutingSmsAddressProxy(clientConfig *platformclientv2.Configuration) *routingSmsAddressProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newRoutingSmsAddressProxy(clientConfig)
        }</span>
        <span class="cov8" title="1">return internalProxy</span>
}

// createSmsAddress creates a Genesys Cloud Sms Address
func (p *routingSmsAddressProxy) createSmsAddress(body platformclientv2.Smsaddressprovision) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.createSmsAddressAttr(p, body)
}</span>

// getSmsAddressById gets a Genesys Cloud Sms Address by ID
func (p *routingSmsAddressProxy) getSmsAddressById(id string) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.getSmsAddressByIdAttr(p, id)
}</span>

// getSmsAddressIdByName gets a Genesys Cloud Sms Address ID by name
func (p *routingSmsAddressProxy) getSmsAddressIdByName(name string, ctx context.Context) (id string, retryable bool, err error) <span class="cov0" title="0">{
        return p.getSmsAddressIdByNameAttr(p, name, ctx)
}</span>

// getAllSmsAddresses gets all Genesys Cloud Sms Addresses
func (p *routingSmsAddressProxy) getAllSmsAddresses(ctx context.Context) (*[]platformclientv2.Smsaddress, error) <span class="cov0" title="0">{
        return p.getAllSmsAddressesAttr(p, ctx)
}</span>

// deleteSmsAddress deletes a Genesys Cloud Sms Address by ID
func (p *routingSmsAddressProxy) deleteSmsAddress(id string) (*platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.deleteSmsAddressByIdAttr(p, id)
}</span>

// createSmsAddressFn is an implementation function for creating a Genesys Cloud Sms Address
func createSmsAddressFn(p *routingSmsAddressProxy, body platformclientv2.Smsaddressprovision) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.routingApi.PostRoutingSmsAddresses(body)
}</span>

// getAllSmsAddressesFn is an implementation function for getting all Sms Addresses
func getAllSmsAddressesFn(p *routingSmsAddressProxy, ctx context.Context) (*[]platformclientv2.Smsaddress, error) <span class="cov0" title="0">{
        var allSmsAddresses []platformclientv2.Smsaddress
        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                smsAddresses, _, getErr := p.routingApi.GetRoutingSmsAddresses(pageSize, pageNum)
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error requesting page of Routing Sms Addresses: %s", getErr)
                }</span>
                <span class="cov0" title="0">if smsAddresses.Entities == nil || len(*smsAddresses.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for _, entity := range *smsAddresses.Entities </span><span class="cov0" title="0">{
                        allSmsAddresses = append(allSmsAddresses, entity)
                }</span>
        }
        <span class="cov0" title="0">return &amp;allSmsAddresses, nil</span>
}

// getSmsAddressByIdFn is an implementation function for getting a Genesys Cloud Sms Address by ID
func getSmsAddressByIdFn(p *routingSmsAddressProxy, id string) (*platformclientv2.Smsaddress, *platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.routingApi.GetRoutingSmsAddress(id)
}</span>

// getSmsAddressIdByNameFn is an implementation function for getting a sms address ID by name.
func getSmsAddressIdByNameFn(p *routingSmsAddressProxy, name string, ctx context.Context) (id string, retryable bool, err error) <span class="cov0" title="0">{
        smsAddresses, err := getAllSmsAddressesFn(p, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("failed to read sms addresses: %v", err)
        }</span>
        <span class="cov0" title="0">if smsAddresses == nil || len(*smsAddresses) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("failed to read sms addresses: %v", err)
        }</span>
        <span class="cov0" title="0">for _, address := range *smsAddresses </span><span class="cov0" title="0">{
                if *address.Name == name </span><span class="cov0" title="0">{
                        return *address.Id, false, nil
                }</span>
        }
        <span class="cov0" title="0">return "", true, fmt.Errorf("failed to find sms address with name '%s'", name)</span>
}

// deleteSmsAddressByIdFn is an implementation function for deleting a Genesys Cloud Sms Address by ID
func deleteSmsAddressByIdFn(p *routingSmsAddressProxy, id string) (*platformclientv2.APIResponse, error) <span class="cov0" title="0">{
        return p.routingApi.DeleteRoutingSmsAddress(id)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package genesyscloud

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// SetRegistrar registers all the resources, data sources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceRoutingSmsAddress())
        l.RegisterResource(resourceName, ResourceRoutingSmsAddress())
        l.RegisterExporter(resourceName, RoutingSmsAddressExporter())
}</span>

func RoutingSmsAddressExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllRoutingSmsAddress),
        }
}</span>

func ResourceRoutingSmsAddress() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud routing sms address`,

                CreateContext: gcloud.CreateWithPooledClient(createRoutingSmsAddress),
                ReadContext:   gcloud.ReadWithPooledClient(readRoutingSmsAddress),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteRoutingSmsAddress),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        `name`: {
                                Description: `Name associated with this address`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `street`: {
                                Description: `The number and street address where this address is located.`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `city`: {
                                Description: `The city in which this address is in`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `region`: {
                                Description: `The state or region this address is in`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `postal_code`: {
                                Description: `The postal code this address is in`,
                                Required:    true,
                                ForceNew:    true,
                                Type:        schema.TypeString,
                        },
                        `country_code`: {
                                Description:      `The ISO country code of this address`,
                                Required:         true,
                                ForceNew:         true,
                                Type:             schema.TypeString,
                                ValidateDiagFunc: gcloud.ValidateCountryCode,
                        },
                        `auto_correct_address`: {
                                Description: `This is used when the address is created. If the value is not set or true, then the system will, if necessary, auto-correct the address you provide. Set this value to false if the system should not auto-correct the address.`,
                                Optional:    true,
                                ForceNew:    true,
                                Type:        schema.TypeBool,
                        },
                },
        }
}</span>

func DataSourceRoutingSmsAddress() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Data source for Genesys Cloud Routing Sms Address. Select a Routing Sms Address by name.`,

                ReadContext: gcloud.ReadWithPooledClient(dataSourceRoutingSmsAddressRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `Routing Sms Address name.`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package genesyscloud

import (
        "context"
        "fmt"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

const resourceName = "genesyscloud_routing_sms_address"

func getAllRoutingSmsAddress(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        proxy := getRoutingSmsAddressProxy(clientConfig)

        allSmsAddresses, err := proxy.getAllSmsAddresses(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("failed to get sms addresses: %v", err)
        }</span>

        <span class="cov0" title="0">for _, entity := range *allSmsAddresses </span><span class="cov0" title="0">{
                var name string
                if entity.Name != nil </span><span class="cov0" title="0">{
                        name = *entity.Name
                }</span> else<span class="cov0" title="0"> {
                        name = *entity.Id
                }</span>
                <span class="cov0" title="0">resources[*entity.Id] = &amp;resourceExporter.ResourceMeta{Name: name}</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func createRoutingSmsAddress(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        name := d.Get("name").(string)
        street := d.Get("street").(string)
        city := d.Get("city").(string)
        region := d.Get("region").(string)
        postalCode := d.Get("postal_code").(string)
        countryCode := d.Get("country_code").(string)
        autoCorrectAddress := d.Get("auto_correct_address").(bool)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getRoutingSmsAddressProxy(sdkConfig)

        sdkSmsAddressProvision := platformclientv2.Smsaddressprovision{
                AutoCorrectAddress: &amp;autoCorrectAddress,
        }

        if name != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if street != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.Street = &amp;street
        }</span>
        <span class="cov8" title="1">if city != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.City = &amp;city
        }</span>
        <span class="cov8" title="1">if region != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.Region = &amp;region
        }</span>
        <span class="cov8" title="1">if postalCode != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.PostalCode = &amp;postalCode
        }</span>
        <span class="cov8" title="1">if countryCode != "" </span><span class="cov8" title="1">{
                sdkSmsAddressProvision.CountryCode = &amp;countryCode
        }</span>

        <span class="cov8" title="1">log.Printf("Creating Routing Sms Address %s", name)
        routingSmsAddress, _, err := proxy.createSmsAddress(sdkSmsAddressProvision)
        if err != nil </span><span class="cov8" title="1">{
                return diag.Errorf("Failed to create Routing Sms Addresse %s: %s", name, err)
        }</span>

        <span class="cov0" title="0">d.SetId(*routingSmsAddress.Id)

        log.Printf("Created Routing Sms Address %s %s", name, *routingSmsAddress.Id)
        return readRoutingSmsAddress(ctx, d, meta)</span>
}

func readRoutingSmsAddress(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getRoutingSmsAddressProxy(sdkConfig)

        log.Printf("Reading Routing Sms Address %s", d.Id())
        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                sdkSmsAddress, resp, getErr := proxy.getSmsAddressById(d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read Routing Sms Address %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read Routing Sms Address %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceRoutingSmsAddress())

                resourcedata.SetNillableValue(d, "name", sdkSmsAddress.Name)
                resourcedata.SetNillableValue(d, "street", sdkSmsAddress.Street)
                resourcedata.SetNillableValue(d, "city", sdkSmsAddress.City)
                resourcedata.SetNillableValue(d, "region", sdkSmsAddress.Region)
                resourcedata.SetNillableValue(d, "postal_code", sdkSmsAddress.PostalCode)
                resourcedata.SetNillableValue(d, "country_code", sdkSmsAddress.CountryCode)

                log.Printf("Read Routing Sms Address %s", d.Id())
                return cc.CheckState()</span>
        })
}

func deleteRoutingSmsAddress(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getRoutingSmsAddressProxy(sdkConfig)

        // AD-123 is the ID for a default address returned to all test orgs, it can't be deleted
        if d.Id() == "AD-123" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov0" title="0">{
                log.Printf("Deleting Routing Sms Address")
                resp, err := proxy.deleteSmsAddress(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to delete Routing Sms Address: %s", err)
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        })
        <span class="cov0" title="0">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, resp, err := proxy.getSmsAddressById(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                // Routing Sms Address deleted
                                log.Printf("Deleted Routing Sms Address %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting Routing Sms Address %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("Routing Sms Address %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package scripts

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
DataSource for the Scripts resource
*/

// dataSourceScriptRead provides the main terraform code needed to read a script resource by name
func dataSourceScriptRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        scriptsProxy := getScriptsProxy(sdkConfig)

        name := d.Get("name").(string)

        // Query for scripts by name. Retry in case new script is not yet indexed by search.
        // As script names are non-unique, fail in case of multiple results.
        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                scripts, err := scriptsProxy.getPublishedScriptsByName(ctx, name)

                if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error requesting script %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if len(*scripts) == 0 </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("No scripts found with name %s", name))
                }</span>

                <span class="cov8" title="1">if len(*scripts) &gt; 1 </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Ambiguous script name: %s", name))
                }</span>

                <span class="cov8" title="1">script := (*scripts)[0]
                d.SetId(*script.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package scripts

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"
        files "terraform-provider-genesyscloud/genesyscloud/util/files"
        "time"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_scripts_proxy.go file contains all of the logic associated with calling the Genesys cloud API for scripts.
*/
var internalProxy *scriptsProxy

type getAllPublishedScriptsFunc func(ctx context.Context, p *scriptsProxy) (*[]platformclientv2.Script, error)
type publishScriptFunc func(ctx context.Context, p *scriptsProxy, scriptId string) error
type getScriptByNameFunc func(ctx context.Context, p *scriptsProxy, scriptName string) ([]platformclientv2.Script, error)
type verifyScriptUploadSuccessFunc func(ctx context.Context, p *scriptsProxy, body []byte) (bool, error)
type scriptWasUploadedSuccessfullyFunc func(ctx context.Context, p *scriptsProxy, uploadId string) (bool, error)
type getScriptExportUrlFunc func(ctx context.Context, p *scriptsProxy, scriptId string) (string, error)
type deleteScriptFunc func(ctx context.Context, p *scriptsProxy, scriptId string) error
type getScriptByIdFunc func(ctx context.Context, p *scriptsProxy, scriptId string) (script *platformclientv2.Script, statusCode int, err error)
type getPublishedScriptsByNameFunc func(ctx context.Context, p *scriptsProxy, name string) (*[]platformclientv2.Script, error)

// scriptsProxy contains all of the method used to interact with the Genesys Scripts SDK
type scriptsProxy struct {
        clientConfig                      *platformclientv2.Configuration
        scriptsApi                        *platformclientv2.ScriptsApi
        basePath                          string
        accessToken                       string
        getAllScriptsAttr                 getAllPublishedScriptsFunc
        publishScriptAttr                 publishScriptFunc
        getScriptByNameAttr               getScriptByNameFunc
        verifyScriptUploadSuccessAttr     verifyScriptUploadSuccessFunc
        scriptWasUploadedSuccessfullyAttr scriptWasUploadedSuccessfullyFunc
        getScriptExportUrlAttr            getScriptExportUrlFunc
        deleteScriptAttr                  deleteScriptFunc
        getScriptByIdAttr                 getScriptByIdFunc
        getPublishedScriptsByNameAttr     getPublishedScriptsByNameFunc
}

// getScriptsProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getScriptsProxy(clientConfig *platformclientv2.Configuration) *scriptsProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newscriptsProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// newscriptsProxy initializes the Scripts proxy with all of the data needed to communicate with Genesys Cloud
func newscriptsProxy(clientConfig *platformclientv2.Configuration) *scriptsProxy <span class="cov8" title="1">{
        scriptsAPI := platformclientv2.NewScriptsApiWithConfig(clientConfig)
        return &amp;scriptsProxy{
                clientConfig:                      clientConfig,
                scriptsApi:                        scriptsAPI,
                basePath:                          strings.Replace(scriptsAPI.Configuration.BasePath, "api", "apps", -1),
                accessToken:                       scriptsAPI.Configuration.AccessToken,
                getAllScriptsAttr:                 getAllPublishedScriptsFn,
                publishScriptAttr:                 publishScriptFn,
                getScriptByNameAttr:               getScriptsByNameFn,
                verifyScriptUploadSuccessAttr:     verifyScriptUploadSuccessFn,
                scriptWasUploadedSuccessfullyAttr: scriptWasUploadedSuccessfullyFn,
                getScriptExportUrlAttr:            getScriptExportUrlFn,
                deleteScriptAttr:                  deleteScriptFn,
                getScriptByIdAttr:                 getScriptByIdFn,
                getPublishedScriptsByNameAttr:     getPublishedScriptsByNameFn,
        }
}</span>

func (p *scriptsProxy) getAllPublishedScripts(ctx context.Context) (*[]platformclientv2.Script, error) <span class="cov0" title="0">{
        return p.getAllScriptsAttr(ctx, p)
}</span>

func (p *scriptsProxy) publishScript(ctx context.Context, scriptId string) error <span class="cov8" title="1">{
        return p.publishScriptAttr(ctx, p, scriptId)
}</span>

func (p *scriptsProxy) getScriptByName(ctx context.Context, scriptName string) ([]platformclientv2.Script, error) <span class="cov8" title="1">{
        return p.getScriptByNameAttr(ctx, p, scriptName)
}</span>

func (p *scriptsProxy) verifyScriptUploadSuccess(ctx context.Context, body []byte) (bool, error) <span class="cov8" title="1">{
        return p.verifyScriptUploadSuccessAttr(ctx, p, body)
}</span>

func (p *scriptsProxy) scriptWasUploadedSuccessfully(ctx context.Context, uploadId string) (bool, error) <span class="cov8" title="1">{
        return p.scriptWasUploadedSuccessfullyAttr(ctx, p, uploadId)
}</span>

func (p *scriptsProxy) getScriptExportUrl(ctx context.Context, scriptId string) (string, error) <span class="cov0" title="0">{
        return p.getScriptExportUrlAttr(ctx, p, scriptId)
}</span>

func (p *scriptsProxy) deleteScript(ctx context.Context, scriptId string) error <span class="cov8" title="1">{
        return p.deleteScriptAttr(ctx, p, scriptId)
}</span>

func (p *scriptsProxy) getScriptById(ctx context.Context, scriptId string) (script *platformclientv2.Script, statusCode int, err error) <span class="cov8" title="1">{
        return p.getScriptByIdAttr(ctx, p, scriptId)
}</span>

func (p *scriptsProxy) getPublishedScriptsByName(ctx context.Context, name string) (*[]platformclientv2.Script, error) <span class="cov8" title="1">{
        return p.getPublishedScriptsByNameAttr(ctx, p, name)
}</span>

// publishScriptFn will publish the script after it has been successfully upload
func publishScriptFn(ctx context.Context, p *scriptsProxy, scriptId string) error <span class="cov8" title="1">{
        publishScriptBody := &amp;platformclientv2.Publishscriptrequestdata{
                ScriptId: &amp;scriptId,
        }

        if _, _, err := p.scriptsApi.PostScriptsPublished("0", *publishScriptBody); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getAllPublishedScriptsFn returns all published scripts within a Genesys Cloud instance
func getAllPublishedScriptsFn(ctx context.Context, p *scriptsProxy) (*[]platformclientv2.Script, error) <span class="cov0" title="0">{
        var allScripts []platformclientv2.Script
        pageSize := 50
        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                scripts, _, err := p.scriptsApi.GetScripts(pageSize, pageNum, "", "", "", "", "", "", "", "")

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if scripts.Entities == nil || len(*scripts.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, script := range *scripts.Entities </span><span class="cov0" title="0">{
                        _, resp, err := p.scriptsApi.GetScriptsPublishedScriptId(*script.Id, "")

                        //If the item is not found this indicates it is not published
                        if resp.StatusCode == http.StatusNotFound &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                log.Printf("Script id %s, script %s name is not published and will not be returned for export", *script.Id, *script.Name)
                                continue</span>
                        }

                        //Some APIs will return an error code even if the response code is a 404.
                        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound &amp;&amp; err != nil </span><span class="cov0" title="0">{
                                log.Printf("Script id %s, script %s name is not published and will not be returned for export.  Also an err was returned on call %s", *script.Id, *script.Name, err)
                                continue</span>
                        }

                        //All other errors should be failed
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to retrieve publication status for script id %s.  Err: %v", *script.Id, err)
                        }</span>

                        <span class="cov0" title="0">allScripts = append(allScripts, script)</span>
                }
        }

        <span class="cov0" title="0">return &amp;allScripts, nil</span>
}

// getScriptsByNameFn Retrieves all scripts instances that matrch the name passed in
func getScriptsByNameFn(ctx context.Context, p *scriptsProxy, scriptName string) ([]platformclientv2.Script, error) <span class="cov8" title="1">{
        var scripts []platformclientv2.Script

        log.Printf("Retrieving scripts with name '%s'", scriptName)
        pageSize := 50
        for i := 0; ; i++ </span><span class="cov8" title="1">{
                pageNumber := i + 1
                data, _, err := p.scriptsApi.GetScripts(pageSize, pageNumber, "", scriptName, "", "", "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return scripts, err
                }</span>

                <span class="cov8" title="1">if data.Entities == nil || len(*data.Entities) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">for _, script := range *data.Entities </span><span class="cov8" title="1">{
                        if *script.Name == scriptName </span><span class="cov8" title="1">{
                                scripts = append(scripts, script)
                        }</span>
                }
        }

        <span class="cov8" title="1">return scripts, nil</span>
}

// createScriptFormData creates the form data attributes to create a script in Genesys Cloud
func (p *scriptsProxy) createScriptFormData(filePath, scriptName string) (map[string]io.Reader, error) <span class="cov8" title="1">{
        fileReader, _, err := files.DownloadOrOpenFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">formData := make(map[string]io.Reader, 0)
        formData["file"] = fileReader
        formData["scriptName"] = strings.NewReader(scriptName)
        return formData, nil</span>
}

// uploadScriptFile uploads a script file to S3
func (p *scriptsProxy) uploadScriptFile(filePath string, scriptName string, substitutions map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        formData, err := p.createScriptFormData(filePath, scriptName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">headers := make(map[string]string, 0)
        headers["Authorization"] = "Bearer " + p.accessToken

        s3Uploader := files.NewS3Uploader(nil, formData, substitutions, headers, "POST", p.basePath+"/uploads/v2/scripter")
        resp, err := s3Uploader.Upload()
        return resp, err</span>
}

// verifyScriptFileFn checks to see if a file has successfully uploaded
func verifyScriptUploadSuccessFn(ctx context.Context, p *scriptsProxy, body []byte) (bool, error) <span class="cov8" title="1">{
        uploadId := p.getUploadIdFromBody(body)

        maxRetries := 3
        for i := 1; i &lt; maxRetries; i++ </span><span class="cov8" title="1">{
                time.Sleep(2 * time.Second)
                isUploadSuccess, err := p.scriptWasUploadedSuccessfully(ctx, uploadId)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if isUploadSuccess </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov0" title="0"> if i == maxRetries </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// getUploadIdFromBody retrieves the upload Id from the json file being uploade
func (p *scriptsProxy) getUploadIdFromBody(body []byte) string <span class="cov8" title="1">{
        var (
                jsonData interface{}
                uploadId string
        )

        json.Unmarshal(body, &amp;jsonData)

        if jsonMap, ok := jsonData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                uploadId = jsonMap["correlationId"].(string)
        }</span>

        <span class="cov8" title="1">return uploadId</span>
}

// scriptWasUploadedSuccessfullyFn checks the Genesys Cloud API to see if the script was successfully uploaded
func scriptWasUploadedSuccessfullyFn(ctx context.Context, p *scriptsProxy, uploadId string) (bool, error) <span class="cov8" title="1">{

        data, resp, err := p.scriptsApi.GetScriptsUploadStatus(uploadId, false)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error calling GetScriptsUploadStatus: %v", resp.Status)
        }</span>

        <span class="cov8" title="1">return *data.Succeeded, nil</span>
}

// getScriptExportUrlFn retrieves the export URL for a targeted script
func getScriptExportUrlFn(ctx context.Context, p *scriptsProxy, scriptId string) (string, error) <span class="cov0" title="0">{
        var (
                body platformclientv2.Exportscriptrequest
        )

        data, resp, err := p.scriptsApi.PostScriptExport(scriptId, body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error calling PostScriptExport: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error calling PostScriptExport: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">return *data.Url, nil</span>
}

// deleteScriptFn deletes a script from Genesys Cloud
func deleteScriptFn(ctx context.Context, p *scriptsProxy, scriptId string) error <span class="cov8" title="1">{
        fullPath := p.scriptsApi.Configuration.BasePath + "/api/v2/scripts/" + scriptId
        r, _ := http.NewRequest(http.MethodDelete, fullPath, nil)
        r.Header.Set("Authorization", "Bearer "+p.scriptsApi.Configuration.AccessToken)
        r.Header.Set("Content-Type", "application/json")

        log.Printf("Deleting script %s", scriptId)
        client := &amp;http.Client{}
        resp, err := client.Do(r)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{

                return fmt.Errorf("failed to delete script %s: %s", scriptId, resp.Status)
        }</span>

        <span class="cov8" title="1">log.Printf("Successfully deleted script %s", scriptId)
        return nil</span>
}

// getScriptByIdFn  retrieves a script by Id
func getScriptByIdFn(ctx context.Context, p *scriptsProxy, scriptId string) (script *platformclientv2.Script, statusCode int, err error) <span class="cov8" title="1">{
        script, resp, err := p.scriptsApi.GetScript(scriptId)

        if err != nil </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, resp.StatusCode, nil
                }</span>
                <span class="cov0" title="0">return nil, 0, err</span>
        }

        <span class="cov8" title="1">return script, 0, nil</span>
}

// getsPublishedScriptsByNameFn returns all of the published scripts that match a name.  Note:  Genesys Cloud allows two script to have the same name and published so we have to return all of the published scripts and let the consumer sort it out.
func getPublishedScriptsByNameFn(ctx context.Context, p *scriptsProxy, name string) (*[]platformclientv2.Script, error) <span class="cov8" title="1">{
        const pageSize = 100
        var allPublishedScripts []platformclientv2.Script

        for i := 0; ; i++ </span><span class="cov8" title="1">{
                pageNumber := i + 1
                data, _, err := p.scriptsApi.GetScriptsPublished(pageSize, pageNumber, "", name, "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if data.Entities == nil || len(*data.Entities) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">for _, script := range *data.Entities </span><span class="cov8" title="1">{
                        if *script.Name == name </span><span class="cov8" title="1">{
                                allPublishedScripts = append(allPublishedScripts, script)
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;allPublishedScripts, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package scripts

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "path"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        files "terraform-provider-genesyscloud/genesyscloud/util/files"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// createScript providers the Terraform resource logic for creating a Script object
func createScript(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        scriptsProxy := getScriptsProxy(sdkConfig)

        filePath := d.Get("filepath").(string)
        scriptName := d.Get("script_name").(string)
        substitutions := d.Get("substitutions").(map[string]interface{})

        log.Printf("Creating script %s", scriptName)
        exists, err := scriptExistsWithName(ctx, scriptsProxy, scriptName)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("%v", err)
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return diag.Errorf("Script with name '%s' already exists. Please provide a unique name.", scriptName)
        }</span>

        <span class="cov8" title="1">resp, err := scriptsProxy.uploadScriptFile(filePath, scriptName, substitutions)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("%v", err)
        }</span>

        <span class="cov8" title="1">success, err := scriptsProxy.verifyScriptUploadSuccess(ctx, resp)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("%v", err)
        }</span> else<span class="cov8" title="1"> if !success </span><span class="cov0" title="0">{
                return diag.Errorf("Script '%s' failed to upload successfully.", scriptName)
        }</span>

        // Retrieve script ID using getScriptByName function
        <span class="cov8" title="1">sdkScripts, err := scriptsProxy.getScriptByName(ctx, scriptName)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("%v", err)
        }</span>
        <span class="cov8" title="1">if len(sdkScripts) &gt; 1 </span><span class="cov0" title="0">{
                return diag.Errorf("More than one script found with name %s", scriptName)
        }</span>
        <span class="cov8" title="1">if len(sdkScripts) == 0 </span><span class="cov0" title="0">{
                return diag.Errorf("Script %s not found after creation.", scriptName)
        }</span>

        <span class="cov8" title="1">scriptId := *sdkScripts[0].Id
        if err := scriptsProxy.publishScript(ctx, scriptId); err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("script %s with id id %s was not successfully published due to %s", scriptName, scriptId, err)
        }</span>

        <span class="cov8" title="1">d.SetId(scriptId)

        log.Printf("Created script %s. ", d.Id())
        return readScript(ctx, d, meta)</span>
}

// readScript contains all of the logic needed to read resource data from Genesys Cloud
func readScript(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        scriptsProxy := getScriptsProxy(sdkConfig)

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                script, statusCode, err := scriptsProxy.getScriptById(ctx, d.Id())
                if statusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("Failed to read flow %s: %s", d.Id(), err))
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Failed to read flow %s: %s", d.Id(), err))
                }</span>

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceScript())

                if script.Name != nil </span><span class="cov8" title="1">{
                        d.Set("script_name", *script.Name)
                }</span>

                <span class="cov8" title="1">log.Printf("Read script %s %s", d.Id(), *script.Name)
                return cc.CheckState()</span>
        })
}

// deleteScript contains all of the logic needed to delete a resource from Genesys Cloud
func deleteScript(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        scriptsProxy := getScriptsProxy(sdkConfig)

        scriptId := d.Id()
        err := scriptsProxy.deleteScript(ctx, scriptId)

        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to delete script %s: %s", d.Id(), err)
        }</span>
        <span class="cov8" title="1">log.Printf("Successfully deleted script %s", d.Id())
        return nil</span>
}

// scriptExistsWithName is a helper method to determine if a script already exists with the name the user is trying create a script with
func scriptExistsWithName(ctx context.Context, scriptsProxy *scriptsProxy, scriptName string) (bool, error) <span class="cov8" title="1">{
        sdkScripts, err := scriptsProxy.getScriptByName(ctx, scriptName)
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov8" title="1">if len(sdkScripts) &lt; 1 </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// getAllScripts returns all of the published scripts
func getAllScripts(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        scriptsProxy := getScriptsProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        scripts, err := scriptsProxy.getAllPublishedScripts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return resources, diag.Errorf("Failed to get page of scripts: %v", err)
        }</span>

        <span class="cov0" title="0">for _, script := range *scripts </span><span class="cov0" title="0">{
                resources[*script.Id] = &amp;resourceExporter.ResourceMeta{Name: *script.Name}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// ScriptResolver is used to download all Genesys Cloud scripts from Genesys Cloud
func ScriptResolver(scriptId, exportDirectory, subDirectory string, configMap map[string]interface{}, meta interface{}) error <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        scriptsProxy := getScriptsProxy(sdkConfig)

        exportFileName := fmt.Sprintf("script-%s.json", scriptId)

        fullPath := path.Join(exportDirectory, subDirectory)
        if err := os.MkdirAll(fullPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ctx := context.Background()
        url, err := scriptsProxy.getScriptExportUrl(ctx, scriptId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := files.DownloadExportFile(fullPath, exportFileName, url); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update filepath field in configMap to point to exported script file
        <span class="cov0" title="0">configMap["filepath"] = path.Join(subDirectory, exportFileName)
        configMap["file_content_hash"] = fmt.Sprintf(`${filesha256("%s")}`, path.Join(subDirectory, exportFileName))

        return err</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package scripts

import (
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

/*
Defines the resource schema, the datasource, and the exporters for the scripts package
*/
const resourceName = "genesyscloud_script"

// SetRegistrar registers all of the resources, datasources and exporters in the packagee
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceScript())
        l.RegisterResource(resourceName, ResourceScript())
        l.RegisterExporter(resourceName, ExporterScript())
}</span>

// DataSourceScript() returns the data source schema definition
func DataSourceScript() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Scripts. Select a script by name.  This will only search on published scripts.  Unpublished scripts will not be returned",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceScriptRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Script name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>

// ResourceScript returns the resource script definitions
func ResourceScript() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Genesys Cloud Script",

                CreateContext: gcloud.CreateWithPooledClient(createScript),
                ReadContext:   gcloud.ReadWithPooledClient(readScript),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteScript),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "script_name": {
                                Description: "Display name for the script. A reliably unique name is recommended.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "filepath": {
                                Description:  "Path to the script file to upload.",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: gcloud.ValidatePath,
                                ForceNew:     true,
                        },
                        "file_content_hash": {
                                Description: "Hash value of the script file content. Used to detect changes.",
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                        },
                        "substitutions": {
                                Description: "A substitution is a key value pair where the key is the value you want to replace, and the value is the value to substitute in its place.",
                                Type:        schema.TypeMap,
                                Optional:    true,
                                ForceNew:    true,
                        },
                },
        }
}</span>

// ExporterScript returns all of the exporter configuration for this resource
func ExporterScript() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllScripts),
                RefAttrs:         map[string]*resourceExporter.RefAttrSettings{},
                CustomFileWriter: resourceExporter.CustomFileWriterSettings{
                        RetrieveAndWriteFilesFunc: ScriptResolver,
                        SubDirectory:              "scripts",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package station

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceStationRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        sp := getStationProxy(sdkConfig)

        stationName := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                stationId, retryable, err := sp.getStationIdByName(ctx, stationName)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting station %s", err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no stations found"))
                }</span>

                <span class="cov8" title="1">d.SetId(stationId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package station

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *stationProxy

type getStationIdByNameFunc func(ctx context.Context, p *stationProxy, stationName string) (stationId string, retryable bool, err error)

// stationProxy contains all of the methods that call genesys cloud APIs.
type stationProxy struct {
        clientConfig           *platformclientv2.Configuration
        stationsApi            *platformclientv2.StationsApi
        getStationIdByNameAttr getStationIdByNameFunc
}

// newStationProxy initializes the Station proxy with all of the data needed to communicate with Genesys Cloud
func newStationProxy(clientConfig *platformclientv2.Configuration) *stationProxy <span class="cov8" title="1">{
        stationsApi := platformclientv2.NewStationsApiWithConfig(clientConfig)

        return &amp;stationProxy{
                clientConfig:           clientConfig,
                stationsApi:            stationsApi,
                getStationIdByNameAttr: getStationIdByNameFn,
        }
}</span>

// getStationProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getStationProxy(clientConfig *platformclientv2.Configuration) *stationProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newStationProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getStationIdByName retrieves a Genesys Cloud Station ID by Name
func (p *stationProxy) getStationIdByName(ctx context.Context, stationName string) (stationId string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getStationIdByNameAttr(ctx, p, stationName)
}</span>

// getStationIdByNameFn is an implementation function for retrieving a Station Id by Name
func getStationIdByNameFn(ctx context.Context, p *stationProxy, stationName string) (stationId string, retryable bool, err error) <span class="cov8" title="1">{
        const pageSize = 100
        stations, _, err := p.stationsApi.GetStations(pageSize, 1, "", stationName, "", "", "", "")
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov8" title="1">if stations.Entities == nil || len(*stations.Entities) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("failed to find ID of station '%s'", stationName)
        }</span>

        <span class="cov8" title="1">for _, station := range *stations.Entities </span><span class="cov8" title="1">{
                if *station.Name == stationName </span><span class="cov8" title="1">{
                        return *station.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *stations.PageCount; pageNum++ </span><span class="cov0" title="0">{
                stations, _, err := p.stationsApi.GetStations(pageSize, pageNum, "", stationName, "", "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return "", false, err
                }</span>
                <span class="cov0" title="0">if stations.Entities == nil </span><span class="cov0" title="0">{
                        return "", true, fmt.Errorf("failed to find ID of station '%s'", stationName)
                }</span>

                <span class="cov0" title="0">for _, station := range *stations.Entities </span><span class="cov0" title="0">{
                        if *station.Name == stationName </span><span class="cov0" title="0">{
                                return *station.Id, false, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("failed to find ID of station '%s'", stationName)</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package station

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

const resourceName = "genesyscloud_station"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceStation())
}</span>

// DataSourceStation registers the genesyscloud_station data source
func DataSourceStation() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Stations. Select a station by name.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceStationRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Station name.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package task_management_workbin

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_task_management_workbin.go contains the data source implementation
   for the resource.
*/

// dataSourceTaskManagementWorkbinRead retrieves by name the id in question
func dataSourceTaskManagementWorkbinRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newTaskManagementWorkbinProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                workbinId, retryable, err := proxy.getTaskManagementWorkbinIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error searching task management workbin %s: %s", name, err))
                }</span>

                <span class="cov0" title="0">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no task management workbin found with name %s", name))
                }</span>

                <span class="cov0" title="0">d.SetId(workbinId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package task_management_workbin

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_task_management_workbin_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *taskManagementWorkbinProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createTaskManagementWorkbinFunc func(ctx context.Context, p *taskManagementWorkbinProxy, workbin *platformclientv2.Workbincreate) (*platformclientv2.Workbin, error)
type getAllTaskManagementWorkbinFunc func(ctx context.Context, p *taskManagementWorkbinProxy) (*[]platformclientv2.Workbin, error)
type getTaskManagementWorkbinIdByNameFunc func(ctx context.Context, p *taskManagementWorkbinProxy, name string) (id string, retryable bool, err error)
type getTaskManagementWorkbinByIdFunc func(ctx context.Context, p *taskManagementWorkbinProxy, id string) (workbin *platformclientv2.Workbin, responseCode int, err error)
type updateTaskManagementWorkbinFunc func(ctx context.Context, p *taskManagementWorkbinProxy, id string, workbin *platformclientv2.Workbinupdate) (*platformclientv2.Workbin, error)
type deleteTaskManagementWorkbinFunc func(ctx context.Context, p *taskManagementWorkbinProxy, id string) (responseCode int, err error)

// taskManagementWorkbinProxy contains all of the methods that call genesys cloud APIs.
type taskManagementWorkbinProxy struct {
        clientConfig                         *platformclientv2.Configuration
        taskManagementApi                    *platformclientv2.TaskManagementApi
        createTaskManagementWorkbinAttr      createTaskManagementWorkbinFunc
        getAllTaskManagementWorkbinAttr      getAllTaskManagementWorkbinFunc
        getTaskManagementWorkbinIdByNameAttr getTaskManagementWorkbinIdByNameFunc
        getTaskManagementWorkbinByIdAttr     getTaskManagementWorkbinByIdFunc
        updateTaskManagementWorkbinAttr      updateTaskManagementWorkbinFunc
        deleteTaskManagementWorkbinAttr      deleteTaskManagementWorkbinFunc
}

// newTaskManagementWorkbinProxy initializes the task management workbin proxy with all of the data needed to communicate with Genesys Cloud
func newTaskManagementWorkbinProxy(clientConfig *platformclientv2.Configuration) *taskManagementWorkbinProxy <span class="cov8" title="1">{
        api := platformclientv2.NewTaskManagementApiWithConfig(clientConfig)
        return &amp;taskManagementWorkbinProxy{
                clientConfig:                         clientConfig,
                taskManagementApi:                    api,
                createTaskManagementWorkbinAttr:      createTaskManagementWorkbinFn,
                getAllTaskManagementWorkbinAttr:      getAllTaskManagementWorkbinFn,
                getTaskManagementWorkbinIdByNameAttr: getTaskManagementWorkbinIdByNameFn,
                getTaskManagementWorkbinByIdAttr:     getTaskManagementWorkbinByIdFn,
                updateTaskManagementWorkbinAttr:      updateTaskManagementWorkbinFn,
                deleteTaskManagementWorkbinAttr:      deleteTaskManagementWorkbinFn,
        }
}</span>

// getTaskManagementWorkbinProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getTaskManagementWorkbinProxy(clientConfig *platformclientv2.Configuration) *taskManagementWorkbinProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newTaskManagementWorkbinProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// createTaskManagementWorkbin creates a Genesys Cloud task management workbin
func (p *taskManagementWorkbinProxy) createTaskManagementWorkbin(ctx context.Context, taskManagementWorkbin *platformclientv2.Workbincreate) (*platformclientv2.Workbin, error) <span class="cov8" title="1">{
        return p.createTaskManagementWorkbinAttr(ctx, p, taskManagementWorkbin)
}</span>

// getTaskManagementWorkbin retrieves all Genesys Cloud task management workbin
func (p *taskManagementWorkbinProxy) getAllTaskManagementWorkbin(ctx context.Context) (*[]platformclientv2.Workbin, error) <span class="cov0" title="0">{
        return p.getAllTaskManagementWorkbinAttr(ctx, p)
}</span>

// getTaskManagementWorkbinIdByName returns a single Genesys Cloud task management workbin by a name
func (p *taskManagementWorkbinProxy) getTaskManagementWorkbinIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov0" title="0">{
        return p.getTaskManagementWorkbinIdByNameAttr(ctx, p, name)
}</span>

// getTaskManagementWorkbinById returns a single Genesys Cloud task management workbin by Id
func (p *taskManagementWorkbinProxy) getTaskManagementWorkbinById(ctx context.Context, id string) (taskManagementWorkbin *platformclientv2.Workbin, statusCode int, err error) <span class="cov0" title="0">{
        return p.getTaskManagementWorkbinByIdAttr(ctx, p, id)
}</span>

// updateTaskManagementWorkbin updates a Genesys Cloud task management workbin
func (p *taskManagementWorkbinProxy) updateTaskManagementWorkbin(ctx context.Context, id string, taskManagementWorkbin *platformclientv2.Workbinupdate) (*platformclientv2.Workbin, error) <span class="cov0" title="0">{
        return p.updateTaskManagementWorkbinAttr(ctx, p, id, taskManagementWorkbin)
}</span>

// deleteTaskManagementWorkbin deletes a Genesys Cloud task management workbin by Id
func (p *taskManagementWorkbinProxy) deleteTaskManagementWorkbin(ctx context.Context, id string) (statusCode int, err error) <span class="cov0" title="0">{
        return p.deleteTaskManagementWorkbinAttr(ctx, p, id)
}</span>

// createTaskManagementWorkbinFn is an implementation function for creating a Genesys Cloud task management workbin
func createTaskManagementWorkbinFn(ctx context.Context, p *taskManagementWorkbinProxy, taskManagementWorkbin *platformclientv2.Workbincreate) (*platformclientv2.Workbin, error) <span class="cov8" title="1">{
        workbin, _, err := p.taskManagementApi.PostTaskmanagementWorkbins(*taskManagementWorkbin)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create task management workbin: %s", err)
        }</span>

        <span class="cov0" title="0">return workbin, nil</span>
}

// getAllTaskManagementWorkbinFn is the implementation for retrieving all task management workbin in Genesys Cloud
func getAllTaskManagementWorkbinFn(ctx context.Context, p *taskManagementWorkbinProxy) (*[]platformclientv2.Workbin, error) <span class="cov0" title="0">{
        var allWorkbins []platformclientv2.Workbin
        pageSize := 200
        after := ""

        for </span><span class="cov0" title="0">{
                queryReq := &amp;platformclientv2.Workbinqueryrequest{
                        PageSize: &amp;pageSize,
                        After:    &amp;after,
                }
                workbins, _, err := p.taskManagementApi.PostTaskmanagementWorkbinsQuery(*queryReq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get workbin: %v", err)
                }</span>
                <span class="cov0" title="0">allWorkbins = append(allWorkbins, *workbins.Entities...)

                // Exit loop if there are no more 'pages'
                if workbins.After == nil || *workbins.After == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">after = *workbins.After</span>
        }

        <span class="cov0" title="0">return &amp;allWorkbins, nil</span>
}

// getTaskManagementWorkbinIdByNameFn is an implementation of the function to get a Genesys Cloud task management workbin by name
func getTaskManagementWorkbinIdByNameFn(ctx context.Context, p *taskManagementWorkbinProxy, name string) (id string, retryable bool, err error) <span class="cov0" title="0">{
        workbins, err := p.getAllTaskManagementWorkbin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("failed to get workbin %s. failed to get all task management workbins", name)
        }</span>

        <span class="cov0" title="0">for _, workbin := range *workbins </span><span class="cov0" title="0">{
                if *workbin.Name == name </span><span class="cov0" title="0">{
                        return *workbin.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("no task management workbin found with name %s", name)</span>
}

// getTaskManagementWorkbinByIdFn is an implementation of the function to get a Genesys Cloud task management workbin by Id
func getTaskManagementWorkbinByIdFn(ctx context.Context, p *taskManagementWorkbinProxy, id string) (taskManagementWorkbin *platformclientv2.Workbin, statusCode int, err error) <span class="cov0" title="0">{
        workbin, resp, err := p.taskManagementApi.GetTaskmanagementWorkbin(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp.StatusCode, fmt.Errorf("failed to retrieve task management workbin by id %s: %s", id, err)
        }</span>

        <span class="cov0" title="0">return workbin, resp.StatusCode, nil</span>
}

// updateTaskManagementWorkbinFn is an implementation of the function to update a Genesys Cloud task management workbin
func updateTaskManagementWorkbinFn(ctx context.Context, p *taskManagementWorkbinProxy, id string, taskManagementWorkbin *platformclientv2.Workbinupdate) (*platformclientv2.Workbin, error) <span class="cov0" title="0">{
        workbin, _, err := p.taskManagementApi.PatchTaskmanagementWorkbin(id, *taskManagementWorkbin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task management workbin: %s", err)
        }</span>
        <span class="cov0" title="0">return workbin, nil</span>
}

// deleteTaskManagementWorkbinFn is an implementation function for deleting a Genesys Cloud task management workbin
func deleteTaskManagementWorkbinFn(ctx context.Context, p *taskManagementWorkbinProxy, id string) (statusCode int, err error) <span class="cov0" title="0">{
        resp, err := p.taskManagementApi.DeleteTaskmanagementWorkbin(id)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("failed to delete task management workbin: %s", err)
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package task_management_workbin

import (
        "context"
        "fmt"
        "log"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

/*
The resource_genesyscloud_task_management_workbin.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthTaskManagementWorkbin retrieves all of the task management workbin via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthTaskManagementWorkbins(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        proxy := getTaskManagementWorkbinProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)

        workbins, err := proxy.getAllTaskManagementWorkbin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("failed to get all workbins: %v", err)
        }</span>

        <span class="cov0" title="0">for _, workbin := range *workbins </span><span class="cov0" title="0">{
                log.Printf("Dealing with task management workbin id: %s", *workbin.Id)
                resources[*workbin.Id] = &amp;resourceExporter.ResourceMeta{Name: *workbin.Id}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// createTaskManagementWorkbin is used by the task_management_workbin resource to create Genesys cloud task management workbin
func createTaskManagementWorkbin(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTaskManagementWorkbinProxy(sdkConfig)

        taskManagementWorkbin := platformclientv2.Workbincreate{
                Name:        platformclientv2.String(d.Get("name").(string)),
                DivisionId:  platformclientv2.String(d.Get("division_id").(string)),
                Description: platformclientv2.String(d.Get("description").(string)),
        }

        log.Printf("Creating task management workbin %s", *taskManagementWorkbin.Name)
        workbin, err := proxy.createTaskManagementWorkbin(ctx, &amp;taskManagementWorkbin)
        if err != nil </span><span class="cov8" title="1">{
                return diag.Errorf("failed to create task management workbin: %s", err)
        }</span>

        <span class="cov0" title="0">d.SetId(*workbin.Id)
        log.Printf("Created task management workbin %s", *workbin.Id)
        return readTaskManagementWorkbin(ctx, d, meta)</span>
}

// readTaskManagementWorkbin is used by the task_management_workbin resource to read an task management workbin from genesys cloud
func readTaskManagementWorkbin(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTaskManagementWorkbinProxy(sdkConfig)

        log.Printf("Reading task management workbin %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov0" title="0">{
                workbin, respCode, getErr := proxy.getTaskManagementWorkbinById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read task management workbin %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read task management workbin %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov0" title="0">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceTaskManagementWorkbin())

                resourcedata.SetNillableValue(d, "name", workbin.Name)
                resourcedata.SetNillableReferenceDivision(d, "division_id", workbin.Division)
                resourcedata.SetNillableValue(d, "description", workbin.Description)

                log.Printf("Read task management workbin %s %s", d.Id(), *workbin.Name)
                return cc.CheckState()</span>
        })
}

// updateTaskManagementWorkbin is used by the task_management_workbin resource to update an task management workbin in Genesys Cloud
func updateTaskManagementWorkbin(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTaskManagementWorkbinProxy(sdkConfig)

        taskManagementWorkbin := platformclientv2.Workbinupdate{
                Name:        platformclientv2.String(d.Get("name").(string)),
                Description: platformclientv2.String(d.Get("description").(string)),
        }

        log.Printf("Updating task management workbin %s", *taskManagementWorkbin.Name)
        workbin, err := proxy.updateTaskManagementWorkbin(ctx, d.Id(), &amp;taskManagementWorkbin)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to update task management workbin: %s", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated task management workbin %s", *workbin.Id)
        return readTaskManagementWorkbin(ctx, d, meta)</span>
}

// deleteTaskManagementWorkbin is used by the task_management_workbin resource to delete an task management workbin from Genesys cloud
func deleteTaskManagementWorkbin(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTaskManagementWorkbinProxy(sdkConfig)

        _, err := proxy.deleteTaskManagementWorkbin(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to delete task management workbin %s: %s", d.Id(), err)
        }</span>

        <span class="cov0" title="0">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov0" title="0">{
                _, respCode, err := proxy.getTaskManagementWorkbinById(ctx, d.Id())

                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                log.Printf("Deleted task management workbin %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting task management workbin %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("task management workbin %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package task_management_workbin

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_task_management_workbin_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the task_management_workbin resource.
3.  The datasource schema definitions for the task_management_workbin datasource.
4.  The resource exporter configuration for the task_management_workbin exporter.
*/
const resourceName = "genesyscloud_task_management_workbin"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceTaskManagementWorkbin())
        regInstance.RegisterDataSource(resourceName, DataSourceTaskManagementWorkbin())
        regInstance.RegisterExporter(resourceName, TaskManagementWorkbinExporter())
}</span>

// ResourceTaskManagementWorkbin registers the genesyscloud_task_management_workbin resource with Terraform
func ResourceTaskManagementWorkbin() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud task management workbin`,

                CreateContext: gcloud.CreateWithPooledClient(createTaskManagementWorkbin),
                ReadContext:   gcloud.ReadWithPooledClient(readTaskManagementWorkbin),
                UpdateContext: gcloud.UpdateWithPooledClient(updateTaskManagementWorkbin),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteTaskManagementWorkbin),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Workbin name",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        "division_id": {
                                Description: "The division to which this entity belongs.",
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeString,
                                ForceNew:    true,
                        },
                        "description": {
                                Description: "Workbin description",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
}</span>

// TaskManagementWorkbinExporter returns the resourceExporter object used to hold the genesyscloud_task_management_workbin exporter's config
func TaskManagementWorkbinExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthTaskManagementWorkbins),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "division_id": {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

// DataSourceTaskManagementWorkbin registers the genesyscloud_task_management_workbin data source
func DataSourceTaskManagementWorkbin() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud task management workbin data source. Select an task management workbin by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceTaskManagementWorkbinRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `task management workbin name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package team

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
)

/*
   The data_source_genesyscloud_team.go contains the data source implementation
   for the resource.
*/

// dataSourceTeamRead retrieves by name the id in question
func dataSourceTeamRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := newTeamProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                teamId, retryable, err := proxy.getTeamIdByName(ctx, name)

                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("Error searching team %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(fmt.Errorf("No team found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(teamId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package team

import (
        "context"
        "fmt"
        "log"
        "net/url"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_team_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.
*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *teamProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type createTeamFunc func(ctx context.Context, p *teamProxy, team *platformclientv2.Team) (*platformclientv2.Team, error)
type getAllTeamFunc func(ctx context.Context, p *teamProxy, name string) (*[]platformclientv2.Team, error)
type getTeamIdByNameFunc func(ctx context.Context, p *teamProxy, name string) (id string, retryable bool, err error)
type getTeamByIdFunc func(ctx context.Context, p *teamProxy, id string) (team *platformclientv2.Team, responseCode int, err error)
type updateTeamFunc func(ctx context.Context, p *teamProxy, id string, team *platformclientv2.Team) (*platformclientv2.Team, error)
type deleteTeamFunc func(ctx context.Context, p *teamProxy, id string) (responseCode int, err error)

// teamProxy contains all of the methods that call genesys cloud APIs.
type teamProxy struct {
        clientConfig        *platformclientv2.Configuration
        teamsApi            *platformclientv2.TeamsApi
        createTeamAttr      createTeamFunc
        getAllTeamAttr      getAllTeamFunc
        getTeamIdByNameAttr getTeamIdByNameFunc
        getTeamByIdAttr     getTeamByIdFunc
        updateTeamAttr      updateTeamFunc
        deleteTeamAttr      deleteTeamFunc
}

// newTeamProxy initializes the team proxy with all of the data needed to communicate with Genesys Cloud
func newTeamProxy(clientConfig *platformclientv2.Configuration) *teamProxy <span class="cov8" title="1">{
        api := platformclientv2.NewTeamsApiWithConfig(clientConfig)
        return &amp;teamProxy{
                clientConfig:        clientConfig,
                teamsApi:            api,
                createTeamAttr:      createTeamFn,
                getAllTeamAttr:      getAllTeamFn,
                getTeamIdByNameAttr: getTeamIdByNameFn,
                getTeamByIdAttr:     getTeamByIdFn,
                updateTeamAttr:      updateTeamFn,
                deleteTeamAttr:      deleteTeamFn,
        }
}</span>

// getTeamProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getTeamProxy(clientConfig *platformclientv2.Configuration) *teamProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newTeamProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// createTeam creates a Genesys Cloud team
func (p *teamProxy) createTeam(ctx context.Context, team *platformclientv2.Team) (*platformclientv2.Team, error) <span class="cov8" title="1">{
        return p.createTeamAttr(ctx, p, team)
}</span>

// getTeam retrieves all Genesys Cloud team
func (p *teamProxy) getAllTeam(ctx context.Context, name string) (*[]platformclientv2.Team, error) <span class="cov8" title="1">{
        return p.getAllTeamAttr(ctx, p, name)
}</span>

// getTeamIdByName returns a single Genesys Cloud team by a name
func (p *teamProxy) getTeamIdByName(ctx context.Context, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getTeamIdByNameAttr(ctx, p, name)
}</span>

// getTeamById returns a single Genesys Cloud team by Id
func (p *teamProxy) getTeamById(ctx context.Context, id string) (team *platformclientv2.Team, statusCode int, err error) <span class="cov8" title="1">{
        return p.getTeamByIdAttr(ctx, p, id)
}</span>

// updateTeam updates a Genesys Cloud team
func (p *teamProxy) updateTeam(ctx context.Context, id string, team *platformclientv2.Team) (*platformclientv2.Team, error) <span class="cov8" title="1">{
        return p.updateTeamAttr(ctx, p, id, team)
}</span>

// deleteTeam deletes a Genesys Cloud team by Id
func (p *teamProxy) deleteTeam(ctx context.Context, id string) (statusCode int, err error) <span class="cov8" title="1">{
        return p.deleteTeamAttr(ctx, p, id)
}</span>

// createTeamFn is an implementation function for creating a Genesys Cloud team
func createTeamFn(ctx context.Context, p *teamProxy, team *platformclientv2.Team) (*platformclientv2.Team, error) <span class="cov8" title="1">{
        team, _, err := p.teamsApi.PostTeams(*team)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create team: %s", err)
        }</span>

        <span class="cov8" title="1">return team, nil</span>
}

// getAllTeamFn is the implementation for retrieving all team in Genesys Cloud
func getAllTeamFn(ctx context.Context, p *teamProxy, name string) (*[]platformclientv2.Team, error) <span class="cov8" title="1">{
        var (
                after    string
                allTeams []platformclientv2.Team
        )

        const pageSize = 100
        for i := 0; ; i++ </span><span class="cov8" title="1">{

                teams, _, getErr := p.teamsApi.GetTeams(pageSize, name, after, "", "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to find team entities %s", getErr)
                }</span>

                <span class="cov8" title="1">if teams.Entities == nil || len(*teams.Entities) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">allTeams = append(allTeams, *teams.Entities...)

                if teams.NextUri == nil || *teams.NextUri == "" </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">u, err := url.Parse(*teams.NextUri)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to find team entities %s", err)
                }</span>

                <span class="cov0" title="0">m, _ := url.ParseQuery(u.RawQuery)
                if afterSlice, ok := m["after"]; ok &amp;&amp; len(afterSlice) &gt; 0 </span><span class="cov0" title="0">{
                        after = afterSlice[0]
                }</span>
                <span class="cov0" title="0">if after == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;allTeams, nil</span>

}

// getTeamIdByNameFn is an implementation of the function to get a Genesys Cloud team by name
func getTeamIdByNameFn(ctx context.Context, p *teamProxy, name string) (id string, retryable bool, err error) <span class="cov8" title="1">{
        teams, err := getAllTeamFn(ctx, p, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov8" title="1">if len(*teams) == 0 </span><span class="cov8" title="1">{
                return "", true, fmt.Errorf("No team found with name %s", name)
        }</span>

        <span class="cov8" title="1">for _, team := range *teams </span><span class="cov8" title="1">{
                if *team.Name == name </span><span class="cov8" title="1">{
                        log.Printf("Retrieved the team id %s by name %s", *team.Id, name)
                        return *team.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("Unable to find team with name %s", name)</span>
}

// getTeamByIdFn is an implementation of the function to get a Genesys Cloud team by Id
func getTeamByIdFn(ctx context.Context, p *teamProxy, id string) (team *platformclientv2.Team, statusCode int, err error) <span class="cov8" title="1">{
        team, resp, err := p.teamsApi.GetTeam(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp.StatusCode, fmt.Errorf("Failed to retrieve team by id %s: %s", id, err)
        }</span>

        <span class="cov8" title="1">return team, resp.StatusCode, nil</span>
}

// updateTeamFn is an implementation of the function to update a Genesys Cloud team
func updateTeamFn(ctx context.Context, p *teamProxy, id string, team *platformclientv2.Team) (*platformclientv2.Team, error) <span class="cov8" title="1">{
        team, _, err := p.teamsApi.PatchTeam(id, *team)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to update team: %s", err)
        }</span>
        <span class="cov8" title="1">return team, nil</span>
}

// deleteTeamFn is an implementation function for deleting a Genesys Cloud team
func deleteTeamFn(ctx context.Context, p *teamProxy, id string) (statusCode int, err error) <span class="cov8" title="1">{
        resp, err := p.teamsApi.DeleteTeam(id)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, fmt.Errorf("Failed to delete team: %s", err)
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package team

import (
        "context"
        "fmt"
        "log"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

/*
The resource_genesyscloud_team.go contains all of the methods that perform the core logic for a resource.
*/

// getAllAuthTeam retrieves all of the team via Terraform in the Genesys Cloud and is used for the exporter
func getAllAuthTeams(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov8" title="1">{
        proxy := getTeamProxy(clientConfig)
        resources := make(resourceExporter.ResourceIDMetaMap)
        teams, err := proxy.getAllTeam(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get team: %v", err)
        }</span>

        <span class="cov8" title="1">for _, team := range *teams </span><span class="cov8" title="1">{
                resources[*team.Id] = &amp;resourceExporter.ResourceMeta{Name: *team.Id}
        }</span>

        <span class="cov8" title="1">return resources, nil</span>
}

// createTeam is used by the team resource to create Genesys cloud team
func createTeam(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTeamProxy(sdkConfig)

        team := getTeamFromResourceData(d)

        log.Printf("Creating team %s", *team.Name)
        teamObj, err := proxy.createTeam(ctx, &amp;team)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create team: %s", err)
        }</span>

        <span class="cov8" title="1">d.SetId(*teamObj.Id)
        log.Printf("Created team %s", *teamObj.Id)
        return readTeam(ctx, d, meta)</span>
}

// readTeam is used by the team resource to read an team from genesys cloud
func readTeam(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTeamProxy(sdkConfig)

        log.Printf("Reading team %s", d.Id())

        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                team, respCode, getErr := proxy.getTeamById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read team %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read team %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceTeam())

                resourcedata.SetNillableValue(d, "name", team.Name)

                resourcedata.SetNillableReferenceWritableDivision(d, "division_id", team.Division)

                resourcedata.SetNillableValue(d, "description", team.Description)

                log.Printf("Read team %s %s", d.Id(), *team.Name)
                return cc.CheckState()</span>
        })
}

// updateTeam is used by the team resource to update an team in Genesys Cloud
func updateTeam(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTeamProxy(sdkConfig)

        team := getTeamFromResourceData(d)

        log.Printf("Updating team %s", *team.Name)
        teamObj, err := proxy.updateTeam(ctx, d.Id(), &amp;team)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to update team: %s", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated team %s", *teamObj.Id)
        return readTeam(ctx, d, meta)</span>
}

// deleteTeam is used by the team resource to delete an team from Genesys cloud
func deleteTeam(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTeamProxy(sdkConfig)

        _, err := proxy.deleteTeam(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete team %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 180*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                _, respCode, err := proxy.getTeamById(ctx, d.Id())

                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                                log.Printf("Deleted team %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Error deleting team %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("team %s still exists", d.Id()))</span>
        })
}

// getTeamFromResourceData maps data from schema ResourceData object to a platformclientv2.Team
func getTeamFromResourceData(d *schema.ResourceData) platformclientv2.Team <span class="cov8" title="1">{

        name := d.Get("name").(string)
        division := d.Get("division_id").(string)

        return platformclientv2.Team{
                Name:        &amp;name,
                Division:    &amp;platformclientv2.Writabledivision{Id: &amp;division},
                Description: platformclientv2.String(d.Get("description").(string)),
        }
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package team

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesycloud_team_schema.go holds four functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the team resource.
3.  The datasource schema definitions for the team datasource.
4.  The resource exporter configuration for the team exporter.
*/
const resourceName = "genesyscloud_team"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(regInstance registrar.Registrar) <span class="cov0" title="0">{
        regInstance.RegisterResource(resourceName, ResourceTeam())
        regInstance.RegisterDataSource(resourceName, DataSourceTeam())
        regInstance.RegisterExporter(resourceName, TeamExporter())
}</span>

// ResourceTeam registers the genesyscloud_team resource with Terraform
func ResourceTeam() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud team`,

                CreateContext: gcloud.CreateWithPooledClient(createTeam),
                ReadContext:   gcloud.ReadWithPooledClient(readTeam),
                UpdateContext: gcloud.UpdateWithPooledClient(updateTeam),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteTeam),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The team name",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        "division_id": {
                                Description: "The division to which this entity belongs.",
                                Required:    true,
                                Type:        schema.TypeString,
                        },
                        "description": {
                                Description: "Team information.",
                                Optional:    true,
                                Type:        schema.TypeString,
                        },
                },
        }
}</span>

// TeamExporter returns the resourceExporter object used to hold the genesyscloud_team exporter's config
func TeamExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllAuthTeams),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "division_id": {RefType: "genesyscloud_auth_division"},
                },
        }
}</span>

// DataSourceTeam registers the genesyscloud_team data source
func DataSourceTeam() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: `Genesys Cloud team data source. Select an team by name`,
                ReadContext: gcloud.ReadWithPooledClient(dataSourceTeamRead),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: `team name`,
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package telephony_providers_edges_did

import (
        "context"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// dataSourceDidRead retrieves by DID ID by DID number
func dataSourceDidRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyProvidersEdgesDidProxy(sdkConfig)

        didPhoneNumber := d.Get("phone_number").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                id, retryable, err := proxy.getTelephonyProvidersEdgesDidIdByDid(ctx, didPhoneNumber)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(err)
                }</span>
                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(err)
                }</span>
                <span class="cov8" title="1">d.SetId(id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package telephony_providers_edges_did

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_telephony_providers_edges_did_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *telephonyProvidersEdgesDidProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getTelephonyProvidersEdgesDidIdByDidFunc func(ctx context.Context, t *telephonyProvidersEdgesDidProxy, did string) (id string, retryable bool, err error)

// telephonyProvidersEdgesDidProxy contains all of the methods that call genesys cloud APIs.
type telephonyProvidersEdgesDidProxy struct {
        clientConfig                             *platformclientv2.Configuration
        telephonyApi                             *platformclientv2.TelephonyProvidersEdgeApi
        getTelephonyProvidersEdgesDidIdByDidAttr getTelephonyProvidersEdgesDidIdByDidFunc
}

// newTelephonyProvidersEdgesDidProxy initializes the proxy with all data needed to communicate with Genesys Cloud
func newTelephonyProvidersEdgesDidProxy(clientConfig *platformclientv2.Configuration) *telephonyProvidersEdgesDidProxy <span class="cov8" title="1">{
        api := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(clientConfig)
        return &amp;telephonyProvidersEdgesDidProxy{
                clientConfig:                             clientConfig,
                telephonyApi:                             api,
                getTelephonyProvidersEdgesDidIdByDidAttr: getTelephonyProvidersEdgesDidIdByDidFn,
        }
}</span>

// getTelephonyProvidersEdgesDidProxy acts as a singleton for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getTelephonyProvidersEdgesDidProxy(clientConfig *platformclientv2.Configuration) *telephonyProvidersEdgesDidProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newTelephonyProvidersEdgesDidProxy(clientConfig)
        }</span>
        <span class="cov8" title="1">return internalProxy</span>
}

// getTelephonyProvidersEdgesDidIdByDid gets a Genesys Cloud telephony DID ID by DID number
func (t *telephonyProvidersEdgesDidProxy) getTelephonyProvidersEdgesDidIdByDid(ctx context.Context, did string) (string, bool, error) <span class="cov8" title="1">{
        return t.getTelephonyProvidersEdgesDidIdByDidAttr(ctx, t, did)
}</span>

// getTelephonyProvidersEdgesDidIdByDidFn is an implementation function for getting a telephony DID ID by DID number.
func getTelephonyProvidersEdgesDidIdByDidFn(_ context.Context, t *telephonyProvidersEdgesDidProxy, did string) (string, bool, error) <span class="cov8" title="1">{
        const pageSize = 100

        pageNum := 1
        dids, _, getErr := t.telephonyApi.GetTelephonyProvidersEdgesDids(pageSize, pageNum, "", "", did, "", "", nil)
        if getErr != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("error requesting list of DIDs: %s", getErr)
        }</span>

        <span class="cov8" title="1">for pageNum := 1; pageNum &lt;= *dids.PageCount; pageNum++ </span><span class="cov8" title="1">{
                dids, _, getErr := t.telephonyApi.GetTelephonyProvidersEdgesDids(pageSize, pageNum, "", "", did, "", "", nil)
                if getErr != nil </span><span class="cov0" title="0">{
                        return "", false, fmt.Errorf("error requesting list of DIDs: %s", getErr)
                }</span>
                <span class="cov8" title="1">if dids.Entities == nil || len(*dids.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">for _, entity := range *dids.Entities </span><span class="cov8" title="1">{
                        if *entity.PhoneNumber == did </span><span class="cov8" title="1">{
                                return *entity.Id, false, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", true, fmt.Errorf("failed to find ID of did number '%s'", did)</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package telephony_providers_edges_did

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

const resourceName = "genesyscloud_telephony_providers_edges_did"

// SetRegistrar registers all resources, data sources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceDid())
}</span>

// DataSourceDid registers the genesyscloud_telephony_providers_edges_did data source
func DataSourceDid() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud DID. The identifier is the E-164 phone number.",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceDidRead),
                Schema: map[string]*schema.Schema{
                        "phone_number": {
                                Description:      "Phone number for the DID.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package telephony_providers_edges_did_pool

import (
        "context"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// dataSourceDidPoolRead retrieves the did pool id using the start and end number
func dataSourceDidPoolRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyDidPoolProxy(sdkConfig)

        didPoolStartPhoneNumber := d.Get("start_phone_number").(string)
        didPoolEndPhoneNumber := d.Get("end_phone_number").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                id, retryable, err := proxy.getTelephonyDidPoolIdByStartAndEndNumber(ctx, didPoolStartPhoneNumber, didPoolEndPhoneNumber)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(err)
                }</span>
                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(err)
                }</span>
                <span class="cov8" title="1">d.SetId(id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package telephony_providers_edges_did_pool

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_telephony_providers_edges_did_pool_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds an instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *telephonyDidPoolProxy

// Type definitions for each func on our proxy, so we can easily mock them out later
type createTelephonyDidPool func(ctx context.Context, t *telephonyDidPoolProxy, didPool *platformclientv2.Didpool) (*platformclientv2.Didpool, error)
type getTelephonyDidPoolById func(context.Context, *telephonyDidPoolProxy, string) (didPool *platformclientv2.Didpool, respCode int, err error)
type updateTelephonyDidPool func(context.Context, *telephonyDidPoolProxy, string, *platformclientv2.Didpool) (*platformclientv2.Didpool, error)
type deleteTelephonyDidPool func(context.Context, *telephonyDidPoolProxy, string) error
type getTelephonyDidPoolIdByStartAndEndNumber func(ctx context.Context, t *telephonyDidPoolProxy, start, end string) (id string, retryable bool, err error)
type getAllTelephonyDidPools func(context.Context, *telephonyDidPoolProxy) (*[]platformclientv2.Didpool, error)

// telephonyDidPoolProxy contains all methods that call genesys cloud APIs.
type telephonyDidPoolProxy struct {
        clientConfig                                 *platformclientv2.Configuration
        telephonyApi                                 *platformclientv2.TelephonyProvidersEdgeApi
        createTelephonyDidPoolAttr                   createTelephonyDidPool
        getTelephonyDidPoolByIdAttr                  getTelephonyDidPoolById
        updateEdgesDidPoolAttr                       updateTelephonyDidPool
        deleteTelephonyDidPoolAttr                   deleteTelephonyDidPool
        getTelephonyDidPoolIdByStartAndEndNumberAttr getTelephonyDidPoolIdByStartAndEndNumber
        getAllTelephonyDidPoolsAttr                  getAllTelephonyDidPools
}

// newTelephonyProvidersEdgesDidPoolProxy initializes the proxy with all data needed to communicate with Genesys Cloud
func newTelephonyProvidersEdgesDidPoolProxy(clientConfig *platformclientv2.Configuration) *telephonyDidPoolProxy <span class="cov8" title="1">{
        api := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(clientConfig)
        return &amp;telephonyDidPoolProxy{
                clientConfig:                                 clientConfig,
                telephonyApi:                                 api,
                createTelephonyDidPoolAttr:                   createTelephonyDidPoolFn,
                getTelephonyDidPoolByIdAttr:                  getTelephonyDidPoolByIdFn,
                updateEdgesDidPoolAttr:                       updateEdgesDidPoolFn,
                deleteTelephonyDidPoolAttr:                   deleteTelephonyDidPoolFn,
                getTelephonyDidPoolIdByStartAndEndNumberAttr: getTelephonyDidPoolIdByStartAndEndNumberFn,
                getAllTelephonyDidPoolsAttr:                  getAllTelephonyDidPoolsFn,
        }
}</span>

// getTelephonyDidPoolProxy acts as a singleton for the internalProxy. It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getTelephonyDidPoolProxy(clientConfig *platformclientv2.Configuration) *telephonyDidPoolProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newTelephonyProvidersEdgesDidPoolProxy(clientConfig)
        }</span>
        <span class="cov8" title="1">return internalProxy</span>
}

// createTelephonyDidPool creates a Genesys Cloud did pool
func (t *telephonyDidPoolProxy) createTelephonyDidPool(ctx context.Context, didPool *platformclientv2.Didpool) (*platformclientv2.Didpool, error) <span class="cov8" title="1">{
        return t.createTelephonyDidPoolAttr(ctx, t, didPool)
}</span>

// getTelephonyDidPoolById reads a Genesys Cloud did pool by id
func (t *telephonyDidPoolProxy) getTelephonyDidPoolById(ctx context.Context, id string) (*platformclientv2.Didpool, int, error) <span class="cov8" title="1">{
        return t.getTelephonyDidPoolByIdAttr(ctx, t, id)
}</span>

// updateTelephonyDidPool update a Genesys Cloud did pool
func (t *telephonyDidPoolProxy) updateTelephonyDidPool(ctx context.Context, id string, didPool *platformclientv2.Didpool) (*platformclientv2.Didpool, error) <span class="cov8" title="1">{
        return t.updateEdgesDidPoolAttr(ctx, t, id, didPool)
}</span>

// deleteTelephonyDidPool delete a Genesys Cloud did pool
func (t *telephonyDidPoolProxy) deleteTelephonyDidPool(ctx context.Context, id string) error <span class="cov8" title="1">{
        return t.deleteTelephonyDidPoolAttr(ctx, t, id)
}</span>

// getTelephonyDidPoolIdByStartAndEndNumber find a Genesys Cloud did pool id using the start and end number
func (t *telephonyDidPoolProxy) getTelephonyDidPoolIdByStartAndEndNumber(ctx context.Context, start, end string) (string, bool, error) <span class="cov8" title="1">{
        return t.getTelephonyDidPoolIdByStartAndEndNumberAttr(ctx, t, start, end)
}</span>

// getAllTelephonyDidPools read all Genesys Cloud did pools
func (t *telephonyDidPoolProxy) getAllTelephonyDidPools(ctx context.Context) (*[]platformclientv2.Didpool, error) <span class="cov0" title="0">{
        return t.getAllTelephonyDidPoolsAttr(ctx, t)
}</span>

// createTelephonyDidPoolFn is an implementation function for creating a Genesys Cloud did pool
func createTelephonyDidPoolFn(_ context.Context, t *telephonyDidPoolProxy, didPool *platformclientv2.Didpool) (*platformclientv2.Didpool, error) <span class="cov8" title="1">{
        postDidPool, _, err := t.telephonyApi.PostTelephonyProvidersEdgesDidpools(*didPool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return postDidPool, nil</span>
}

// getTelephonyDidPoolByIdFn is an implementation function for reading a Genesys Cloud did pool by ID
func getTelephonyDidPoolByIdFn(_ context.Context, t *telephonyDidPoolProxy, id string) (*platformclientv2.Didpool, int, error) <span class="cov8" title="1">{
        didPool, resp, err := t.telephonyApi.GetTelephonyProvidersEdgesDidpool(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp.StatusCode, err
        }</span>
        <span class="cov8" title="1">return didPool, resp.StatusCode, nil</span>
}

// updateEdgesDidPoolFn is an implementation function for updating a Genesys Cloud did pool
func updateEdgesDidPoolFn(_ context.Context, t *telephonyDidPoolProxy, id string, didPool *platformclientv2.Didpool) (*platformclientv2.Didpool, error) <span class="cov8" title="1">{
        updatedDidPool, _, err := t.telephonyApi.PutTelephonyProvidersEdgesDidpool(id, *didPool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return updatedDidPool, nil</span>
}

// deleteTelephonyDidPoolFn is an implementation function for deleting a Genesys Cloud did pool
func deleteTelephonyDidPoolFn(_ context.Context, t *telephonyDidPoolProxy, id string) error <span class="cov8" title="1">{
        _, err := t.telephonyApi.DeleteTelephonyProvidersEdgesDidpool(id)
        return err
}</span>

// getAllTelephonyDidPoolsFn is an implementation function for reading all Genesys Cloud did pools
func getAllTelephonyDidPoolsFn(_ context.Context, t *telephonyDidPoolProxy) (*[]platformclientv2.Didpool, error) <span class="cov8" title="1">{
        var (
                allDidPools []platformclientv2.Didpool
                pageCount   int
                pageNum     = 1
        )
        const pageSize = 100

        didPools, _, getErr := t.telephonyApi.GetTelephonyProvidersEdgesDidpools(pageSize, pageNum, "", nil)
        if getErr != nil </span><span class="cov0" title="0">{
                return nil, getErr
        }</span>
        <span class="cov8" title="1">pageCount = *didPools.PageCount

        if didPools.Entities != nil &amp;&amp; len(*didPools.Entities) &gt; 0 </span><span class="cov8" title="1">{
                allDidPools = append(allDidPools, *didPools.Entities...)
        }</span>

        <span class="cov8" title="1">if pageCount &lt; 2 </span><span class="cov8" title="1">{
                return &amp;allDidPools, nil
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= pageCount; pageNum++ </span><span class="cov0" title="0">{
                didPools, _, getErr := t.telephonyApi.GetTelephonyProvidersEdgesDidpools(pageSize, pageNum, "", nil)
                if getErr != nil </span><span class="cov0" title="0">{
                        return nil, getErr
                }</span>

                <span class="cov0" title="0">if didPools.Entities == nil || len(*didPools.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">allDidPools = append(allDidPools, *didPools.Entities...)</span>
        }
        <span class="cov0" title="0">return &amp;allDidPools, nil</span>
}

// getTelephonyDidPoolIdByStartAndEndNumberFn is an implementation function for finding a Genesys Cloud did pool using the start and end number
func getTelephonyDidPoolIdByStartAndEndNumberFn(ctx context.Context, t *telephonyDidPoolProxy, start, end string) (string, bool, error) <span class="cov8" title="1">{
        allDidPools, err := getAllTelephonyDidPoolsFn(ctx, t)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("failed to read did pools: %v", err)
        }</span>
        <span class="cov8" title="1">for _, didPool := range *allDidPools </span><span class="cov8" title="1">{
                if didPool.StartPhoneNumber != nil &amp;&amp; *didPool.StartPhoneNumber == start &amp;&amp;
                        didPool.EndPhoneNumber != nil &amp;&amp; *didPool.EndPhoneNumber == end &amp;&amp;
                        didPool.State != nil &amp;&amp; *didPool.State != "deleted" </span><span class="cov8" title="1">{
                        return *didPool.Id, false, nil
                }</span>
        }
        <span class="cov8" title="1">return "", true, fmt.Errorf("failed to find DID pool with start phone number '%s' and end phone number '%s'", start, end)</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package telephony_providers_edges_did_pool

import (
        "context"
        "fmt"
        "log"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"

        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

// getAllDidPools retrieves all DID pools and is used for the exporter
func getAllDidPools(ctx context.Context, clientConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        proxy := getTelephonyDidPoolProxy(clientConfig)

        didPools, err := proxy.getAllTelephonyDidPools(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("failed to read did pools: %v", err)
        }</span>

        <span class="cov0" title="0">for _, didPool := range *didPools </span><span class="cov0" title="0">{
                if didPool.State != nil &amp;&amp; *didPool.State != "deleted" </span><span class="cov0" title="0">{
                        resources[*didPool.Id] = &amp;resourceExporter.ResourceMeta{Name: *didPool.StartPhoneNumber}
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createDidPool is used by the resource to create a Genesys Cloud DID pool
func createDidPool(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        startPhoneNumber := d.Get("start_phone_number").(string)
        endPhoneNumber := d.Get("end_phone_number").(string)
        description := d.Get("description").(string)
        comments := d.Get("comments").(string)
        poolProvider := d.Get("pool_provider").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyDidPoolProxy(sdkConfig)

        didPool := &amp;platformclientv2.Didpool{
                StartPhoneNumber: &amp;startPhoneNumber,
                EndPhoneNumber:   &amp;endPhoneNumber,
                Description:      &amp;description,
                Comments:         &amp;comments,
                Provider:         &amp;poolProvider,
        }
        log.Printf("Creating DID pool %s", startPhoneNumber)
        createdDidPool, err := proxy.createTelephonyDidPool(ctx, didPool)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to create DID pool %s: %s", startPhoneNumber, err)
        }</span>

        <span class="cov8" title="1">d.SetId(*createdDidPool.Id)

        log.Printf("Created DID pool %s %s", startPhoneNumber, *createdDidPool.Id)
        return readDidPool(ctx, d, meta)</span>
}

// readDidPool is used by the resource to read a Genesys Cloud DID pool
func readDidPool(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyDidPoolProxy(sdkConfig)

        log.Printf("Reading DID pool %s", d.Id())
        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                didPool, respCode, getErr := proxy.getTelephonyDidPoolById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("Failed to read DID pool %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("Failed to read DID pool %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">if didPool.State != nil &amp;&amp; *didPool.State == "deleted" </span><span class="cov0" title="0">{
                        d.SetId("")
                        return nil
                }</span>

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceTelephonyDidPool())
                _ = d.Set("start_phone_number", *didPool.StartPhoneNumber)
                _ = d.Set("end_phone_number", *didPool.EndPhoneNumber)

                resourcedata.SetNillableValue(d, "description", didPool.Description)
                resourcedata.SetNillableValue(d, "comments", didPool.Comments)
                resourcedata.SetNillableValue(d, "pool_provider", didPool.Provider)

                log.Printf("Read DID pool %s %s", d.Id(), *didPool.StartPhoneNumber)
                return cc.CheckState()</span>
        })
}

// updateDidPool is used by the resource to update a Genesys Cloud DID pool
func updateDidPool(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        startPhoneNumber := d.Get("start_phone_number").(string)
        endPhoneNumber := d.Get("end_phone_number").(string)
        description := d.Get("description").(string)
        comments := d.Get("comments").(string)
        poolProvider := d.Get("pool_provider").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyDidPoolProxy(sdkConfig)

        didPoolBody := &amp;platformclientv2.Didpool{
                StartPhoneNumber: &amp;startPhoneNumber,
                EndPhoneNumber:   &amp;endPhoneNumber,
                Description:      &amp;description,
                Comments:         &amp;comments,
                Provider:         &amp;poolProvider,
        }

        log.Printf("Updating DID pool %s", d.Id())
        if _, err := proxy.updateTelephonyDidPool(ctx, d.Id(), didPoolBody); err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Error updating DID pool %s: %s", startPhoneNumber, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated DID pool %s", d.Id())
        return readDidPool(ctx, d, meta)</span>
}

// deleteDidPool is used by the resource to delete a Genesys Cloud DID pool
func deleteDidPool(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        startPhoneNumber := d.Get("start_phone_number").(string)

        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        proxy := getTelephonyDidPoolProxy(sdkConfig)

        log.Printf("Deleting DID pool with starting number %s", startPhoneNumber)
        if err := proxy.deleteTelephonyDidPool(ctx, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to delete DID pool with starting number %s: %s", startPhoneNumber, err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                didPool, respCode, err := proxy.getTelephonyDidPoolById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404ByInt(respCode) </span><span class="cov8" title="1">{
                                // DID pool deleted
                                log.Printf("Deleted DID pool %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting DID pool %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">if didPool.State != nil &amp;&amp; *didPool.State == "deleted" </span><span class="cov0" title="0">{
                        // DID pool deleted
                        log.Printf("Deleted DID pool %s", d.Id())
                        return nil
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("DID pool %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package telephony_providers_edges_did_pool

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

const resourceName = "genesyscloud_telephony_providers_edges_did_pool"

// SetRegistrar registers all resources, data sources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceDidPool())
        l.RegisterResource(resourceName, ResourceTelephonyDidPool())
        l.RegisterExporter(resourceName, TelephonyDidPoolExporter())
}</span>

// TelephonyDidPoolExporter returns the resourceExporter object used to hold the genesyscloud_telephony_providers_edges_did_pool exporter's config
func TelephonyDidPoolExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllDidPools),
                RefAttrs:         map[string]*resourceExporter.RefAttrSettings{}, // No references
        }
}</span>

// ResourceTelephonyDidPool registers the genesyscloud_telephony_providers_edges_did_pool resource with Terraform
func ResourceTelephonyDidPool() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Genesys Cloud DID Pool",

                CreateContext: gcloud.CreateWithPooledClient(createDidPool),
                ReadContext:   gcloud.ReadWithPooledClient(readDidPool),
                UpdateContext: gcloud.UpdateWithPooledClient(updateDidPool),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteDidPool),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "start_phone_number": {
                                Description:      "Starting phone number of the DID Pool range. Phone number must be in a E.164 number format. Changing the start_phone_number attribute will cause the did_pool object to be dropped and recreated with a new ID.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ForceNew:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                        "end_phone_number": {
                                Description:      "Ending phone number of the DID Pool range.  Phone number must be in an E.164 number format. Changing the end_phone_number attribute will cause the did_pool object to be dropped and recreated with a new ID.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ForceNew:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                        "description": {
                                Description: "DID Pool description.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "comments": {
                                Description: "Comments for the DID Pool.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "pool_provider": {
                                Description:  "Provider (PURE_CLOUD | PURE_CLOUD_VOICE).",
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ValidateFunc: validation.StringInSlice([]string{"PURE_CLOUD", "PURE_CLOUD_VOICE"}, false),
                        },
                },
        }
}</span>

// DataSourceDidPool registers the genesyscloud_telephony_providers_edges_did_pool data source
func DataSourceDidPool() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud DID pool. Select a DID pool by starting phone number and ending phone number",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceDidPoolRead),
                Schema: map[string]*schema.Schema{
                        "start_phone_number": {
                                Description:      "Starting phone number of the DID Pool range. Must be in an E.164 number format.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                        "end_phone_number": {
                                Description:      "Ending phone number of the DID Pool range.",
                                Type:             schema.TypeString,
                                Required:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package telephony_providers_edges_did_pool

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

type DidPoolStruct struct {
        ResourceID       string
        StartPhoneNumber string
        EndPhoneNumber   string
        Description      string
        Comments         string
        PoolProvider     string
}

// DeleteDidPoolWithStartAndEndNumber deletes a did pool by start and end number. Used as a cleanup function in tests which
// utilise the did pool resource
func DeleteDidPoolWithStartAndEndNumber(ctx context.Context, startNumber, endNumber string) error <span class="cov8" title="1">{
        config := platformclientv2.GetDefaultConfiguration()
        proxy := getTelephonyDidPoolProxy(config)

        didPoolId, _, err := proxy.getTelephonyDidPoolIdByStartAndEndNumber(ctx, startNumber, endNumber)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">return proxy.deleteTelephonyDidPool(ctx, didPoolId)</span>
}

// GenerateDidPoolResource generates a string representation of a did pool resource based on a DidPoolStruct object
func GenerateDidPoolResource(didPool *DidPoolStruct) string <span class="cov8" title="1">{
        return fmt.Sprintf(`resource "%s" "%s" {
                start_phone_number = "%s"
                end_phone_number   = "%s"
                description        = %s
                comments           = %s
                pool_provider      = %s
        }
        `, resourceName,
                didPool.ResourceID,
                didPool.StartPhoneNumber,
                didPool.EndPhoneNumber,
                didPool.Description,
                didPool.Comments,
                didPool.PoolProvider)
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package telephony_providers_edges_phone

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourcePhoneRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        pp := getPhoneProxy(sdkConfig)

        name := d.Get("name").(string)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                phone, retryable, err := pp.getPhoneByName(ctx, name)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting phone %s: %s", name, err))
                }</span>

                <span class="cov8" title="1">if retryable </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf("no phone found with name %s", name))
                }</span>

                <span class="cov8" title="1">d.SetId(*phone.Id)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package telephony_providers_edges_phone

import (
        "context"
        "fmt"
        "log"
        "net/http"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_telephony_providers_edges_phone_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *phoneProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllPhonesFunc func(ctx context.Context, p *phoneProxy) (*[]platformclientv2.Phone, error)
type createPhoneFunc func(ctx context.Context, p *phoneProxy, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, *platformclientv2.APIResponse, error)
type getPhoneByIdFunc func(ctx context.Context, p *phoneProxy, phoneId string) (*platformclientv2.Phone, *platformclientv2.APIResponse, error)
type getPhoneByNameFunc func(ctx context.Context, p *phoneProxy, phoneName string) (phone *platformclientv2.Phone, retryable bool, err error)
type updatePhoneFunc func(ctx context.Context, p *phoneProxy, phoneId string, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, error)
type deletePhoneFunc func(ctx context.Context, p *phoneProxy, phoneId string) (responseCode int, err error)

type getPhoneBaseSettingFunc func(ctx context.Context, p *phoneProxy, phoneBaseSettingsId string) (*platformclientv2.Phonebase, error)
type getStationOfUserFunc func(ctx context.Context, p *phoneProxy, userId string) (station *platformclientv2.Station, retryable bool, err error)
type unassignUserFromStationFunc func(ctx context.Context, p *phoneProxy, stationId string) (*platformclientv2.APIResponse, error)
type assignUserToStationFunc func(ctx context.Context, p *phoneProxy, userId string, stationId string) (*platformclientv2.APIResponse, error)

// phoneProxy contains all of the methods that call genesys cloud APIs.
type phoneProxy struct {
        clientConfig *platformclientv2.Configuration
        edgesApi     *platformclientv2.TelephonyProvidersEdgeApi
        stationsApi  *platformclientv2.StationsApi
        usersApi     *platformclientv2.UsersApi

        getAllPhonesAttr   getAllPhonesFunc
        createPhoneAttr    createPhoneFunc
        getPhoneByIdAttr   getPhoneByIdFunc
        getPhoneByNameAttr getPhoneByNameFunc
        updatePhoneAttr    updatePhoneFunc
        deletePhoneAttr    deletePhoneFunc

        getPhoneBaseSettingAttr     getPhoneBaseSettingFunc
        getStationOfUserAttr        getStationOfUserFunc
        unassignUserFromStationAttr unassignUserFromStationFunc
        assignUserToStationAttr     assignUserToStationFunc
}

// newPhoneProxy initializes the Phone proxy with all of the data needed to communicate with Genesys Cloud
func newPhoneProxy(clientConfig *platformclientv2.Configuration) *phoneProxy <span class="cov8" title="1">{
        edgesApi := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(clientConfig)
        stationsApi := platformclientv2.NewStationsApiWithConfig(clientConfig)
        usersApi := platformclientv2.NewUsersApiWithConfig(clientConfig)

        return &amp;phoneProxy{
                clientConfig: clientConfig,
                edgesApi:     edgesApi,
                stationsApi:  stationsApi,
                usersApi:     usersApi,

                getAllPhonesAttr:   getAllPhonesFn,
                createPhoneAttr:    createPhoneFn,
                getPhoneByIdAttr:   getPhoneByIdFn,
                getPhoneByNameAttr: getPhoneByNameFn,
                updatePhoneAttr:    updatePhoneFn,
                deletePhoneAttr:    deletePhoneFn,

                getPhoneBaseSettingAttr:     getPhoneBaseSettingFn,
                getStationOfUserAttr:        getStationOfUserFn,
                unassignUserFromStationAttr: unassignUserFromStationFn,
                assignUserToStationAttr:     assignUserToStationFn,
        }
}</span>

// getPhoneProxy acts as a singleton to for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getPhoneProxy(clientConfig *platformclientv2.Configuration) *phoneProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newPhoneProxy(clientConfig)
        }</span>

        <span class="cov8" title="1">return internalProxy</span>
}

// getAllPhones retrieves all Genesys Cloud Phones
func (p *phoneProxy) getAllPhones(ctx context.Context) (*[]platformclientv2.Phone, error) <span class="cov0" title="0">{
        return p.getAllPhonesAttr(ctx, p)
}</span>

// createPhone creates a Genesys Cloud Phone
func (p *phoneProxy) createPhone(ctx context.Context, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.createPhoneAttr(ctx, p, phoneConfig)
}</span>

// getPhoneById retrieves a Genesys Cloud Phone by id
func (p *phoneProxy) getPhoneById(ctx context.Context, phoneId string) (*platformclientv2.Phone, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getPhoneByIdAttr(ctx, p, phoneId)
}</span>

// getPhoneByName retrieves a Genesys Cloud Phone by name
func (p *phoneProxy) getPhoneByName(ctx context.Context, phoneName string) (phone *platformclientv2.Phone, retryable bool, err error) <span class="cov8" title="1">{
        return p.getPhoneByNameAttr(ctx, p, phoneName)
}</span>

// updatePhone updates a Genesys Cloud Phone
func (p *phoneProxy) updatePhone(ctx context.Context, phoneId string, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, error) <span class="cov8" title="1">{
        return p.updatePhoneAttr(ctx, p, phoneId, phoneConfig)
}</span>

// deletePhone deletes a Genesys Cloud Phone
func (p *phoneProxy) deletePhone(ctx context.Context, phoneId string) (responseCode int, err error) <span class="cov8" title="1">{
        return p.deletePhoneAttr(ctx, p, phoneId)
}</span>

// getPhoneBaseSetting retrieves a Genesys Cloud Phone Base Setting
func (p *phoneProxy) getPhoneBaseSetting(ctx context.Context, phoneBaseSettingsId string) (*platformclientv2.Phonebase, error) <span class="cov8" title="1">{
        return p.getPhoneBaseSettingAttr(ctx, p, phoneBaseSettingsId)
}</span>

// getStationOfUser retrieves the station of a user
func (p *phoneProxy) getStationOfUser(ctx context.Context, userId string) (*platformclientv2.Station, bool, error) <span class="cov8" title="1">{
        return p.getStationOfUserAttr(ctx, p, userId)
}</span>

// unassignUserFromStation unassigns a user from the station
func (p *phoneProxy) unassignUserFromStation(ctx context.Context, stationId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.unassignUserFromStationAttr(ctx, p, stationId)
}</span>

// assignUserToStation assigns a user to the station
func (p *phoneProxy) assignUserToStation(ctx context.Context, userId string, stationId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.assignUserToStationAttr(ctx, p, userId, stationId)
}</span>

// getAllPhonesFn is an implementation function for retrieving all Genesys Cloud Phones
func getAllPhonesFn(ctx context.Context, p *phoneProxy) (*[]platformclientv2.Phone, error) <span class="cov0" title="0">{
        log.Printf("Entering the getAllPhonesFn method to retrieve all of the phone ids for export")
        var allPhones []platformclientv2.Phone
        const pageSize = 100
        const sortBy = "id"

        phones, response, err := p.edgesApi.GetTelephonyProvidersEdgesPhones(1, pageSize, sortBy, "", "", "", "", "", "", "", "", "", "", "", "", nil, nil)
        if err != nil || (response != nil &amp;&amp; response.StatusCode != http.StatusOK) </span><span class="cov0" title="0">{
                log.Printf("getAllPhonesFn:: error encountered while trying to get first page of phone data #%v statusCode: %d", err, response.StatusCode)
                return nil, err
        }</span>

        <span class="cov0" title="0">if phones != nil &amp;&amp; phones.Entities != nil </span><span class="cov0" title="0">{
                log.Printf("getAllPhonesFn::: Retrieved page 1 of %d pages of phone data.  Total number of phone records is %d", phones.PageCount, phones.Total)
                for _, phone := range *phones.Entities </span><span class="cov0" title="0">{
                        if phone.State != nil &amp;&amp; *phone.State != "deleted" </span><span class="cov0" title="0">{
                                allPhones = append(allPhones, phone)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("getAllPhonesFn:: No phone records were retrieved (phone or on the first call to p.edgesApi.GetTelephonyProvidersEdgesPhones.")
                phones := make([]platformclientv2.Phone, 0)
                return &amp;phones, nil
        }</span>

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *phones.PageCount; pageNum++ </span><span class="cov0" title="0">{
                phones, response, err := p.edgesApi.GetTelephonyProvidersEdgesPhones(pageNum, pageSize, sortBy, "", "", "", "", "", "", "", "", "", "", "", "", nil, nil)
                if err != nil || (response != nil &amp;&amp; response.StatusCode != http.StatusOK) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if phones.Entities == nil || len(*phones.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, phone := range *phones.Entities </span><span class="cov0" title="0">{
                        if phone.State != nil &amp;&amp; *phone.State != "deleted" </span><span class="cov0" title="0">{
                                allPhones = append(allPhones, phone)
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Printf("getAllPhonesFn:: Listing all of the non-deleted phone ids and names that we actually retrieved")
        for _, phone := range allPhones </span><span class="cov0" title="0">{
                log.Printf("getAllPhonesFn::  Retrieved phone id %s with phone name: %s\n", *phone.Id, *phone.Name)
        }</span>

        <span class="cov0" title="0">return &amp;allPhones, nil</span>
}

// createPhoneFn is an implementation function for creating a Genesys Cloud Phone
func createPhoneFn(ctx context.Context, p *phoneProxy, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        phone, resp, err := p.edgesApi.PostTelephonyProvidersEdgesPhones(*phoneConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return phone, resp, nil</span>
}

// getPhoneByIdFn is an implementation function for retrieving a Genesys Cloud Phone by id
func getPhoneByIdFn(ctx context.Context, p *phoneProxy, phoneId string) (*platformclientv2.Phone, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        phone, resp, err := p.edgesApi.GetTelephonyProvidersEdgesPhone(phoneId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">log.Printf("getPhoneByIdFn:: Successfully retrieved individual phone record id %s with phone name %s.\n", *phone.Id, *phone.Name)
        return phone, resp, nil</span>
}

// getPhoneByNameFn is an implementation function for retrieving a Genesys Cloud Phone by name
func getPhoneByNameFn(ctx context.Context, p *phoneProxy, phoneName string) (phone *platformclientv2.Phone, retryable bool, err error) <span class="cov8" title="1">{
        const pageSize = 100
        phones, _, err := p.edgesApi.GetTelephonyProvidersEdgesPhones(1, pageSize, "", "", "", "", "", "", "", "", "", "", phoneName, "", "", nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">if phones.Entities == nil || len(*phones.Entities) == 0 </span><span class="cov0" title="0">{
                return nil, true, fmt.Errorf("failed to find ID of phone '%s'", phoneName)
        }</span>

        <span class="cov8" title="1">for _, phone := range *phones.Entities </span><span class="cov8" title="1">{
                if *phone.Name == phoneName </span><span class="cov8" title="1">{
                        return &amp;phone, false, nil
                }</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *phones.PageCount; pageNum++ </span><span class="cov0" title="0">{
                phones, _, err := p.edgesApi.GetTelephonyProvidersEdgesPhones(pageNum, pageSize, "", "", "", "", "", "", "", "", "", "", phoneName, "", "", nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
                <span class="cov0" title="0">if phones.Entities == nil </span><span class="cov0" title="0">{
                        return nil, true, fmt.Errorf("failed to find ID of phone '%s'", phoneName)
                }</span>

                <span class="cov0" title="0">for _, phone := range *phones.Entities </span><span class="cov0" title="0">{
                        if *phone.Name == phoneName </span><span class="cov0" title="0">{
                                return &amp;phone, false, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, true, fmt.Errorf("failed to find ID of phone '%s'", phoneName)</span>
}

// updatePhoneFn is an implementation function for updating a Genesys Cloud Phone
func updatePhoneFn(ctx context.Context, p *phoneProxy, phoneId string, phoneConfig *platformclientv2.Phone) (*platformclientv2.Phone, error) <span class="cov8" title="1">{
        phone, _, err := p.edgesApi.PutTelephonyProvidersEdgesPhone(phoneId, *phoneConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return phone, err</span>
}

// deletePhoneFn is an implementation function for deleting a Genesys Cloud Phone
func deletePhoneFn(ctx context.Context, p *phoneProxy, phoneId string) (responseCode int, err error) <span class="cov8" title="1">{
        resp, err := p.edgesApi.DeleteTelephonyProvidersEdgesPhone(phoneId)
        return resp.StatusCode, err
}</span>

// getPhoneBaseSettingFn is an implementation function for retrieving a Genesys Cloud Phone Base Setting
func getPhoneBaseSettingFn(ctx context.Context, p *phoneProxy, phoneBaseSettingsId string) (*platformclientv2.Phonebase, error) <span class="cov8" title="1">{
        phoneBase, _, err := p.edgesApi.GetTelephonyProvidersEdgesPhonebasesetting(phoneBaseSettingsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return phoneBase, nil</span>
}

// getStationOfUserFn is an implementation function for retrieving a Genesys Cloud User Station
func getStationOfUserFn(ctx context.Context, p *phoneProxy, userId string) (station *platformclientv2.Station, retryable bool, err error) <span class="cov8" title="1">{
        const pageSize = 100
        const pageNum = 1
        stations, _, err := p.stationsApi.GetStations(pageSize, pageNum, "", "", "", userId, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">if stations.Entities == nil || len(*stations.Entities) == 0 </span><span class="cov8" title="1">{
                return nil, true, nil
        }</span>

        <span class="cov8" title="1">return &amp;(*stations.Entities)[0], false, err</span>
}

// unassignUserFromStationFn is an implementation function for unassigning a Genesys Cloud User from a Station
func unassignUserFromStationFn(ctx context.Context, p *phoneProxy, stationId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.stationsApi.DeleteStationAssociateduser(stationId)
}</span>

// assignUserToStationFn is an implementation function for assigning a Genesys Cloud User to a Station
func assignUserToStationFn(ctx context.Context, p *phoneProxy, userId string, stationId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.usersApi.PutUserStationAssociatedstationStationId(userId, stationId)
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">package telephony_providers_edges_phone

import (
        "context"
        "fmt"
        "log"
        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func getAllPhones(ctx context.Context, sdkConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        pp := getPhoneProxy(sdkConfig)

        phones, err := pp.getAllPhones(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.Errorf("Failed to get page of phones: %v", err)
        }</span>

        <span class="cov0" title="0">for _, phone := range *phones </span><span class="cov0" title="0">{
                resources[*phone.Id] = &amp;resourceExporter.ResourceMeta{Name: *phone.Name}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

func createPhone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPhoneProxy(sdkConfig)

        phoneConfig, err := getPhoneFromResourceData(ctx, pp, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to create phone %v: %v", *phoneConfig.Name, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Creating phone %s", *phoneConfig.Name)
        diagErr := gcloud.RetryWhen(gcloud.IsStatus404, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                phone, resp, err := pp.createPhone(ctx, phoneConfig)
                log.Printf("Completed call to create phone name %s with status code %d, correlation id %s and err %s", *phoneConfig.Name, resp.StatusCode, resp.CorrelationID, err)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("failed to create phone %s: %s", *phoneConfig.Name, err)
                }</span>
                <span class="cov8" title="1">d.SetId(*phone.Id)

                webRtcUserId := d.Get("web_rtc_user_id")
                if webRtcUserId != "" </span><span class="cov8" title="1">{
                        diagErr := assignUserToWebRtcPhone(ctx, pp, webRtcUserId.(string))
                        if diagErr != nil </span><span class="cov0" title="0">{
                                return resp, diagErr
                        }</span>
                }

                <span class="cov8" title="1">log.Printf("Created phone %s", *phone.Id)
                return nil, nil</span>
        })

        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return readPhone(ctx, d, meta)</span>
}

func readPhone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPhoneProxy(sdkConfig)

        log.Printf("Reading phone %s", d.Id())
        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                currentPhone, resp, getErr := pp.getPhoneById(ctx, d.Id())
                if getErr != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read phone %s: %s", d.Id(), getErr))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read phone %s: %s", d.Id(), getErr))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourcePhone())
                d.Set("name", *currentPhone.Name)
                d.Set("state", *currentPhone.State)
                d.Set("site_id", *currentPhone.Site.Id)
                d.Set("phone_base_settings_id", *currentPhone.PhoneBaseSettings.Id)
                d.Set("line_base_settings_id", *currentPhone.LineBaseSettings.Id)

                if currentPhone.PhoneMetaBase != nil </span><span class="cov8" title="1">{
                        d.Set("phone_meta_base_id", *currentPhone.PhoneMetaBase.Id)
                }</span>

                <span class="cov8" title="1">if currentPhone.WebRtcUser != nil </span><span class="cov8" title="1">{
                        d.Set("web_rtc_user_id", *currentPhone.WebRtcUser.Id)
                }</span>

                <span class="cov8" title="1">if currentPhone.Lines != nil </span><span class="cov8" title="1">{
                        d.Set("line_addresses", flattenPhoneLines(currentPhone.Lines))
                }</span>

                <span class="cov8" title="1">resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "capabilities", currentPhone.Capabilities, flattenPhoneCapabilities)

                log.Printf("Read phone %s %s", d.Id(), *currentPhone.Name)
                return cc.CheckState()</span>
        })
}

func updatePhone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPhoneProxy(sdkConfig)

        phoneConfig, err := getPhoneFromResourceData(ctx, pp, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to updated phone %v: %v", *phoneConfig.Name, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updating phone %s", *phoneConfig.Name)
        phone, err := pp.updatePhone(ctx, d.Id(), phoneConfig)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to update phone %s: %s", *phoneConfig.Name, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Updated phone %s", *phone.Id)

        webRtcUserId := d.Get("web_rtc_user_id")
        if webRtcUserId != "" </span><span class="cov8" title="1">{
                if d.HasChange("web_rtc_user_id") </span><span class="cov8" title="1">{
                        diagErr := assignUserToWebRtcPhone(ctx, pp, webRtcUserId.(string))
                        if diagErr != nil </span><span class="cov0" title="0">{
                                return diagErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return readPhone(ctx, d, meta)</span>
}

func deletePhone(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        pp := getPhoneProxy(sdkConfig)

        log.Printf("Deleting Phone")
        _, err := pp.deletePhone(ctx, d.Id())

        /*
          Adding a small sleep because when a phone is deleted, the station associated with the phone and the site
          objects need time to disassociate from the phone. This eventual consistency problem was discovered during
          building the GCX Now project.  Adding the sleep gives the platform time to settle down.
        */
        time.Sleep(5 * time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("failed to delete phone: %s", err)
        }</span>

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                phone, resp, err := pp.getPhoneById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Phone deleted
                                log.Printf("Deleted Phone %s", d.Id())
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting Phone %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">if phone.State != nil &amp;&amp; *phone.State == "deleted" </span><span class="cov0" title="0">{
                        // phone deleted
                        log.Printf("Deleted Phone %s", d.Id())
                        return nil
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("phone %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package telephony_providers_edges_phone

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_telephony_providers_edges_phone_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the telephony_providers_edges_phone resource.
3.  The datasource schema definitions for the telephony_providers_edges_phone datasource.
4.  The resource exporter configuration for the telephony_providers_edges_phone exporter.
*/
const resourceName = "genesyscloud_telephony_providers_edges_phone"

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourcePhone())
        l.RegisterResource(resourceName, ResourcePhone())
        l.RegisterExporter(resourceName, PhoneExporter())
}</span>

// ResourcePhone registers the genesyscloud_telephony_providers_edges_phone resource with Terraform
func ResourcePhone() *schema.Resource <span class="cov8" title="1">{
        phoneCapabilities := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "provisions": {
                                Description: "Provisions",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "registers": {
                                Description: "Registers",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "dual_registers": {
                                Description: "Dual Registers",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "hardware_id_type": {
                                Description: "HardwareId Type",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "allow_reboot": {
                                Description: "Allow Reboot",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "no_rebalance": {
                                Description: "No Rebalance",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "no_cloud_provisioning": {
                                Description: "No Cloud Provisioning",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                        "media_codecs": {
                                Description: "Media Codecs",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem: &amp;schema.Schema{
                                        Type:         schema.TypeString,
                                        ValidateFunc: validation.StringInSlice([]string{"audio/opus", "audio/pcmu", "audio/pcma", "audio/g729", "audio/g722"}, false),
                                },
                        },
                        "cdm": {
                                Description: "CDM",
                                Type:        schema.TypeBool,
                                Optional:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud Phone",

                CreateContext: gcloud.CreateWithPooledClient(createPhone),
                ReadContext:   gcloud.ReadWithPooledClient(readPhone),
                UpdateContext: gcloud.UpdateWithPooledClient(updatePhone),
                DeleteContext: gcloud.DeleteWithPooledClient(deletePhone),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the entity.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "state": {
                                Description:  "Indicates if the resource is active, inactive, or deleted. Valid values: active, inactive, deleted.",
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "active",
                                ValidateFunc: validation.StringInSlice([]string{"active", "inactive", "deleted"}, false),
                        },
                        "site_id": {
                                Description: "The site ID associated to the phone.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "phone_base_settings_id": {
                                Description: "Phone Base Settings ID.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "line_base_settings_id": {
                                Description: "Line Base Settings ID.",
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                        },
                        "phone_meta_base_id": {
                                Description: "Phone Meta Base ID.",
                                Type:        schema.TypeString,
                                Computed:    true,
                                Optional:    true,
                        },
                        "web_rtc_user_id": {
                                Description: "Web RTC User ID. This is necessary when creating a Web RTC phone. This user will be assigned to the phone after it is created.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "line_addresses": {
                                Description: "Ordered list of Line DIDs for standalone phones.  Each phone number must be in an E.164 phone number format.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Computed:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString, ValidateDiagFunc: gcloud.ValidatePhoneNumber},
                        },
                        "capabilities": {
                                Description: "Phone Capabilities.",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Computed:    true,
                                Elem:        phoneCapabilities,
                        },
                },
        }
}</span>

// PhoneExporter returns the resourceExporter object used to hold the genesyscloud_telephony_providers_edges_phone exporter's config
func PhoneExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getAllPhones),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "web_rtc_user_id":        {RefType: "genesyscloud_user"},
                        "site_id":                {RefType: "genesyscloud_telephony_providers_edges_site"},
                        "phone_base_settings_id": {RefType: "genesyscloud_telephony_providers_edges_phonebasesettings"},
                },
        }
}</span>

// DataSourcePhone registers the genesyscloud_telephony_providers_edges_phone data source
func DataSourcePhone() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Phone. Select a phone by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourcePhoneRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Phone name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package telephony_providers_edges_phone

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

type PhoneConfig struct {
        PhoneRes            string
        Name                string
        State               string
        SiteId              string
        PhoneBaseSettingsId string
        LineAddresses       []string
        WebRtcUserId        string
        Depends_on          string
}

func getPhoneFromResourceData(ctx context.Context, pp *phoneProxy, d *schema.ResourceData) (*platformclientv2.Phone, error) <span class="cov8" title="1">{
        phoneConfig := &amp;platformclientv2.Phone{
                Name:  platformclientv2.String(d.Get("name").(string)),
                State: platformclientv2.String(d.Get("state").(string)),
                Site:  gcloud.BuildSdkDomainEntityRef(d, "site_id"),
                PhoneBaseSettings: &amp;platformclientv2.Phonebasesettings{
                        Id: buildSdkPhoneBaseSettings(d, "phone_base_settings_id").Id,
                },
                Capabilities: buildSdkCapabilities(d),
        }

        // Line base settings and lines
        var err error
        lineBaseSettingsID := d.Get("line_base_settings_id").(string)
        if lineBaseSettingsID == "" </span><span class="cov8" title="1">{
                lineBaseSettingsID, err = getLineBaseSettingsID(ctx, pp, *phoneConfig.PhoneBaseSettings.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ailed to get line base settings for %s: %s", *phoneConfig.Name, err)
                }</span>
        }
        <span class="cov8" title="1">lineBaseSettings := &amp;platformclientv2.Domainentityref{Id: &amp;lineBaseSettingsID}
        lines, isStandalone := buildSdkLines(ctx, pp, d, lineBaseSettings)
        phoneConfig.LineBaseSettings = lineBaseSettings
        phoneConfig.Lines = lines

        // phone meta base
        phoneMetaBaseId, err := getPhoneMetaBaseId(ctx, pp, *phoneConfig.PhoneBaseSettings.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get phone meta base for %s: %s", *phoneConfig.Name, err)
        }</span>
        <span class="cov8" title="1">phoneMetaBase := &amp;platformclientv2.Domainentityref{
                Id: &amp;phoneMetaBaseId,
        }
        phoneConfig.PhoneMetaBase = phoneMetaBase

        if isStandalone </span><span class="cov8" title="1">{
                phoneConfig.Properties = &amp;map[string]interface{}{
                        "phone_standalone": &amp;map[string]interface{}{
                                "value": &amp;map[string]interface{}{
                                        "instance": true,
                                },
                        },
                }
        }</span>

        <span class="cov8" title="1">webRtcUserId := d.Get("web_rtc_user_id")
        if webRtcUserId != "" </span><span class="cov8" title="1">{
                phoneConfig.WebRtcUser = gcloud.BuildSdkDomainEntityRef(d, "web_rtc_user_id")
        }</span>

        <span class="cov8" title="1">return phoneConfig, nil</span>
}

func getLineBaseSettingsID(ctx context.Context, pp *phoneProxy, phoneBaseSettingsId string) (string, error) <span class="cov8" title="1">{
        phoneBase, err := pp.getPhoneBaseSetting(ctx, phoneBaseSettingsId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(*phoneBase.Lines) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return *(*phoneBase.Lines)[0].Id, nil</span>
}

func assignUserToWebRtcPhone(ctx context.Context, pp *phoneProxy, userId string) diag.Diagnostics <span class="cov8" title="1">{
        stationId := ""
        stationIsAssociated := false

        retryErr := gcloud.WithRetries(ctx, 60*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                station, retryable, err := pp.getStationOfUser(ctx, userId)
                if err != nil &amp;&amp; !retryable </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("error requesting stations: %s", err))
                }</span>
                <span class="cov8" title="1">if retryable </span><span class="cov8" title="1">{
                        return retry.RetryableError(fmt.Errorf("no stations found with userID %v", userId))
                }</span>

                <span class="cov8" title="1">stationId = *station.Id
                stationIsAssociated = *station.Status == "ASSOCIATED"

                return nil</span>
        })
        <span class="cov8" title="1">if retryErr != nil </span><span class="cov0" title="0">{
                return retryErr
        }</span>

        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                if stationIsAssociated </span><span class="cov8" title="1">{
                        log.Printf("Disassociating user from phone station %s", stationId)
                        if resp, err := pp.unassignUserFromStation(ctx, stationId); err != nil </span><span class="cov0" title="0">{
                                return resp, diag.Errorf("Error unassigning user from station %s: %v", stationId, err)
                        }</span>
                }

                <span class="cov8" title="1">resp, putErr := pp.assignUserToStation(ctx, userId, stationId)
                if putErr != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to assign user %v to the station %s: %s", userId, stationId, putErr)
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func buildSdkPhoneBaseSettings(d *schema.ResourceData, idAttr string) *platformclientv2.Phonebasesettings <span class="cov8" title="1">{
        idVal := d.Get(idAttr).(string)
        if idVal == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;platformclientv2.Phonebasesettings{Id: &amp;idVal}</span>
}

func getPhoneMetaBaseId(ctx context.Context, pp *phoneProxy, phoneBaseSettingsId string) (string, error) <span class="cov8" title="1">{
        phoneBase, err := pp.getPhoneBaseSetting(ctx, phoneBaseSettingsId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *phoneBase.PhoneMetaBase.Id, nil</span>
}

func flattenPhoneLines(lines *[]platformclientv2.Line) []string <span class="cov8" title="1">{
        if lines == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">lineAddressList := []string{}
        for i := 0; i &lt; len(*lines); i++ </span><span class="cov8" title="1">{
                line := (*lines)[i]
                did := ""
                if k := (*line.Properties)["station_identity_address"]; k != nil </span><span class="cov8" title="1">{
                        didI := k.(map[string]interface{})["value"].(map[string]interface{})["instance"]
                        if didI != nil </span><span class="cov8" title="1">{
                                did = didI.(string)
                        }</span>
                }

                <span class="cov8" title="1">if len(did) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">lineAddressList = append(lineAddressList, did)</span>
        }

        <span class="cov8" title="1">return lineAddressList</span>
}

func flattenPhoneCapabilities(capabilities *platformclientv2.Phonecapabilities) []interface{} <span class="cov8" title="1">{
        if capabilities == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">capabilitiesMap := make(map[string]interface{})
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "provisions", capabilities.Provisions)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "registers", capabilities.Registers)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "dual_registers", capabilities.DualRegisters)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "hardware_id_type", capabilities.HardwareIdType)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "allow_reboot", capabilities.AllowReboot)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "no_rebalance", capabilities.NoRebalance)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "no_cloud_provisioning", capabilities.NoCloudProvisioning)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "media_codecs", capabilities.MediaCodecs)
        resourcedata.SetMapValueIfNotNil(capabilitiesMap, "cdm", capabilities.Cdm)

        return []interface{}{capabilitiesMap}</span>
}

func buildSdkLines(ctx context.Context, pp *phoneProxy, d *schema.ResourceData, lineBaseSettings *platformclientv2.Domainentityref) (linesPtr *[]platformclientv2.Line, isStandAlone bool) <span class="cov8" title="1">{
        lines := []platformclientv2.Line{}
        isStandAlone = false

        lineAddresses, ok := d.GetOk("line_addresses")
        lineStringList := lists.InterfaceListToStrings(lineAddresses.([]interface{}))

        // If line_addresses is not provided, phone is not standalone
        if !ok || len(lineStringList) == 0 </span><span class="cov8" title="1">{
                lineName := "line_" + *lineBaseSettings.Id
                line := platformclientv2.Line{
                        Name:             &amp;lineName,
                        LineBaseSettings: lineBaseSettings,
                }

                // If this function is invoked on a phone create, the ID won't exist yet
                if d.Id() != "" </span><span class="cov8" title="1">{
                        lineId, err := getLineIdByPhoneId(ctx, pp, d.Id())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to retrieve ID for phone %s: %v", d.Id(), err)
                        }</span> else<span class="cov8" title="1"> {
                                line.Id = &amp;lineId
                        }</span>
                }

                <span class="cov8" title="1">lines = append(lines, line)

                linesPtr = &amp;lines
                return</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(lineStringList); i++ </span><span class="cov8" title="1">{
                lineName := "line_" + *lineBaseSettings.Id + "_" + strconv.Itoa(i+1)
                properties := map[string]interface{}{
                        "station_identity_address": &amp;map[string]interface{}{
                                "value": &amp;map[string]interface{}{
                                        "instance": (lineStringList)[i],
                                },
                        },
                }
                lines = append(lines, platformclientv2.Line{
                        Name:             &amp;lineName,
                        LineBaseSettings: lineBaseSettings,
                        Properties:       &amp;properties,
                })
        }</span>

        <span class="cov8" title="1">linesPtr = &amp;lines
        isStandAlone = true

        return</span>
}

func getLineIdByPhoneId(ctx context.Context, pp *phoneProxy, phoneId string) (string, error) <span class="cov8" title="1">{
        phone, _, err := pp.getPhoneById(ctx, phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if phone.Lines != nil &amp;&amp; len(*phone.Lines) &gt; 0 </span><span class="cov8" title="1">{
                return *(*phone.Lines)[0].Id, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("could not access line ID for phone %s", phoneId)</span>
}

func buildSdkCapabilities(d *schema.ResourceData) *platformclientv2.Phonecapabilities <span class="cov8" title="1">{
        if capabilities := d.Get("capabilities").([]interface{}); capabilities != nil </span><span class="cov8" title="1">{
                sdkPhoneCapabilities := platformclientv2.Phonecapabilities{}
                if len(capabilities) &gt; 0 </span><span class="cov8" title="1">{
                        if _, ok := capabilities[0].(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">capabilitiesMap := capabilities[0].(map[string]interface{})

                        sdkPhoneCapabilities = platformclientv2.Phonecapabilities{
                                Provisions:          platformclientv2.Bool(capabilitiesMap["provisions"].(bool)),
                                Registers:           platformclientv2.Bool(capabilitiesMap["registers"].(bool)),
                                DualRegisters:       platformclientv2.Bool(capabilitiesMap["dual_registers"].(bool)),
                                AllowReboot:         platformclientv2.Bool(capabilitiesMap["allow_reboot"].(bool)),
                                NoRebalance:         platformclientv2.Bool(capabilitiesMap["no_rebalance"].(bool)),
                                NoCloudProvisioning: platformclientv2.Bool(capabilitiesMap["no_cloud_provisioning"].(bool)),
                                Cdm:                 platformclientv2.Bool(capabilitiesMap["cdm"].(bool)),
                        }

                        // Hardware ID type
                        if checkHardwareIdType := capabilitiesMap["hardware_id_type"].(string); len(checkHardwareIdType) &gt; 0 </span><span class="cov8" title="1">{
                                sdkPhoneCapabilities.HardwareIdType = &amp;checkHardwareIdType
                        }</span>

                        // Media codecs
                        <span class="cov8" title="1">mediaCodecs := make([]string, 0)
                        if checkMediaCodecs := capabilitiesMap["media_codecs"].([]interface{}); len(checkMediaCodecs) &gt; 0 </span><span class="cov8" title="1">{
                                for _, codec := range checkMediaCodecs </span><span class="cov8" title="1">{
                                        mediaCodecs = append(mediaCodecs, fmt.Sprintf("%v", codec))
                                }</span>
                        }

                        <span class="cov8" title="1">sdkPhoneCapabilities.MediaCodecs = &amp;mediaCodecs</span>
                }
                <span class="cov8" title="1">return &amp;sdkPhoneCapabilities</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func GeneratePhoneResourceWithCustomAttrs(config *PhoneConfig, otherAttrs ...string) string <span class="cov8" title="1">{
        lineStrs := make([]string, len(config.LineAddresses))
        for i, val := range config.LineAddresses </span><span class="cov8" title="1">{
                lineStrs[i] = fmt.Sprintf("\"%s\"", val)
        }</span>

        <span class="cov8" title="1">webRtcUser := ""
        if len(config.WebRtcUserId) != 0 </span><span class="cov8" title="1">{
                webRtcUser = fmt.Sprintf(`web_rtc_user_id = %s`, config.WebRtcUserId)
        }</span>

        <span class="cov8" title="1">finalConfig := fmt.Sprintf(`resource "genesyscloud_telephony_providers_edges_phone" "%s" {
                name = "%s"
                state = "%s"
                site_id = %s
                phone_base_settings_id = %s
                line_addresses = [%s]
                depends_on=[%s]
                %s
                %s
        }
        `, config.PhoneRes,
                config.Name,
                config.State,
                config.SiteId,
                config.PhoneBaseSettingsId,
                strings.Join(lineStrs, ","),
                config.Depends_on,
                webRtcUser,
                strings.Join(otherAttrs, "\n"),
        )

        return finalConfig</span>
}

func TestVerifyWebRtcPhoneDestroyed(state *terraform.State) error <span class="cov8" title="1">{
        edgesAPI := platformclientv2.NewTelephonyProvidersEdgeApi()
        for _, rs := range state.RootModule().Resources </span><span class="cov8" title="1">{
                if rs.Type != "genesyscloud_telephony_providers_edges_phone" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">phone, resp, err := edgesAPI.GetTelephonyProvidersEdgesPhone(rs.Primary.ID)
                if phone != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("phone (%s) still exists", rs.Primary.ID)
                }</span> else<span class="cov8" title="1"> if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                        // Phone not found as expected
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Unexpected error
                        return fmt.Errorf("unexpected error: %s", err)
                }</span>
        }
        //Success. Phone destroyed
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package telephony_providers_edges_site

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceSiteRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := m.(*gcloud.ProviderMeta).ClientConfig
        sp := getSiteProxy(sdkConfig)

        name := d.Get("name").(string)
        managed := d.Get("managed").(bool)

        return gcloud.WithRetries(ctx, 15*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                siteId, retryable, err := sp.getSiteIdByName(ctx, name, managed)
                if err != nil </span><span class="cov0" title="0">{
                        if retryable </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to get site %s", name))
                        }</span>

                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error requesting site %s: %s", name, err))</span>
                }

                <span class="cov8" title="1">d.SetId(siteId)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package telephony_providers_edges_site

import (
        "context"
        "fmt"

        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

/*
The genesyscloud_telephony_providers_edges_site_proxy.go file contains the proxy structures and methods that interact
with the Genesys Cloud SDK. We use composition here for each function on the proxy so individual functions can be stubbed
out during testing.

Each proxy implementation:

1.  Should provide a private package level variable that holds a instance of a proxy class.
2.  A New... constructor function  to initialize the proxy object.  This constructor should only be used within
    the proxy.
3.  A get private constructor function that the classes in the package can be used to to retrieve
    the proxy.  This proxy should check to see if the package level proxy instance is nil and
    should initialize it, otherwise it should return the instance
4.  Type definitions for each function that will be used in the proxy.  We use composition here
    so that we can easily provide mocks for testing.
5.  A struct for the proxy that holds an attribute for each function type.
6.  Wrapper methods on each of the elements on the struct.
7.  Function implementations for each function type definition.

*/

// internalProxy holds a proxy instance that can be used throughout the package
var internalProxy *siteProxy

// Type definitions for each func on our proxy so we can easily mock them out later
type getAllManagedSitesFunc func(ctx context.Context, p *siteProxy) (*[]platformclientv2.Site, error)
type getAllUnmanagedSitesFunc func(ctx context.Context, p *siteProxy) (*[]platformclientv2.Site, error)
type createSiteFunc func(ctx context.Context, p *siteProxy, site *platformclientv2.Site) (*platformclientv2.Site, error)
type deleteSiteFunc func(ctx context.Context, p *siteProxy, siteId string) (*platformclientv2.APIResponse, error)
type getSiteByIdFunc func(ctx context.Context, p *siteProxy, siteId string) (site *platformclientv2.Site, resp *platformclientv2.APIResponse, err error)
type getSiteIdByNameFunc func(ctx context.Context, p *siteProxy, siteName string, managed bool) (siteId string, retryable bool, err error)
type updateSiteFunc func(ctx context.Context, p *siteProxy, siteId string, site *platformclientv2.Site) (*platformclientv2.Site, *platformclientv2.APIResponse, error)

type createSiteOutboundRouteFunc func(ctx context.Context, p *siteProxy, siteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error)
type getSiteOutboundRoutesFunc func(ctx context.Context, p *siteProxy, siteId string) (*[]platformclientv2.Outboundroutebase, error)
type updateSiteOutboundRouteFunc func(ctx context.Context, p *siteProxy, siteId string, outboundRouteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error)
type deleteSiteOutboundRouteFunc func(ctx context.Context, p *siteProxy, siteId string, outboundRouteId string) (*platformclientv2.APIResponse, error)

type getSiteNumberPlansFunc func(ctx context.Context, p *siteProxy, siteId string) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error)
type updateSiteNumberPlansFunc func(ctx context.Context, p *siteProxy, siteId string, numberPlans *[]platformclientv2.Numberplan) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error)

type getLocationFunc func(ctx context.Context, p *siteProxy, locationId string) (*platformclientv2.Locationdefinition, error)
type getTelephonyMediaregionsFunc func(ctx context.Context, p *siteProxy) (*platformclientv2.Mediaregions, error)
type setDefaultSiteFunc func(ctx context.Context, p *siteProxy, siteId string) error
type getDefaultSiteIdFunc func(ctx context.Context, p *siteProxy) (siteId string, err error)

// siteProxy contains all of the methods that call genesys cloud APIs.
type siteProxy struct {
        clientConfig    *platformclientv2.Configuration
        edgesApi        *platformclientv2.TelephonyProvidersEdgeApi
        locationsApi    *platformclientv2.LocationsApi
        telephonyApi    *platformclientv2.TelephonyApi
        organizationApi *platformclientv2.OrganizationApi

        getAllManagedSitesAttr   getAllManagedSitesFunc
        getAllUnmanagedSitesAttr getAllUnmanagedSitesFunc
        createSiteAttr           createSiteFunc
        deleteSiteAttr           deleteSiteFunc
        getSiteByIdAttr          getSiteByIdFunc
        getSiteIdByNameAttr      getSiteIdByNameFunc
        updateSiteAttr           updateSiteFunc

        createSiteOutboundRouteAttr createSiteOutboundRouteFunc
        getSiteOutboundRoutesAttr   getSiteOutboundRoutesFunc
        updateSiteOutboundRouteAttr updateSiteOutboundRouteFunc
        deleteSiteOutboundRouteAttr deleteSiteOutboundRouteFunc

        getSiteNumberPlansAttr    getSiteNumberPlansFunc
        updateSiteNumberPlansAttr updateSiteNumberPlansFunc

        getLocationAttr              getLocationFunc
        getTelephonyMediaregionsAttr getTelephonyMediaregionsFunc
        setDefaultSiteAttr           setDefaultSiteFunc
        getDefaultSiteIdAttr         getDefaultSiteIdFunc
}

// newSiteProxy initializes the Site proxy with all of the data needed to communicate with Genesys Cloud
func newSiteProxy(clientConfig *platformclientv2.Configuration) *siteProxy <span class="cov8" title="1">{
        edgesApi := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(clientConfig)
        locationsApi := platformclientv2.NewLocationsApiWithConfig(clientConfig)
        telephonyApi := platformclientv2.NewTelephonyApiWithConfig(clientConfig)
        organizationApi := platformclientv2.NewOrganizationApiWithConfig(clientConfig)

        return &amp;siteProxy{
                clientConfig:    clientConfig,
                edgesApi:        edgesApi,
                locationsApi:    locationsApi,
                telephonyApi:    telephonyApi,
                organizationApi: organizationApi,

                getAllManagedSitesAttr:   getAllManagedSitesFn,
                getAllUnmanagedSitesAttr: getAllUnmanagedSitesFn,
                createSiteAttr:           createSiteFn,
                deleteSiteAttr:           deleteSiteFn,
                getSiteByIdAttr:          getSiteByIdFn,
                getSiteIdByNameAttr:      getSiteIdByNameFn,
                updateSiteAttr:           updateSiteFn,

                createSiteOutboundRouteAttr: createSiteOutboundRouteFn,
                getSiteOutboundRoutesAttr:   getSiteOutboundRoutesFn,
                updateSiteOutboundRouteAttr: updateSiteOutboundRouteFn,
                deleteSiteOutboundRouteAttr: deleteSiteOutboundRouteFn,

                getSiteNumberPlansAttr:    getSiteNumberPlansFn,
                updateSiteNumberPlansAttr: updateSiteNumberPlansFn,

                getLocationAttr:              getLocationFn,
                getTelephonyMediaregionsAttr: getTelephonyMediaregionsFn,
                setDefaultSiteAttr:           setDefaultSiteFn,
                getDefaultSiteIdAttr:         getDefaultSiteIdFn,
        }
}</span>

// getSiteProxy acts as a singleton for the internalProxy.  It also ensures
// that we can still proxy our tests by directly setting internalProxy package variable
func getSiteProxy(clientConfig *platformclientv2.Configuration) *siteProxy <span class="cov8" title="1">{
        if internalProxy == nil </span><span class="cov8" title="1">{
                internalProxy = newSiteProxy(clientConfig)
        }</span>
        <span class="cov8" title="1">return internalProxy</span>
}

// getAllManagedSitesFunc retrieves all managed Genesys Cloud Sites
func (p *siteProxy) getAllManagedSites(ctx context.Context) (*[]platformclientv2.Site, error) <span class="cov0" title="0">{
        return p.getAllManagedSitesAttr(ctx, p)
}</span>

// getAllUnmanagedSitesFunc retrieves all unmanaged Genesys Cloud Sites
func (p *siteProxy) getAllUnmanagedSites(ctx context.Context) (*[]platformclientv2.Site, error) <span class="cov0" title="0">{
        return p.getAllUnmanagedSitesAttr(ctx, p)
}</span>

// createSiteFunc creates a Genesys Cloud Site
func (p *siteProxy) createSite(ctx context.Context, site *platformclientv2.Site) (*platformclientv2.Site, error) <span class="cov8" title="1">{
        return p.createSiteAttr(ctx, p, site)
}</span>

// deleteSiteFunc deletes a Genesys Cloud Site by ID
func (p *siteProxy) deleteSite(ctx context.Context, siteId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.deleteSiteAttr(ctx, p, siteId)
}</span>

// getSiteByIdFunc returns a single Genesys Cloud Site by Id
func (p *siteProxy) getSiteById(ctx context.Context, siteId string) (site *platformclientv2.Site, resp *platformclientv2.APIResponse, err error) <span class="cov8" title="1">{
        return p.getSiteByIdAttr(ctx, p, siteId)
}</span>

// getSiteIdByNameFunc returns a single Genesys Cloud Site by Name
func (p *siteProxy) getSiteIdByName(ctx context.Context, siteName string, managed bool) (siteId string, retryable bool, err error) <span class="cov8" title="1">{
        return p.getSiteIdByNameAttr(ctx, p, siteName, managed)
}</span>

// updateSiteFunc updates a Genesys Cloud Site
func (p *siteProxy) updateSite(ctx context.Context, siteId string, site *platformclientv2.Site) (*platformclientv2.Site, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.updateSiteAttr(ctx, p, siteId, site)
}</span>

// createSiteOutboundRouteFunc creates an Outbound Route for a Genesys Cloud Site
func (p *siteProxy) createSiteOutboundRoute(ctx context.Context, siteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        return p.createSiteOutboundRouteAttr(ctx, p, siteId, outboundRoute)
}</span>

// getSiteByIdFunc returns a single Outbound Route by Id
func (p *siteProxy) getSiteOutboundRoutes(ctx context.Context, siteId string) (*[]platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        return p.getSiteOutboundRoutesAttr(ctx, p, siteId)
}</span>

// updateSiteFunc updates a Genesys Cloud Outbound Route for a Genesys Cloud Site
func (p *siteProxy) updateSiteOutboundRoute(ctx context.Context, siteId string, outboundRouteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        return p.updateSiteOutboundRouteAttr(ctx, p, siteId, outboundRouteId, outboundRoute)
}</span>

// deleteSiteFunc deletes a Genesys Cloud Outbound Route by Id for a Genesys Cloud Site
func (p *siteProxy) deleteSiteOutboundRoute(ctx context.Context, siteId string, outboundRouteId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.deleteSiteOutboundRouteAttr(ctx, p, siteId, outboundRouteId)
}</span>

// getSiteNumberPlansFunc retrieves all Number Plans of a Genesys Cloud Sites
func (p *siteProxy) getSiteNumberPlans(ctx context.Context, siteId string) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.getSiteNumberPlansAttr(ctx, p, siteId)
}</span>

// updateSiteNumberPlansFunc updates the Number Plans for a Genesys Cloud Site
func (p *siteProxy) updateSiteNumberPlans(ctx context.Context, siteId string, numberPlans *[]platformclientv2.Numberplan) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        return p.updateSiteNumberPlansAttr(ctx, p, siteId, numberPlans)
}</span>

// getLocation retrieves a Genesys Cloud Location by Id
func (p *siteProxy) getLocation(ctx context.Context, locationId string) (*platformclientv2.Locationdefinition, error) <span class="cov8" title="1">{
        return p.getLocationAttr(ctx, p, locationId)
}</span>

// getTelephonyMediaregions retrieves the Genesys Cloud media regions
func (p *siteProxy) getTelephonyMediaregions(ctx context.Context) (*platformclientv2.Mediaregions, error) <span class="cov8" title="1">{
        return p.getTelephonyMediaregionsAttr(ctx, p)
}</span>

// setDefaultSite sets a Genesys Cloud Site as the default site for the org
func (p *siteProxy) setDefaultSite(ctx context.Context, siteId string) error <span class="cov8" title="1">{
        return p.setDefaultSiteAttr(ctx, p, siteId)
}</span>

// getDefaultSiteId gets the default Site for the Genesys Cloud org
func (p *siteProxy) getDefaultSiteId(ctx context.Context) (siteId string, err error) <span class="cov8" title="1">{
        return p.getDefaultSiteIdAttr(ctx, p)
}</span>

// getAllManagedSitesFn is an implementation function for retrieving all Genesys Cloud Outbound managed Sites
func getAllManagedSitesFn(ctx context.Context, p *siteProxy) (*[]platformclientv2.Site, error) <span class="cov0" title="0">{
        var allManagedSites []platformclientv2.Site

        const pageSize = 100
        sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, 1, "", "", "", "", true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get only sites that are not 'deleted'
        <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                if site.State != nil &amp;&amp; *site.State != "deleted" </span><span class="cov0" title="0">{
                        allManagedSites = append(allManagedSites, site)
                }</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *sites.PageCount; pageNum++ </span><span class="cov0" title="0">{
                sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, pageNum, "", "", "", "", true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if sites.Entities == nil || len(*sites.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Get only sites that are not 'deleted'
                <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                        if site.State != nil &amp;&amp; *site.State != "deleted" </span><span class="cov0" title="0">{
                                allManagedSites = append(allManagedSites, site)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;allManagedSites, nil</span>
}

// getAllUnmanagedSitesFn is an implementation function for retrieving all Genesys Cloud Outbound unmanaged Sites
func getAllUnmanagedSitesFn(ctx context.Context, p *siteProxy) (*[]platformclientv2.Site, error) <span class="cov0" title="0">{
        var allUnManagedSites []platformclientv2.Site

        const pageSize = 100
        sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, 1, "", "", "", "", false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get only sites that are not 'deleted'
        <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                if site.State != nil &amp;&amp; *site.State != "deleted" </span><span class="cov0" title="0">{
                        allUnManagedSites = append(allUnManagedSites, site)
                }</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *sites.PageCount; pageNum++ </span><span class="cov0" title="0">{
                sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, pageNum, "", "", "", "", false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if sites.Entities == nil || len(*sites.Entities) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Get only sites that are not 'deleted'
                <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                        if site.State != nil &amp;&amp; *site.State != "deleted" </span><span class="cov0" title="0">{
                                allUnManagedSites = append(allUnManagedSites, site)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;allUnManagedSites, nil</span>
}

// createSiteFn is an implementation function for creating a Genesys Cloud Site
func createSiteFn(ctx context.Context, p *siteProxy, siteReq *platformclientv2.Site) (*platformclientv2.Site, error) <span class="cov8" title="1">{
        site, _, err := p.edgesApi.PostTelephonyProvidersEdgesSites(*siteReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return site, nil</span>
}

// deleteSiteFn is an implementation function for deleting a Genesys Cloud Site
func deleteSiteFn(ctx context.Context, p *siteProxy, siteId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        resp, err := p.edgesApi.DeleteTelephonyProvidersEdgesSite(siteId)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// getSiteByIdFn is an implementation function for retrieving a Genesys Cloud Site by id
func getSiteByIdFn(ctx context.Context, p *siteProxy, siteId string) (*platformclientv2.Site, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        site, resp, err := p.edgesApi.GetTelephonyProvidersEdgesSite(siteId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return site, resp, nil</span>
}

// getSiteIdByNameFn is an implementation function for retrieving a Genesys Cloud Site by name
func getSiteIdByNameFn(ctx context.Context, p *siteProxy, siteName string, managed bool) (string, bool, error) <span class="cov8" title="1">{
        const pageSize = 100
        sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, 1, "", "", siteName, "", managed)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov8" title="1">if sites.Entities == nil || len(*sites.Entities) == 0 </span><span class="cov0" title="0">{
                return "", true, fmt.Errorf("no sites found with name %s", siteName)
        }</span>
        <span class="cov8" title="1">for _, site := range *sites.Entities </span><span class="cov8" title="1">{
                if (site.Name != nil &amp;&amp; *site.Name == siteName) &amp;&amp; (site.State != nil &amp;&amp; *site.State != "deleted") </span><span class="cov8" title="1">{
                        return *site.Id, false, nil
                }</span>
        }

        <span class="cov0" title="0">for pageNum := 2; pageNum &lt;= *sites.PageCount; pageNum++ </span><span class="cov0" title="0">{
                sites, _, err := p.edgesApi.GetTelephonyProvidersEdgesSites(pageSize, pageNum, "", "", siteName, "", managed)
                if err != nil </span><span class="cov0" title="0">{
                        return "", false, err
                }</span>

                <span class="cov0" title="0">if sites.Entities == nil || len(*sites.Entities) == 0 </span><span class="cov0" title="0">{
                        return "", true, fmt.Errorf("no sites found with name %s", siteName)
                }</span>

                <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                        if (site.Name != nil &amp;&amp; *site.Name == siteName) &amp;&amp; (site.State != nil &amp;&amp; *site.State != "deleted") </span><span class="cov0" title="0">{
                                return *site.Id, false, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", true, fmt.Errorf("no sites found with name %s", siteName)</span>
}

// updateSiteFn is an implementation function for updating a Genesys Cloud Site
func updateSiteFn(ctx context.Context, p *siteProxy, siteId string, site *platformclientv2.Site) (*platformclientv2.Site, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        updatedSite, resp, err := p.edgesApi.PutTelephonyProvidersEdgesSite(siteId, *site)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return updatedSite, resp, nil</span>
}

// createSiteOutboundRouteFn is an implementation function for creating an outbound route for a Genesys Cloud Site
func createSiteOutboundRouteFn(ctx context.Context, p *siteProxy, siteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        obr, _, err := p.edgesApi.PostTelephonyProvidersEdgesSiteOutboundroutes(siteId, *outboundRoute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return obr, nil</span>
}

// getSiteOutboundRoutesFn is an implementation function for getting an outbound route for a Genesys Cloud Site
func getSiteOutboundRoutesFn(ctx context.Context, p *siteProxy, siteId string) (*[]platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        var allOutboundRoutes = []platformclientv2.Outboundroutebase{}
        const pageSize = 100
        outboundRoutes, _, err := p.edgesApi.GetTelephonyProvidersEdgesSiteOutboundroutes(siteId, pageSize, 1, "", "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">allOutboundRoutes = append(allOutboundRoutes, *outboundRoutes.Entities...)

        for pageNum := 2; pageNum &lt;= *outboundRoutes.PageCount; pageNum++ </span><span class="cov0" title="0">{
                outboundRoutes, _, err := p.edgesApi.GetTelephonyProvidersEdgesSiteOutboundroutes(siteId, pageSize, pageNum, "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if outboundRoutes.Entities == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">allOutboundRoutes = append(allOutboundRoutes, *outboundRoutes.Entities...)</span>
        }

        <span class="cov8" title="1">return &amp;allOutboundRoutes, nil</span>
}

// updateSiteOutboundRouteFn is an implementation function for updating an outbound route for a Genesys Cloud Site
func updateSiteOutboundRouteFn(ctx context.Context, p *siteProxy, siteId string, outboundRouteId string, outboundRoute *platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, error) <span class="cov8" title="1">{
        obrs, _, err := p.edgesApi.PutTelephonyProvidersEdgesSiteOutboundroute(siteId, outboundRouteId, *outboundRoute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return obrs, nil</span>
}

// deleteSiteOutboundRouteFn is an implementation function for deleting an outbound route for a Genesys Cloud Site
func deleteSiteOutboundRouteFn(ctx context.Context, p *siteProxy, siteId string, outboundRouteId string) (*platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        resp, err := p.edgesApi.DeleteTelephonyProvidersEdgesSiteOutboundroute(siteId, outboundRouteId)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// getSiteNumberPlansFn is an implementation function for retrieving number plans of a Genesys Cloud Site
func getSiteNumberPlansFn(ctx context.Context, p *siteProxy, siteId string) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        numberPlans, resp, err := p.edgesApi.GetTelephonyProvidersEdgesSiteNumberplans(siteId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return &amp;numberPlans, resp, nil</span>
}

// updateSiteNumberPlansFn is an implementation function for updating number plans of a Genesys Cloud Site
func updateSiteNumberPlansFn(ctx context.Context, p *siteProxy, siteId string, numberPlansUpdate *[]platformclientv2.Numberplan) (*[]platformclientv2.Numberplan, *platformclientv2.APIResponse, error) <span class="cov8" title="1">{
        numberPlans, resp, err := p.edgesApi.PutTelephonyProvidersEdgesSiteNumberplans(siteId, *numberPlansUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        <span class="cov8" title="1">return &amp;numberPlans, resp, nil</span>
}

// getLocationFn is an implementation function for retrieving a Genesys Cloud Location
func getLocationFn(ctx context.Context, p *siteProxy, locationId string) (*platformclientv2.Locationdefinition, error) <span class="cov8" title="1">{
        location, _, err := p.locationsApi.GetLocation(locationId, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if location.EmergencyNumber == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("location with id %v does not have an emergency number", locationId)
        }</span>

        <span class="cov8" title="1">return location, nil</span>
}

// getTelephonyMediaregionsFn is an implementation function for retrieving a Genesys Cloud Media Regions
func getTelephonyMediaregionsFn(ctx context.Context, p *siteProxy) (*platformclientv2.Mediaregions, error) <span class="cov8" title="1">{
        telephonyRegions, _, err := p.telephonyApi.GetTelephonyMediaregions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return telephonyRegions, nil</span>
}

// setDefaultSiteFn is an implementation function for setting the default Site of a Genesys Cloud org
func setDefaultSiteFn(ctx context.Context, p *siteProxy, siteId string) error <span class="cov8" title="1">{
        org, _, err := p.organizationApi.GetOrganizationsMe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update org details
        <span class="cov8" title="1">*org.DefaultSiteId = siteId

        _, _, err = p.organizationApi.PutOrganizationsMe(*org)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error on setting default site. Make sure only one resource has the `set_as_default_site` set to true. %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getDefaultSiteIdFn is an implementation function for getting the default Site of a Genesys Cloud org
func getDefaultSiteIdFn(ctx context.Context, p *siteProxy) (string, error) <span class="cov8" title="1">{
        org, _, err := p.organizationApi.GetOrganizationsMe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *org.DefaultSiteId, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package telephony_providers_edges_site

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "terraform-provider-genesyscloud/genesyscloud/consistency_checker"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

func getSites(ctx context.Context, sdkConfig *platformclientv2.Configuration) (resourceExporter.ResourceIDMetaMap, diag.Diagnostics) <span class="cov0" title="0">{
        resources := make(resourceExporter.ResourceIDMetaMap)
        sp := getSiteProxy(sdkConfig)

        unmanagedSites, err := sp.getAllUnmanagedSites(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">for _, unmanagedSite := range *unmanagedSites </span><span class="cov0" title="0">{
                resources[*unmanagedSite.Id] = &amp;resourceExporter.ResourceMeta{Name: *unmanagedSite.Name}
        }</span>

        <span class="cov0" title="0">managedSites, err := sp.getAllManagedSites(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">for _, managedSite := range *managedSites </span><span class="cov0" title="0">{
                resources[*managedSite.Id] = &amp;resourceExporter.ResourceMeta{Name: *managedSite.Name}
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

func createSite(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        sp := getSiteProxy(sdkConfig)

        siteReq := &amp;platformclientv2.Site{
                Name:                        platformclientv2.String(d.Get("name").(string)),
                CallerId:                    platformclientv2.String(d.Get("caller_id").(string)),
                CallerName:                  platformclientv2.String(d.Get("caller_name").(string)),
                MediaModel:                  platformclientv2.String(d.Get("media_model").(string)),
                Description:                 platformclientv2.String(d.Get("description").(string)),
                MediaRegionsUseLatencyBased: platformclientv2.Bool(d.Get("media_regions_use_latency_based").(bool)),
        }

        edgeAutoUpdateConfig, err := buildSdkEdgeAutoUpdateConfig(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">mediaRegions := lists.BuildSdkStringListFromInterfaceArray(d, "media_regions")

        locationId := d.Get("location_id").(string)
        location, err := sp.getLocation(ctx, locationId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">err = validateMediaRegions(ctx, sp, mediaRegions)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">siteReq.Location = &amp;platformclientv2.Locationdefinition{
                Id:              platformclientv2.String(locationId),
                EmergencyNumber: location.EmergencyNumber,
        }

        if edgeAutoUpdateConfig != nil </span><span class="cov0" title="0">{
                siteReq.EdgeAutoUpdateConfig = edgeAutoUpdateConfig
        }</span>

        <span class="cov8" title="1">if mediaRegions != nil </span><span class="cov8" title="1">{
                siteReq.MediaRegions = mediaRegions
        }</span>

        <span class="cov8" title="1">log.Printf("Creating site %s", *siteReq.Name)
        site, err := sp.createSite(ctx, siteReq)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">d.SetId(*site.Id)

        log.Printf("Creating updating site with primary/secondary:  %s", *site.Id)
        diagErr := updatePrimarySecondarySites(ctx, sp, d, *site.Id)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">diagErr = updateSiteNumberPlans(ctx, sp, d)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">diagErr = gcloud.WithRetries(ctx, 60*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                diagErr = updateSiteOutboundRoutes(ctx, sp, d)
                if diagErr != nil </span><span class="cov0" title="0">{
                        return retry.RetryableError(fmt.Errorf(fmt.Sprintf("%v", diagErr), d.Id()))
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">log.Printf("Created site %s", *site.Id)

        // Default site
        if d.Get("set_as_default_site").(bool) </span><span class="cov8" title="1">{
                log.Printf("Setting default site to %s", *site.Id)
                err := sp.setDefaultSite(ctx, *site.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("unable to set default site to %s. err: %v", *site.Id, err)
                }</span>
        }

        <span class="cov8" title="1">return readSite(ctx, d, meta)</span>
}

func readSite(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        sp := getSiteProxy(sdkConfig)

        log.Printf("Reading site %s", d.Id())
        return gcloud.WithRetriesForRead(ctx, d, func() *retry.RetryError </span><span class="cov8" title="1">{
                currentSite, resp, err := sp.getSiteById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                return retry.RetryableError(fmt.Errorf("failed to read site %s: %s", d.Id(), err))
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read site %s: %s", d.Id(), err))</span>
                }

                <span class="cov8" title="1">cc := consistency_checker.NewConsistencyCheck(ctx, d, meta, ResourceSite())
                d.Set("name", *currentSite.Name)
                d.Set("location_id", nil)
                if currentSite.Location != nil </span><span class="cov8" title="1">{
                        d.Set("location_id", *currentSite.Location.Id)
                }</span>
                <span class="cov8" title="1">d.Set("media_model", *currentSite.MediaModel)
                d.Set("media_regions_use_latency_based", *currentSite.MediaRegionsUseLatencyBased)

                resourcedata.SetNillableValue(d, "description", currentSite.Description)
                resourcedata.SetNillableValueWithInterfaceArrayWithFunc(d, "edge_auto_update_config", currentSite.EdgeAutoUpdateConfig, flattenSdkEdgeAutoUpdateConfig)
                resourcedata.SetNillableValue(d, "media_regions", currentSite.MediaRegions)

                d.Set("caller_id", currentSite.CallerId)
                d.Set("caller_name", currentSite.CallerName)

                if currentSite.PrimarySites != nil </span><span class="cov8" title="1">{
                        d.Set("primary_sites", gcloud.SdkDomainEntityRefArrToList(*currentSite.PrimarySites))
                }</span>

                <span class="cov8" title="1">if currentSite.SecondarySites != nil </span><span class="cov8" title="1">{
                        d.Set("secondary_sites", gcloud.SdkDomainEntityRefArrToList(*currentSite.SecondarySites))
                }</span>

                <span class="cov8" title="1">if retryErr := readSiteNumberPlans(ctx, sp, d); retryErr != nil </span><span class="cov0" title="0">{
                        return retryErr
                }</span>

                <span class="cov8" title="1">if retryErr := readSiteOutboundRoutes(ctx, sp, d); retryErr != nil </span><span class="cov0" title="0">{
                        return retryErr
                }</span>

                <span class="cov8" title="1">defaultSiteId, err := sp.getDefaultSiteId(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return retry.NonRetryableError(fmt.Errorf("failed to get default site id: %v", err))
                }</span>
                <span class="cov8" title="1">d.Set("set_as_default_site", defaultSiteId == *currentSite.Id)

                log.Printf("Read site %s %s", d.Id(), *currentSite.Name)
                return cc.CheckState()</span>
        })
}

func updateSite(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        sp := getSiteProxy(sdkConfig)

        site := &amp;platformclientv2.Site{
                Name:                        platformclientv2.String(d.Get("name").(string)),
                CallerId:                    platformclientv2.String(d.Get("caller_id").(string)),
                CallerName:                  platformclientv2.String(d.Get("caller_name").(string)),
                MediaModel:                  platformclientv2.String(d.Get("media_model").(string)),
                Description:                 platformclientv2.String(d.Get("description").(string)),
                MediaRegionsUseLatencyBased: platformclientv2.Bool(d.Get("media_regions_use_latency_based").(bool)),
        }

        locationId := d.Get("location_id").(string)
        edgeAutoUpdateConfig, err := buildSdkEdgeAutoUpdateConfig(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">primarySites := lists.InterfaceListToStrings(d.Get("primary_sites").([]interface{}))
        secondarySites := lists.InterfaceListToStrings(d.Get("secondary_sites").([]interface{}))

        mediaRegions := lists.BuildSdkStringListFromInterfaceArray(d, "media_regions")

        location, err := sp.getLocation(ctx, locationId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov8" title="1">site.Location = &amp;platformclientv2.Locationdefinition{
                Id:              &amp;locationId,
                EmergencyNumber: location.EmergencyNumber,
        }

        err = validateMediaRegions(ctx, sp, mediaRegions)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov8" title="1">if edgeAutoUpdateConfig != nil </span><span class="cov8" title="1">{
                site.EdgeAutoUpdateConfig = edgeAutoUpdateConfig
        }</span>

        <span class="cov8" title="1">if mediaRegions != nil </span><span class="cov8" title="1">{
                site.MediaRegions = mediaRegions
        }</span>

        <span class="cov8" title="1">if len(primarySites) &gt; 0 </span><span class="cov8" title="1">{
                site.PrimarySites = gcloud.BuildSdkDomainEntityRefArr(d, "primary_sites")
        }</span>

        <span class="cov8" title="1">if len(secondarySites) &gt; 0 </span><span class="cov8" title="1">{
                site.SecondarySites = gcloud.BuildSdkDomainEntityRefArr(d, "secondary_sites")
        }</span>

        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsVersionMismatch, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                // Get current site version
                currentSite, resp, err := sp.getSiteById(ctx, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to read site %s: %s", d.Id(), err)
                }</span>
                <span class="cov8" title="1">site.Version = currentSite.Version

                log.Printf("Updating site %s", *site.Name)
                site, resp, err = sp.updateSite(ctx, d.Id(), site)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, diag.Errorf("Failed to update site %s: %s", *site.Name, err)
                }</span>

                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">diagErr = updateSiteNumberPlans(ctx, sp, d)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">diagErr = updateSiteOutboundRoutes(ctx, sp, d)
        if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>

        <span class="cov8" title="1">if d.Get("set_as_default_site").(bool) </span><span class="cov0" title="0">{
                log.Printf("Setting default site to %s", *site.Id)
                err := sp.setDefaultSite(ctx, *site.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.Errorf("unable to set default site to %s. err: %v", *site.Id, err)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Updated site %s", *site.Id)
        time.Sleep(5 * time.Second)
        return readSite(ctx, d, meta)</span>
}

func deleteSite(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics <span class="cov8" title="1">{
        sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
        sp := getSiteProxy(sdkConfig)

        log.Printf("Deleting site")
        resp, err := sp.deleteSite(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                        log.Printf("Site already deleted %s", d.Id())
                        return nil
                }</span>
                <span class="cov0" title="0">return diag.Errorf("failed to delete site: %s %s", d.Id(), err)</span>
        }

        <span class="cov8" title="1">return gcloud.WithRetries(ctx, 30*time.Second, func() *retry.RetryError </span><span class="cov8" title="1">{
                site, resp, err := sp.getSiteById(ctx, d.Id())
                if err != nil </span><span class="cov8" title="1">{
                        if gcloud.IsStatus404(resp) </span><span class="cov8" title="1">{
                                // Site deleted
                                log.Printf("Deleted site %s", d.Id())
                                // Need to sleep here because if terraform deletes the dependent location straight away
                                // the API will think it's still in use
                                time.Sleep(8 * time.Second)
                                return nil
                        }</span>
                        <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("error deleting site %s: %s", d.Id(), err))</span>
                }

                <span class="cov0" title="0">if site.State != nil &amp;&amp; *site.State == "deleted" </span><span class="cov0" title="0">{
                        // Site deleted
                        log.Printf("Deleted site %s", d.Id())
                        // Need to sleep here because if terraform deletes the dependent location straight away
                        // the API will think it's still in use
                        time.Sleep(8 * time.Second)
                        return nil
                }</span>

                <span class="cov0" title="0">return retry.RetryableError(fmt.Errorf("site %s still exists", d.Id()))</span>
        })
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package telephony_providers_edges_site

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        resourceExporter "terraform-provider-genesyscloud/genesyscloud/resource_exporter"
        registrar "terraform-provider-genesyscloud/genesyscloud/resource_register"
)

/*
resource_genesyscloud_telephony_providers_edges_site_schema.go should hold four types of functions within it:

1.  The registration code that registers the Datasource, Resource and Exporter for the package.
2.  The resource schema definitions for the telephony_providers_edges_site resource.
3.  The datasource schema definitions for the telephony_providers_edges_site datasource.
4.  The resource exporter configuration for the telephony_providers_edges_site exporter.
*/
const resourceName = "genesyscloud_telephony_providers_edges_site"

var (
        // This is outside the ResourceSite because it is used in a utility function.
        outboundRouteSchema = &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the entity.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "description": {
                                Description: "The resource's description.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "classification_types": {
                                Description: "Used to classify this outbound route.",
                                Type:        schema.TypeList,
                                Required:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "enabled": {
                                Description: "Enable or disable the outbound route",
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                        },
                        "distribution": {
                                Description:  "Valid values: SEQUENTIAL, RANDOM.",
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "SEQUENTIAL",
                                ValidateFunc: validation.StringInSlice([]string{"SEQUENTIAL", "RANDOM"}, false),
                        },
                        "external_trunk_base_ids": {
                                Description: "Trunk base settings of trunkType \"EXTERNAL\". This base must also be set on an edge logical interface for correct routing. The order of the IDs determines the distribution if \"distribution\" is set to \"SEQUENTIAL\"",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                },
        }
)

// SetRegistrar registers all of the resources, datasources and exporters in the package
func SetRegistrar(l registrar.Registrar) <span class="cov0" title="0">{
        l.RegisterDataSource(resourceName, DataSourceSite())
        l.RegisterResource(resourceName, ResourceSite())
        l.RegisterExporter(resourceName, SiteExporter())
}</span>

// ResourceSite registers the genesyscloud_telephony_providers_edges_site resource with Terraform
func ResourceSite() *schema.Resource <span class="cov8" title="1">{
        edgeAutoUpdateConfigSchema := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "time_zone": {
                                Description: "The timezone of the window in which any updates to the edges assigned to the site can be applied. The minimum size of the window is 2 hours.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "rrule": {
                                Description: "The recurrence rule for updating the Edges assigned to the site. The only supported frequencies are daily and weekly. Weekly frequencies require a day list with at least oneday specified. All other configurations are not supported.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "start": {
                                Description: "Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "end": {
                                Description: "Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }

        numberPlansSchema := &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the entity.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "match_type": {
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"digitLength", "e164NumberList", "interCountryCode", "intraCountryCode", "numberList", "regex"}, false),
                        },
                        "normalized_format": {
                                Description: "Use regular expression capture groups to build the normalized number",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "match_format": {
                                Description: "Use regular expression capture groups to build the normalized number",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "numbers": {
                                Description: "Numbers must be 2-9 digits long. Numbers within ranges must be the same length. (e.g. 888, 888-999, 55555-77777, 800).",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "start": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "end": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "digit_length": {
                                Description: "Allowed values are between 1-20 digits.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "start": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "end": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "classification": {
                                Description: "Used to classify this number plan",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                },
        }

        return &amp;schema.Resource{
                Description: "Genesys Cloud Site",

                CreateContext: gcloud.CreateWithPooledClient(createSite),
                ReadContext:   gcloud.ReadWithPooledClient(readSite),
                UpdateContext: gcloud.UpdateWithPooledClient(updateSite),
                DeleteContext: gcloud.DeleteWithPooledClient(deleteSite),
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "The name of the entity.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "description": {
                                Description: "The resource's description.",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "location_id": {
                                Description: "Site location ID",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "media_model": {
                                Description:  "Media model for the site Valid Values: Premises, Cloud. Changing the media_model attribute will cause the site object to be dropped and created with a new ID.",
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"Premises", "Cloud"}, false),
                                ForceNew:     true,
                        },
                        "media_regions_use_latency_based": {
                                Description: "Latency based on media region",
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                        },
                        "media_regions": {
                                Description: "The ordered list of AWS regions through which media can stream. A full list of available media regions can be found at the GET /api/v2/telephony/mediaregions endpoint",
                                Type:        schema.TypeList, //This has to be a list because it must be ordered
                                Optional:    true,
                                Computed:    true, //This needs to be a computed field because the sites API automatically adds the home region to whatever regions you add add.
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "caller_id": {
                                Description:      "The caller ID value for the site. The callerID must be a valid E.164 formatted phone number",
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: gcloud.ValidatePhoneNumber,
                        },
                        "caller_name": {
                                Description: "The caller name for the site",
                                Type:        schema.TypeString,
                                Optional:    true,
                        },
                        "edge_auto_update_config": {
                                Description: "Recurrence rule, time zone, and start/end settings for automatic edge updates for this site",
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Elem:        edgeAutoUpdateConfigSchema,
                        },
                        "number_plans": {
                                Description: "Number plans for the site. The order of the plans in the resource file determines the priority of the plans. Specifying number plans will not result in the default plans being overwritten.",
                                Type:        schema.TypeList,
                                Optional:    true,
                                Computed:    true,
                                Elem:        numberPlansSchema,
                        },
                        "outbound_routes": {
                                Description: "Outbound Routes for the site. The default outbound route will be deleted if routes are specified",
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Computed:    true,
                                ConfigMode:  schema.SchemaConfigModeAttr,
                                Elem:        outboundRouteSchema,
                        },
                        "primary_sites": {
                                Description: `Used for primary phone edge assignment on physical edges only.  List of primary sites the phones can be assigned to. If no primary_sites are defined, the site id for this site will be used as the primary site id.`,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "secondary_sites": {
                                Description: `Used for secondary phone edge assignment on physical edges only.  List of secondary sites the phones can be assigned to.  If no primary_sites or secondary_sites are defined then the current site will defined as primary and secondary. `,
                                Optional:    true,
                                Computed:    true,
                                Type:        schema.TypeList,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "set_as_default_site": {
                                Description: `Set this site as the default site for the organization. Only one genesyscloud_telephony_providers_edges_site resource should be set as the default.`,
                                Optional:    true,
                                Default:     false,
                                Type:        schema.TypeBool,
                        },
                },
                CustomizeDiff: customizeSiteDiff,
        }
}</span>

// SiteExporter returns the resourceExporter object used to hold the genesyscloud_telephony_providers_edges_site exporter's config
func SiteExporter() *resourceExporter.ResourceExporter <span class="cov0" title="0">{
        return &amp;resourceExporter.ResourceExporter{
                GetResourcesFunc: gcloud.GetAllWithPooledClient(getSites),
                RefAttrs: map[string]*resourceExporter.RefAttrSettings{
                        "location_id": {RefType: "genesyscloud_location"},
                        "outbound_routes.external_trunk_base_ids": {RefType: "genesyscloud_telephony_providers_edges_trunkbasesettings"},
                        "primary_sites":   {RefType: "genesyscloud_telephony_providers_edges_site"},
                        "secondary_sites": {RefType: "genesyscloud_telephony_providers_edges_site"},
                },
        }
}</span>

// DataSourceSite registers the genesyscloud_telephony_providers_edges_site data source
func DataSourceSite() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Description: "Data source for Genesys Cloud Sites. Select a site by name",
                ReadContext: gcloud.ReadWithPooledClient(dataSourceSiteRead),
                Schema: map[string]*schema.Schema{
                        "name": {
                                Description: "Site name.",
                                Type:        schema.TypeString,
                                Required:    true,
                        },
                        "managed": {
                                Description: "Return entities that are managed by Genesys Cloud.",
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package telephony_providers_edges_site

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        gcloud "terraform-provider-genesyscloud/genesyscloud"
        lists "terraform-provider-genesyscloud/genesyscloud/util/lists"
        "terraform-provider-genesyscloud/genesyscloud/util/resourcedata"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/leekchan/timeutil"
        "github.com/mypurecloud/platform-client-sdk-go/v115/platformclientv2"
)

var (
        defaultPlans = []string{"Emergency", "Extension", "National", "International", "Network", "Suicide Prevention"}
)

func customizeSiteDiff(ctx context.Context, diff *schema.ResourceDiff, meta interface{}) error <span class="cov8" title="1">{
        if diff.HasChange("number_plans") </span><span class="cov8" title="1">{
                oldNumberPlans, newNumberPlans := diff.GetChange("number_plans")
                oldNumberPlansList := oldNumberPlans.([]interface{})
                newNumberPlansList := newNumberPlans.([]interface{})

                if len(oldNumberPlansList) &lt;= len(newNumberPlansList) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">sdkConfig := meta.(*gcloud.ProviderMeta).ClientConfig
                edgesAPI := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(sdkConfig)

                siteId := diff.Id()
                if siteId == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">numberPlansFromApi, _, err := edgesAPI.GetTelephonyProvidersEdgesSiteNumberplans(siteId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get number plans from site %s: %s", siteId, err)
                }</span>

                <span class="cov8" title="1">for _, np := range numberPlansFromApi </span><span class="cov8" title="1">{
                        if isDefaultPlan(*np.Name) &amp;&amp; isNumberPlanInConfig(*np.Name, oldNumberPlansList) &amp;&amp; !isNumberPlanInConfig(*np.Name, newNumberPlansList) </span><span class="cov8" title="1">{
                                newNumberPlansList = append(newNumberPlansList, flattenNumberPlan(&amp;np))
                        }</span>
                }

                <span class="cov8" title="1">for i, x := range newNumberPlansList </span><span class="cov8" title="1">{
                        log.Printf("%v: %v", i, x)
                }</span>
                <span class="cov8" title="1">diff.SetNew("number_plans", newNumberPlansList)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateMediaRegions(ctx context.Context, sp *siteProxy, regions *[]string) error <span class="cov8" title="1">{
        telephonyRegions, err := sp.getTelephonyMediaregions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">homeRegion := telephonyRegions.AwsHomeRegion
        coreRegions := telephonyRegions.AwsCoreRegions
        satRegions := telephonyRegions.AwsSatelliteRegions

        for _, region := range *regions </span><span class="cov8" title="1">{
                if region != *homeRegion &amp;&amp;
                        !lists.ItemInSlice(region, *coreRegions) &amp;&amp;
                        !lists.ItemInSlice(region, *satRegions) </span><span class="cov0" title="0">{
                        return fmt.Errorf("region %s is not a valid media region.  please refer to the Genesys Cloud GET /api/v2/telephony/mediaregions for list of valid regions", regions)
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func nameInPlans(name string, plans []platformclientv2.Numberplan) (*platformclientv2.Numberplan, bool) <span class="cov8" title="1">{
        for _, plan := range plans </span><span class="cov8" title="1">{
                if name == *plan.Name </span><span class="cov8" title="1">{
                        return &amp;plan, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

func nameInOutboundRoutes(name string, outboundRoutes []platformclientv2.Outboundroutebase) (*platformclientv2.Outboundroutebase, bool) <span class="cov8" title="1">{
        for _, outboundRoute := range outboundRoutes </span><span class="cov8" title="1">{
                if name == *outboundRoute.Name </span><span class="cov8" title="1">{
                        return &amp;outboundRoute, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

// Contains the logic to determine if a primary or secondary site need to be updated.
func updatePrimarySecondarySites(ctx context.Context, sp *siteProxy, d *schema.ResourceData, siteId string) diag.Diagnostics <span class="cov8" title="1">{
        primarySites := lists.InterfaceListToStrings(d.Get("primary_sites").([]interface{}))
        secondarySites := lists.InterfaceListToStrings(d.Get("secondary_sites").([]interface{}))

        site, resp, err := sp.getSiteById(ctx, siteId)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return diag.Errorf("Unable to retrieve site record after site %s was created, but unable to update the primary or secondary site.  Status code %d. RespBody %s", siteId, resp.StatusCode, resp.RawBody)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Unable to retrieve site record after site %s was created, but unable to update the primary or secondary site.  Err: %s", siteId, err)
        }</span>

        <span class="cov8" title="1">if len(primarySites) == 0 &amp;&amp; len(secondarySites) &gt; 0 </span><span class="cov0" title="0">{
                der := platformclientv2.Domainentityref{Id: &amp;siteId}
                derArr := make([]platformclientv2.Domainentityref, 1)
                derArr[0] = der
                site.PrimarySites = &amp;derArr
        }</span>

        <span class="cov8" title="1">if len(primarySites) &gt; 0 </span><span class="cov0" title="0">{
                site.PrimarySites = gcloud.BuildSdkDomainEntityRefArr(d, "primary_sites")
        }</span>

        <span class="cov8" title="1">if len(secondarySites) &gt; 0 </span><span class="cov0" title="0">{
                site.SecondarySites = gcloud.BuildSdkDomainEntityRefArr(d, "secondary_sites")
        }</span>

        <span class="cov8" title="1">_, resp, err = sp.updateSite(ctx, siteId, site)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return diag.Errorf("Site %s was created, but unable to update the primary or secondary site.  Status code %d. RespBody %s", siteId, resp.StatusCode, resp.RawBody)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("[Site %s was created, but unable to update the primary or secondary site.  Err: %s", siteId, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func updateSiteNumberPlans(ctx context.Context, sp *siteProxy, d *schema.ResourceData) diag.Diagnostics <span class="cov8" title="1">{
        if !d.HasChange("number_plans") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">nps := d.Get("number_plans").([]interface{})
        if nps == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">numberPlansFromTf := make([]platformclientv2.Numberplan, 0)
        for _, np := range nps </span><span class="cov8" title="1">{
                npMap := np.(map[string]interface{})
                numberPlanFromTf := platformclientv2.Numberplan{}

                resourcedata.BuildSDKStringValueIfNotNil(&amp;numberPlanFromTf.Name, npMap, "name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;numberPlanFromTf.MatchType, npMap, "match_type")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;numberPlanFromTf.Match, npMap, "match_format")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;numberPlanFromTf.NormalizedFormat, npMap, "normalized_format")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;numberPlanFromTf.Classification, npMap, "classification")

                if numbers, ok := npMap["numbers"].([]interface{}); ok &amp;&amp; len(numbers) &gt; 0 </span><span class="cov8" title="1">{
                        sdkNumbers := make([]platformclientv2.Number, 0)
                        for _, number := range numbers </span><span class="cov8" title="1">{
                                numberMap := number.(map[string]interface{})
                                sdkNumber := platformclientv2.Number{}
                                if start, ok := numberMap["start"].(string); ok </span><span class="cov8" title="1">{
                                        sdkNumber.Start = &amp;start
                                }</span>
                                <span class="cov8" title="1">if end, ok := numberMap["end"].(string); ok </span><span class="cov8" title="1">{
                                        sdkNumber.End = &amp;end
                                }</span>
                                <span class="cov8" title="1">sdkNumbers = append(sdkNumbers, sdkNumber)</span>
                        }
                        <span class="cov8" title="1">numberPlanFromTf.Numbers = &amp;sdkNumbers</span>
                }

                <span class="cov8" title="1">if digitLength, ok := npMap["digit_length"].([]interface{}); ok &amp;&amp; len(digitLength) &gt; 0 </span><span class="cov8" title="1">{
                        sdkDigitlengthMap := digitLength[0].(map[string]interface{})
                        sdkDigitlength := platformclientv2.Digitlength{}
                        if start, ok := sdkDigitlengthMap["start"].(string); ok </span><span class="cov8" title="1">{
                                sdkDigitlength.Start = &amp;start
                        }</span>
                        <span class="cov8" title="1">if end, ok := sdkDigitlengthMap["end"].(string); ok </span><span class="cov8" title="1">{
                                sdkDigitlength.End = &amp;end
                        }</span>
                        <span class="cov8" title="1">numberPlanFromTf.DigitLength = &amp;sdkDigitlength</span>
                }

                <span class="cov8" title="1">numberPlansFromTf = append(numberPlansFromTf, numberPlanFromTf)</span>
        }

        // The default plans won't be assigned yet if there isn't a wait
        <span class="cov8" title="1">time.Sleep(5 * time.Second)

        numberPlansFromAPI, _, err := sp.getSiteNumberPlans(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to get number plans for site %s: %s", d.Id(), err)
        }</span>

        <span class="cov8" title="1">updatedNumberPlans := make([]platformclientv2.Numberplan, 0)
        namesOfOverridenDefaults := []string{}

        for _, numberPlanFromTf := range numberPlansFromTf </span><span class="cov8" title="1">{
                if plan, ok := nameInPlans(*numberPlanFromTf.Name, *numberPlansFromAPI); ok </span><span class="cov8" title="1">{
                        // Update the plan
                        plan.Classification = numberPlanFromTf.Classification
                        plan.Numbers = numberPlanFromTf.Numbers
                        plan.DigitLength = numberPlanFromTf.DigitLength
                        plan.Match = numberPlanFromTf.Match
                        plan.MatchType = numberPlanFromTf.MatchType
                        plan.NormalizedFormat = numberPlanFromTf.NormalizedFormat

                        namesOfOverridenDefaults = append(namesOfOverridenDefaults, *numberPlanFromTf.Name)
                        updatedNumberPlans = append(updatedNumberPlans, *plan)
                }</span> else<span class="cov8" title="1"> {
                        // Add the plan
                        updatedNumberPlans = append(updatedNumberPlans, numberPlanFromTf)
                }</span>
        }

        <span class="cov8" title="1">for _, numberPlanFromAPI := range *numberPlansFromAPI </span><span class="cov8" title="1">{
                // Keep the default plans which are not overriden.
                if isDefaultPlan(*numberPlanFromAPI.Name) &amp;&amp; !lists.ItemInSlice(*numberPlanFromAPI.Name, namesOfOverridenDefaults) </span><span class="cov8" title="1">{
                        updatedNumberPlans = append(updatedNumberPlans, numberPlanFromAPI)
                }</span>
        }

        <span class="cov8" title="1">diagErr := gcloud.RetryWhen(gcloud.IsStatus400, func() (*platformclientv2.APIResponse, diag.Diagnostics) </span><span class="cov8" title="1">{
                log.Printf("Updating number plans for site %s", d.Id())

                _, resp, err := sp.updateSiteNumberPlans(ctx, d.Id(), &amp;updatedNumberPlans)
                if err != nil </span><span class="cov0" title="0">{
                        respString := ""
                        if resp != nil </span><span class="cov0" title="0">{
                                respString = resp.String()
                        }</span>
                        <span class="cov0" title="0">return resp, diag.Errorf("Failed to update number plans for site %s: %s %s", d.Id(), err, respString)</span>
                }
                <span class="cov8" title="1">return resp, nil</span>
        })
        <span class="cov8" title="1">if diagErr != nil </span><span class="cov0" title="0">{
                return diagErr
        }</span>
        // Wait for the update before reading
        <span class="cov8" title="1">time.Sleep(5 * time.Second)

        return nil</span>
}

func updateSiteOutboundRoutes(ctx context.Context, sp *siteProxy, d *schema.ResourceData) diag.Diagnostics <span class="cov8" title="1">{
        if !d.HasChange("outbound_routes") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ors := d.Get("outbound_routes").(*schema.Set)
        if ors == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">orsList := ors.List()

        outboundRoutesFromTf := make([]platformclientv2.Outboundroutebase, 0)
        for _, or := range orsList </span><span class="cov8" title="1">{
                orMap := or.(map[string]interface{})
                outboundRouteFromTf := platformclientv2.Outboundroutebase{}

                resourcedata.BuildSDKStringValueIfNotNil(&amp;outboundRouteFromTf.Name, orMap, "name")
                resourcedata.BuildSDKStringValueIfNotNil(&amp;outboundRouteFromTf.Description, orMap, "description")

                if classificationTypes, ok := orMap["classification_types"].([]interface{}); ok &amp;&amp; len(classificationTypes) &gt; 0 </span><span class="cov8" title="1">{
                        cts := make([]string, 0)
                        for _, classificationType := range classificationTypes </span><span class="cov8" title="1">{
                                cts = append(cts, classificationType.(string))
                        }</span>
                        <span class="cov8" title="1">outboundRouteFromTf.ClassificationTypes = &amp;cts</span>
                }
                <span class="cov8" title="1">if enabled, ok := orMap["enabled"].(bool); ok </span><span class="cov8" title="1">{
                        outboundRouteFromTf.Enabled = &amp;enabled
                }</span>
                <span class="cov8" title="1">resourcedata.BuildSDKStringValueIfNotNil(&amp;outboundRouteFromTf.Distribution, orMap, "distribution")

                if externalTrunkBaseIds, ok := orMap["external_trunk_base_ids"].([]interface{}); ok &amp;&amp; len(externalTrunkBaseIds) &gt; 0 </span><span class="cov8" title="1">{
                        ids := make([]platformclientv2.Domainentityref, 0)
                        for _, externalTrunkBaseId := range externalTrunkBaseIds </span><span class="cov8" title="1">{
                                externalTrunkBaseIdStr := externalTrunkBaseId.(string)
                                ids = append(ids, platformclientv2.Domainentityref{Id: &amp;externalTrunkBaseIdStr})
                        }</span>
                        <span class="cov8" title="1">outboundRouteFromTf.ExternalTrunkBases = &amp;ids</span>
                }

                <span class="cov8" title="1">outboundRoutesFromTf = append(outboundRoutesFromTf, outboundRouteFromTf)</span>
        }

        // The default outbound routes won't be assigned yet if there isn't a wait
        <span class="cov8" title="1">time.Sleep(5 * time.Second)

        // Get the current outbound routes
        outboundRoutesFromAPI, err := sp.getSiteOutboundRoutes(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.Errorf("Failed to get outbound routes for site %s: %s", d.Id(), err)
        }</span>

        // Delete unwanted outbound roues first to free up classifications assigned to them
        <span class="cov8" title="1">for _, outboundRouteFromAPI := range *outboundRoutesFromAPI </span><span class="cov8" title="1">{
                // Delete route if no reference to it
                if _, ok := nameInOutboundRoutes(*outboundRouteFromAPI.Name, outboundRoutesFromTf); !ok </span><span class="cov8" title="1">{
                        resp, err := sp.deleteSiteOutboundRoute(ctx, d.Id(), *outboundRouteFromAPI.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return diag.Errorf("failed to delete outbound route from site %s: %s", d.Id(), err)</span>
                        }
                }
        }
        <span class="cov8" title="1">time.Sleep(2 * time.Second)

        // Update the outbound routes
        for _, outboundRouteFromTf := range outboundRoutesFromTf </span><span class="cov8" title="1">{
                if outboundRoute, ok := nameInOutboundRoutes(*outboundRouteFromTf.Name, *outboundRoutesFromAPI); ok </span><span class="cov8" title="1">{
                        // Update the outbound route
                        outboundRoute.Name = outboundRouteFromTf.Name
                        outboundRoute.Description = outboundRouteFromTf.Description
                        outboundRoute.ClassificationTypes = outboundRouteFromTf.ClassificationTypes
                        outboundRoute.Enabled = outboundRouteFromTf.Enabled
                        outboundRoute.Distribution = outboundRouteFromTf.Distribution
                        outboundRoute.ExternalTrunkBases = outboundRouteFromTf.ExternalTrunkBases

                        _, err := sp.updateSiteOutboundRoute(ctx, d.Id(), *outboundRoute.Id, outboundRoute)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.Errorf("Failed to update outbound route with id %s for site %s: %s", *outboundRoute.Id, d.Id(), err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Add the outbound route
                        _, err := sp.createSiteOutboundRoute(ctx, d.Id(), &amp;outboundRouteFromTf)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.Errorf("Failed to add outbound route to site %s: %s", d.Id(), err)
                        }</span>
                }
        }

        // Wait for the update before reading
        <span class="cov8" title="1">time.Sleep(5 * time.Second)

        return nil</span>
}

func isDefaultPlan(name string) bool <span class="cov8" title="1">{
        for _, defaultPlan := range defaultPlans </span><span class="cov8" title="1">{
                if name == defaultPlan </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isNumberPlanInConfig returns true if the number plan's name is in the config list
func isNumberPlanInConfig(planName string, list []interface{}) bool <span class="cov8" title="1">{
        for _, plan := range list </span><span class="cov8" title="1">{
                planMap := plan.(map[string]interface{})
                if planName == planMap["name"] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func readSiteNumberPlans(ctx context.Context, sp *siteProxy, d *schema.ResourceData) *retry.RetryError <span class="cov8" title="1">{
        numberPlans, resp, err := sp.getSiteNumberPlans(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                if gcloud.IsStatus404(resp) </span><span class="cov0" title="0">{
                        d.SetId("") // Site doesn't exist
                        return nil
                }</span>
                <span class="cov0" title="0">return retry.NonRetryableError(fmt.Errorf("failed to read number plans for site %s: %s", d.Id(), err))</span>
        }

        <span class="cov8" title="1">dNumberPlans := make([]interface{}, 0)
        if len(*numberPlans) &gt; 0 </span><span class="cov8" title="1">{
                for _, numberPlan := range *numberPlans </span><span class="cov8" title="1">{
                        dNumberPlan := flattenNumberPlan(&amp;numberPlan)
                        dNumberPlans = append(dNumberPlans, dNumberPlan)
                }</span>
                <span class="cov8" title="1">d.Set("number_plans", dNumberPlans)</span>
        } else<span class="cov8" title="1"> {
                d.Set("number_plans", nil)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func readSiteOutboundRoutes(ctx context.Context, sp *siteProxy, d *schema.ResourceData) *retry.RetryError <span class="cov8" title="1">{
        outboundRoutes, err := sp.getSiteOutboundRoutes(ctx, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return retry.NonRetryableError(fmt.Errorf("failed to get outbound routes for site %s: %s", d.Id(), err))
        }</span>

        <span class="cov8" title="1">dOutboundRoutes := schema.NewSet(schema.HashResource(outboundRouteSchema), []interface{}{})

        if len(*outboundRoutes) &gt; 0 </span><span class="cov8" title="1">{
                for _, outboundRoute := range *outboundRoutes </span><span class="cov8" title="1">{
                        dOutboundRoute := make(map[string]interface{})
                        dOutboundRoute["name"] = *outboundRoute.Name

                        resourcedata.SetMapValueIfNotNil(dOutboundRoute, "description", outboundRoute.Description)
                        resourcedata.SetMapValueIfNotNil(dOutboundRoute, "enabled", outboundRoute.Enabled)
                        resourcedata.SetMapValueIfNotNil(dOutboundRoute, "distribution", outboundRoute.Distribution)

                        if outboundRoute.ClassificationTypes != nil </span><span class="cov8" title="1">{
                                dOutboundRoute["classification_types"] = lists.StringListToInterfaceList(*outboundRoute.ClassificationTypes)
                        }</span>

                        <span class="cov8" title="1">if len(*outboundRoute.ExternalTrunkBases) &gt; 0 </span><span class="cov8" title="1">{
                                externalTrunkBaseIds := make([]string, 0)
                                for _, externalTrunkBase := range *outboundRoute.ExternalTrunkBases </span><span class="cov8" title="1">{
                                        externalTrunkBaseIds = append(externalTrunkBaseIds, *externalTrunkBase.Id)
                                }</span>
                                <span class="cov8" title="1">dOutboundRoute["external_trunk_base_ids"] = lists.StringListToInterfaceList(externalTrunkBaseIds)</span>
                        }

                        <span class="cov8" title="1">dOutboundRoutes.Add(dOutboundRoute)</span>
                }
                <span class="cov8" title="1">d.Set("outbound_routes", dOutboundRoutes)</span>
        } else<span class="cov8" title="1"> {
                d.Set("outbound_routes", nil)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func flattenSdkEdgeAutoUpdateConfig(edgeAutoUpdateConfig *platformclientv2.Edgeautoupdateconfig) []interface{} <span class="cov8" title="1">{
        if edgeAutoUpdateConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">edgeAutoUpdateConfigMap := make(map[string]interface{})
        edgeAutoUpdateConfigMap["time_zone"] = *edgeAutoUpdateConfig.TimeZone
        edgeAutoUpdateConfigMap["rrule"] = *edgeAutoUpdateConfig.Rrule
        edgeAutoUpdateConfigMap["start"] = timeutil.Strftime(edgeAutoUpdateConfig.Start, "%Y-%m-%dT%H:%M:%S.%f")
        edgeAutoUpdateConfigMap["end"] = timeutil.Strftime(edgeAutoUpdateConfig.End, "%Y-%m-%dT%H:%M:%S.%f")

        return []interface{}{edgeAutoUpdateConfigMap}</span>
}

func flattenNumberPlan(numberPlan *platformclientv2.Numberplan) interface{} <span class="cov8" title="1">{
        dNumberPlan := make(map[string]interface{})
        dNumberPlan["name"] = *numberPlan.Name

        resourcedata.SetMapValueIfNotNil(dNumberPlan, "match_format", numberPlan.Match)
        resourcedata.SetMapValueIfNotNil(dNumberPlan, "normalized_format", numberPlan.NormalizedFormat)
        resourcedata.SetMapValueIfNotNil(dNumberPlan, "classification", numberPlan.Classification)
        resourcedata.SetMapValueIfNotNil(dNumberPlan, "match_type", numberPlan.MatchType)

        if numberPlan.Numbers != nil </span><span class="cov8" title="1">{
                numbers := make([]interface{}, 0)
                for _, number := range *numberPlan.Numbers </span><span class="cov8" title="1">{
                        numberMap := make(map[string]interface{})
                        if number.Start != nil </span><span class="cov8" title="1">{
                                numberMap["start"] = *number.Start
                        }</span>
                        <span class="cov8" title="1">if number.End != nil </span><span class="cov8" title="1">{
                                numberMap["end"] = *number.End
                        }</span>
                        <span class="cov8" title="1">numbers = append(numbers, numberMap)</span>
                }
                <span class="cov8" title="1">dNumberPlan["numbers"] = numbers</span>
        }
        <span class="cov8" title="1">if numberPlan.DigitLength != nil </span><span class="cov8" title="1">{
                digitLength := make([]interface{}, 0)
                digitLengthMap := make(map[string]interface{})
                if numberPlan.DigitLength.Start != nil </span><span class="cov8" title="1">{
                        digitLengthMap["start"] = *numberPlan.DigitLength.Start
                }</span>
                <span class="cov8" title="1">if numberPlan.DigitLength.End != nil </span><span class="cov8" title="1">{
                        digitLengthMap["end"] = *numberPlan.DigitLength.End
                }</span>
                <span class="cov8" title="1">digitLength = append(digitLength, digitLengthMap)
                dNumberPlan["digit_length"] = digitLength</span>
        }
        <span class="cov8" title="1">return dNumberPlan</span>
}

func buildSdkEdgeAutoUpdateConfig(d *schema.ResourceData) (*platformclientv2.Edgeautoupdateconfig, error) <span class="cov8" title="1">{
        if edgeAutoUpdateConfig := d.Get("edge_auto_update_config"); edgeAutoUpdateConfig != nil </span><span class="cov8" title="1">{
                if edgeAutoUpdateConfigList := edgeAutoUpdateConfig.([]interface{}); len(edgeAutoUpdateConfigList) &gt; 0 </span><span class="cov8" title="1">{
                        edgeAutoUpdateConfigMap := edgeAutoUpdateConfigList[0].(map[string]interface{})

                        timeZone := edgeAutoUpdateConfigMap["time_zone"].(string)
                        rrule := edgeAutoUpdateConfigMap["rrule"].(string)
                        startStr := edgeAutoUpdateConfigMap["start"].(string)
                        endStr := edgeAutoUpdateConfigMap["end"].(string)

                        start, err := time.Parse("2006-01-02T15:04:05.000000", startStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse date %s: %s", startStr, err)
                        }</span>

                        <span class="cov8" title="1">end, err := time.Parse("2006-01-02T15:04:05.000000", endStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse date %s: %s", end, err)
                        }</span>

                        <span class="cov8" title="1">return &amp;platformclientv2.Edgeautoupdateconfig{
                                TimeZone: &amp;timeZone,
                                Rrule:    &amp;rrule,
                                Start:    &amp;start,
                                End:      &amp;end,
                        }, nil</span>
                }
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func GenerateSiteResourceWithCustomAttrs(
        siteRes,
        name,
        description,
        locationId,
        mediaModel string,
        mediaRegionsUseLatencyBased bool,
        mediaRegions string,
        callerId string,
        callerName string,
        otherAttrs ...string) string <span class="cov8" title="1">{
        return fmt.Sprintf(`resource "genesyscloud_telephony_providers_edges_site" "%s" {
                name = "%s"
                description = "%s"
                location_id = %s
                media_model = "%s"
                media_regions_use_latency_based = %v
                media_regions= %s
                caller_id = %s
                caller_name = %s
                %s
        }
        `, siteRes, name, description, locationId, mediaModel, mediaRegionsUseLatencyBased, mediaRegions, callerId, callerName, strings.Join(otherAttrs, "\n"))
}</span>

// DeleteLocationWithNumber is a test utiliy function to delete site and location with the provided emergency number
func DeleteLocationWithNumber(emergencyNumber string) error <span class="cov8" title="1">{
        sdkConfig := platformclientv2.GetDefaultConfiguration()
        locationsAPI := platformclientv2.NewLocationsApiWithConfig(sdkConfig)

        for pageNum := 1; ; pageNum++ </span><span class="cov8" title="1">{
                const pageSize = 100
                locations, _, getErr := locationsAPI.GetLocations(pageSize, pageNum, nil, "")
                if getErr != nil </span><span class="cov0" title="0">{
                        return getErr
                }</span>

                <span class="cov8" title="1">if locations.Entities == nil || len(*locations.Entities) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">for _, location := range *locations.Entities </span><span class="cov8" title="1">{
                        if location.EmergencyNumber != nil </span><span class="cov8" title="1">{
                                if strings.Contains(*location.EmergencyNumber.E164, emergencyNumber) </span><span class="cov0" title="0">{
                                        err := deleteSiteWithLocationId(*location.Id)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">_, err = locationsAPI.DeleteLocation(*location.Id)
                                        time.Sleep(30 * time.Second)
                                        return err</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// deleteSiteWithLocationId is a test utility function that will
// delete a site with the provided location id
func deleteSiteWithLocationId(locationId string) error <span class="cov0" title="0">{
        sdkConfig := platformclientv2.GetDefaultConfiguration()
        edgesAPI := platformclientv2.NewTelephonyProvidersEdgeApiWithConfig(sdkConfig)
        for pageNum := 1; ; pageNum++ </span><span class="cov0" title="0">{
                const pageSize = 100
                sites, _, getErr := edgesAPI.GetTelephonyProvidersEdgesSites(pageSize, pageNum, "", "", "", "", false)
                if getErr != nil </span><span class="cov0" title="0">{
                        return getErr
                }</span>

                <span class="cov0" title="0">if sites.Entities == nil || len(*sites.Entities) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">for _, site := range *sites.Entities </span><span class="cov0" title="0">{
                        if site.Location != nil &amp;&amp; *site.Location.Id == locationId </span><span class="cov0" title="0">{
                                _, err := edgesAPI.DeleteTelephonyProvidersEdgesSite(*site.Id)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">time.Sleep(8 * time.Second)
                                break</span>
                        }
                }
        }
}

// getOrganizationDefaultSite is a test utiliy function to get the default site ID of the org
func GetOrganizationDefaultSiteId() (siteId string, err error) <span class="cov8" title="1">{
        sdkConfig := platformclientv2.GetDefaultConfiguration()
        organizationApi := platformclientv2.NewOrganizationApiWithConfig(sdkConfig)

        org, _, err := organizationApi.GetOrganizationsMe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if org.DefaultSiteId == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return *org.DefaultSiteId, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package chunks

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        u "github.com/rjNemo/underscore"
)

func seqGen() func() int <span class="cov0" title="0">{
        seq := -1 // Initialize sequence

        return func() int </span><span class="cov0" title="0">{
                seq++
                return seq
        }</span>
}

// Generic function to chunk given Items based on the size provided.
func ChunkBy[T any](items []T, chunkSize int) (chunks [][]T) <span class="cov8" title="1">{
        for chunkSize &lt; len(items) </span><span class="cov8" title="1">{
                items, chunks = items[chunkSize:], append(chunks, items[0:chunkSize:chunkSize])
        }</span>
        <span class="cov8" title="1">return append(chunks, items)</span>
}

// Generic function to Map each Item in Items based on a transform/builder function
func mapItems[T, P any](items []T, mapBuilder func(T) P) []P <span class="cov8" title="1">{
        return u.Map(items, func(item T) P </span><span class="cov8" title="1">{
                return mapBuilder(item)
        }</span>)
}

// Generic function that Chunks the Items and then Maps
func ChunkItems[T, P any](items []T, mapBuilder func(T) P, chunkSize int) (chunks [][]P) <span class="cov8" title="1">{
        mappedItems := mapItems(items, mapBuilder)
        return ChunkBy(mappedItems, chunkSize)
}</span>

// Generic function that takes array of Chunks and then Processes each Chunk with the defined Funcion.
// Typically Processor Function would be a REST API call

func ProcessChunks[T any](chunks []T, chunkProcessor func(T) diag.Diagnostics) diag.Diagnostics <span class="cov8" title="1">{
        var err diag.Diagnostics
        u.Map(chunks, func(chunk T) diag.Diagnostics </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">err = chunkProcessor(chunk)
                return err</span>
        })

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package files

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "path"
        "strings"
)

type S3Uploader struct {
        reader        io.Reader
        formData      map[string]io.Reader
        bodyBuf       *bytes.Buffer
        writer        *multipart.Writer
        substitutions map[string]interface{}
        headers       map[string]string
        httpMethod    string
        presignedUrl  string
        client        http.Client
}

func NewS3Uploader(reader io.Reader, formData map[string]io.Reader, substitutions map[string]interface{}, headers map[string]string, method, presignedUrl string) *S3Uploader <span class="cov8" title="1">{
        c := &amp;http.Client{}
        var bodyBuf bytes.Buffer
        writer := multipart.NewWriter(&amp;bodyBuf)
        s3Uploader := &amp;S3Uploader{
                reader:        reader,
                formData:      formData,
                bodyBuf:       &amp;bodyBuf,
                writer:        writer,
                substitutions: substitutions,
                headers:       headers,
                httpMethod:    method,
                presignedUrl:  presignedUrl,
                client:        *c,
        }
        return s3Uploader
}</span>

func (s *S3Uploader) substituteValues() <span class="cov8" title="1">{
        // Attribute specific to the flows resource
        if s.substitutions != nil &amp;&amp; len(s.substitutions) &gt; 0 </span><span class="cov8" title="1">{
                fileContents := s.bodyBuf.String()
                for k, v := range s.substitutions </span><span class="cov8" title="1">{
                        fileContents = strings.Replace(fileContents, fmt.Sprintf("{{%s}}", k), v.(string), -1)
                }</span>

                <span class="cov8" title="1">s.bodyBuf.Reset()
                s.bodyBuf.WriteString(fileContents)</span>
        }
}

func (s *S3Uploader) Upload() ([]byte, error) <span class="cov8" title="1">{
        if s.formData != nil &amp;&amp; len(s.formData) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.createFormData(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">s.headers["Content-Type"] = s.writer.FormDataContentType()</span>
        } else<span class="cov8" title="1"> {
                _, err := io.Copy(s.bodyBuf, s.reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to copy file content to the handler. Error: %s ", err)
                }</span>
        }

        <span class="cov8" title="1">s.substituteValues()

        req, _ := http.NewRequest(s.httpMethod, s.presignedUrl, s.bodyBuf)
        for key, value := range s.headers </span><span class="cov8" title="1">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov8" title="1">resp, err := s.client.Do(req)
        if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov8" title="1">{
                defer resp.Body.Close()
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload file to S3 bucket with an error. Error: %s", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to upload file to S3 bucket with an HTTP status code of %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">response, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body when uploading file. %s", err)
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}

func (s *S3Uploader) createFormData() error <span class="cov8" title="1">{
        defer s.writer.Close()
        for key, r := range s.formData </span><span class="cov8" title="1">{
                var (
                        fw  io.Writer
                        err error
                )
                if r == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if x, ok := r.(io.Closer); ok </span><span class="cov0" title="0">{
                        defer x.Close()
                }</span>
                <span class="cov8" title="1">if file, ok := r.(*os.File); ok </span><span class="cov0" title="0">{
                        fw, err = s.writer.CreateFormFile(key, file.Name())
                }</span> else<span class="cov8" title="1"> {
                        fw, err = s.writer.CreateFormField(key)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := io.Copy(fw, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func DownloadOrOpenFile(path string) (io.Reader, *os.File, error) <span class="cov0" title="0">{
        var reader io.Reader
        var file *os.File

        _, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                _, err = url.ParseRequestURI(path)
                if err == nil </span><span class="cov0" title="0">{
                        resp, err := http.Get(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">if resp.StatusCode &lt; http.StatusOK || resp.StatusCode &gt;= http.StatusMultipleChoices </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("HTTP Error downloading file: %v", resp.StatusCode)
                        }</span>
                        <span class="cov0" title="0">reader = resp.Body</span>
                } else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("Invalid file path or URL: %v", path)
                }</span>
        } else<span class="cov0" title="0"> {
                file, err = os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">reader = file</span>
        }

        <span class="cov0" title="0">return reader, file, nil</span>
}

// Download file from uri to directory/fileName
func DownloadExportFile(directory, fileName, uri string) error <span class="cov0" title="0">{
        resp, err := http.Get(uri)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        out, err := os.Create(path.Join(directory, fileName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, resp.Body)
        return err</span>
}

// Hash file content, used in stateFunc for "filepath" type attributes
func hashFileContent(path string) string <span class="cov0" title="0">{
        reader, file, err := DownloadOrOpenFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">if file != nil </span><span class="cov0" title="0">{
                defer file.Close()
        }</span>

        <span class="cov0" title="0">hash := sha256.New()
        if file == nil </span><span class="cov0" title="0">{
                if _, err := io.Copy(hash, reader); err != nil </span><span class="cov0" title="0">{
                        return err.Error()
                }</span>
        } else<span class="cov0" title="0"> {
                if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                        return err.Error()
                }</span>
        }

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil))</span>
}

// Read and upload input file path to S3 pre-signed URL
func prepareAndUploadFile(filename string, substitutions map[string]interface{}, headers map[string]string, presignedUrl string) ([]byte, error) <span class="cov0" title="0">{
        bodyBuf := &amp;bytes.Buffer{}

        reader, file, err := DownloadOrOpenFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if file != nil </span><span class="cov0" title="0">{
                defer file.Close()
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(bodyBuf, reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to copy file content to the handler. Error: %s ", err)
        }</span>

        // Attribute specific to the flows resource
        <span class="cov0" title="0">if len(substitutions) &gt; 0 </span><span class="cov0" title="0">{
                fileContents := bodyBuf.String()
                for k, v := range substitutions </span><span class="cov0" title="0">{
                        fileContents = strings.Replace(fileContents, fmt.Sprintf("{{%s}}", k), v.(string), -1)
                }</span>

                <span class="cov0" title="0">bodyBuf.Reset()
                bodyBuf.WriteString(fileContents)</span>
        }

        <span class="cov0" title="0">req, _ := http.NewRequest("PUT", presignedUrl, bodyBuf)
        for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}

        resp, err := client.Do(req)
        if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov0" title="0">{
                defer resp.Body.Close()
        }</span>

        <span class="cov0" title="0">if err != nil || resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to upload file to S3 bucket. Error: %s ", err)
        }</span>

        <span class="cov0" title="0">response, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to read response body when uploading file. %s", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package lists

func ChunkStringSlice(slice []string, chunkSize int) [][]string <span class="cov8" title="1">{
        var chunks [][]string
        for i := 0; i &lt; len(slice); i += chunkSize </span><span class="cov8" title="1">{
                end := i + chunkSize
                // check to avoid slicing beyond slice capacity
                if end &gt; len(slice) </span><span class="cov8" title="1">{
                        end = len(slice)
                }</span>
                <span class="cov8" title="1">chunks = append(chunks, slice[i:end])</span>
        }
        <span class="cov8" title="1">return chunks</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package lists

import (
        "sort"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func ItemInSlice[T comparable](a T, list []T) bool <span class="cov0" title="0">{
        for _, b := range list </span><span class="cov0" title="0">{
                if b == a </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func RemoveStringFromSlice(value string, slice []string) []string <span class="cov0" title="0">{
        s := make([]string, 0)
        for _, v := range slice </span><span class="cov0" title="0">{
                if v != value </span><span class="cov0" title="0">{
                        s = append(s, v)
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

func SubStringInSlice(a string, list []string) bool <span class="cov0" title="0">{
        for _, b := range list </span><span class="cov0" title="0">{
                if strings.Contains(b, a) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// difference returns the elements in a that aren't in b
func SliceDifference(a, b []string) []string <span class="cov0" title="0">{
        var diff []string
        if len(a) == 0 </span><span class="cov0" title="0">{
                return diff
        }</span>
        <span class="cov0" title="0">mb := make(map[string]struct{}, len(b))
        for _, x := range b </span><span class="cov0" title="0">{
                mb[x] = struct{}{}
        }</span>
        <span class="cov0" title="0">for _, x := range a </span><span class="cov0" title="0">{
                if _, found := mb[x]; !found </span><span class="cov0" title="0">{
                        diff = append(diff, x)
                }</span>
        }
        <span class="cov0" title="0">return diff</span>
}

// AreEquivalent takes two string lists and returns true if they are equivalent, ignoring the ordering of the items.
func AreEquivalent(a []string, b []string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">aCopy := make([]string, len(a))
        copy(aCopy, a)
        bCopy := make([]string, len(b))
        copy(bCopy, b)

        sort.Strings(aCopy)
        sort.Strings(bCopy)

        for i := 0; i &lt; len(aCopy); i++ </span><span class="cov8" title="1">{
                if aCopy[i] != bCopy[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func StringListToSet(list []string) *schema.Set <span class="cov0" title="0">{
        interfaceList := make([]interface{}, len(list))
        for i, v := range list </span><span class="cov0" title="0">{
                interfaceList[i] = v
        }</span>
        <span class="cov0" title="0">return schema.NewSet(schema.HashString, interfaceList)</span>
}

func StringListToSetOrNil(list *[]string) *schema.Set <span class="cov0" title="0">{
        if list == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return StringListToSet(*list)</span>
}

func StringListToInterfaceList(list []string) []interface{} <span class="cov0" title="0">{
        interfaceList := make([]interface{}, len(list))
        for i, v := range list </span><span class="cov0" title="0">{
                interfaceList[i] = v
        }</span>
        <span class="cov0" title="0">return interfaceList</span>
}

func SetToStringList(strSet *schema.Set) *[]string <span class="cov0" title="0">{
        interfaceList := strSet.List()
        strList := InterfaceListToStrings(interfaceList)
        return &amp;strList
}</span>

func InterfaceListToStrings(interfaceList []interface{}) []string <span class="cov0" title="0">{
        strs := make([]string, len(interfaceList))
        for i, val := range interfaceList </span><span class="cov0" title="0">{
                strs[i] = val.(string)
        }</span>
        <span class="cov0" title="0">return strs</span>
}

func BuildSdkStringList(d *schema.ResourceData, attrName string) *[]string <span class="cov0" title="0">{
        if val, ok := d.GetOk(attrName); ok </span><span class="cov0" title="0">{
                return SetToStringList(val.(*schema.Set))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func BuildSdkStringListFromInterfaceArray(d *schema.ResourceData, attrName string) *[]string <span class="cov0" title="0">{
        var stringArray []string
        if val, ok := d.GetOk(attrName); ok </span><span class="cov0" title="0">{
                if valArray, ok := val.([]interface{}); ok </span><span class="cov0" title="0">{
                        stringArray = InterfaceListToStrings(valArray)
                }</span>
        }
        <span class="cov0" title="0">return &amp;stringArray</span>
}

func FlattenList[T interface{}](resourceList *[]T, elementFlattener func(resource *T) map[string]interface{}) *[]map[string]interface{} <span class="cov0" title="0">{
        if resourceList == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var resultList []map[string]interface{}

        for _, resource := range *resourceList </span><span class="cov0" title="0">{
                resultList = append(resultList, elementFlattener(&amp;resource))
        }</span>
        <span class="cov0" title="0">return &amp;resultList</span>
}

func FlattenAsList[T interface{}](resource *T, elementFlattener func(resource *T) map[string]interface{}) *[]map[string]interface{} <span class="cov0" title="0">{
        if resource == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">flattened := elementFlattener(resource)
        if flattened != nil </span><span class="cov0" title="0">{
                return &amp;[]map[string]interface{}{flattened}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NilToEmptyList[T interface{}](list *[]T) *[]T <span class="cov0" title="0">{
        if list == nil </span><span class="cov0" title="0">{
                emptyArray := []T{}
                return &amp;emptyArray
        }</span>
        <span class="cov0" title="0">return list</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package typeconv

import (
        "fmt"
        "strconv"
)

func Float32to64(float32Value *float32) *float64 <span class="cov8" title="1">{
        if float32Value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">floatString := fmt.Sprintf("%f", *float32Value)
        float64Value, _ := strconv.ParseFloat(floatString, 64)
        return &amp;float64Value</span>
}

func Float64to32(float64Value *float64) *float32 <span class="cov0" title="0">{
        if float64Value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">float32Value := float32(*float64Value)
        return &amp;float32Value</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
